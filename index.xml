<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SECBIT Blog</title>
    <link>https://sec-bit.github.io/blog/</link>
    <description>Recent content on SECBIT Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 28 Oct 2019 08:00:00 +0800</lastBuildDate>
    
        <atom:link href="https://sec-bit.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如果量子计算时代到来，我们的比特币安全吗？</title>
      <link>https://sec-bit.github.io/blog/2019/10/28/bitcoin-safety-in-the-coming-era-of-quantum-computing/</link>
      <pubDate>Mon, 28 Oct 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/10/28/bitcoin-safety-in-the-coming-era-of-quantum-computing/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;量子计算对挖矿的影响更多的是芯片升级的经济问题，而不是安全问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/D1nY0ukwj2svqcQMX02CuA&#34;&gt;本文首发于链闻&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;撰文：李画、安比实验室创始人郭宇&lt;/p&gt;

&lt;p&gt;校正：郭宇&lt;/p&gt;

&lt;p&gt;每次有量子计算的新闻出现时，人们都要担心一次比特币。原因很简单，比特币是基于密码学的，而密码学之所以能够成立，是基于某种计算上的不可能性。如果量子计算把原本不可能或难以实现的计算变成可以计算，那么这种密码学的方法就会失效。&lt;/p&gt;

&lt;p&gt;但&lt;strong&gt;这种担心是多余的&lt;/strong&gt;。原因同样简单：我们只要有量子计算也无法完成的计算，不就可以吗？以这种计算为基础构建的密码学方法（ &lt;em&gt;量子安全密码学&lt;/em&gt; ），量子计算也就无法破解，然后把比特币升级到该密码学方法之下即可。&lt;/p&gt;

&lt;p&gt;「格困难问题」就是典型的代表，即便对于量子计算，它也保持着计算上的不可能性。基于人类的「无知」，我们很大程度上总可以找到方法生活在密码学的保护之下。&lt;/p&gt;

&lt;h2 id=&#34;比特币中的密码算法&#34;&gt;比特币中的密码算法&lt;/h2&gt;

&lt;p&gt;我们知道比特币钱包地址对应一个公钥和一个私钥，只有拥有私钥才能动用该钱包中的比特币，但私钥是安全的，它无法通过钱包地址或公钥被计算出来。&lt;/p&gt;

&lt;p&gt;这是如何实现的？让我们从台球厅开始。&lt;/p&gt;

&lt;p&gt;你去台球厅打台球，把一个球放在台球桌底边的一个位置上，就叫它 A 点，然后你把这个球打出去，假设你击球的力气超级大，那么球从 A 点出发，总会撞到台球桌某条边上的一个点，然后又会从该点弹到台球桌另一条边上的另一个点……它可能这样弹了 B 次（ &lt;em&gt;比如一万次&lt;/em&gt; ），最后停在了台球桌某条边的一个点上，就叫它 C 点。&lt;/p&gt;

&lt;p&gt;这时候你的朋友来了，他能看见台球在 C 点的位置，你告诉他这个球最初的位置 A 点和击球的角度，问他这个球中间弹了多少次，也就是 B 是多少？你的朋友应该一时回答不上来。&lt;/p&gt;

&lt;p&gt;这就是一个简单的公、私钥生成算法，C（ &lt;em&gt;位置&lt;/em&gt; ）是公钥，B（ &lt;em&gt;次数&lt;/em&gt; ）是私钥。在我们知道 A 点和 B 次弹跳的情况下，是能得到 C 点的；但如果我们只知道 A 点和 C 点，是很难算出弹跳次数 B 的。&lt;/p&gt;

&lt;p&gt;在真正的密码学中，台球桌的边被换成了&lt;strong&gt;椭圆曲线&lt;/strong&gt;，A 是椭圆曲线（ &lt;em&gt;其实是椭圆群&lt;/em&gt; ）上一个固定的点，它击打自己（ &lt;em&gt;球从该点的切线位置被击打出去&lt;/em&gt; ），球在椭圆群里撞来撞去撞了 B 次，最后落在了椭圆群的一个点上，还要对该点再做一次映射，有了椭圆群上的一个点 C。C 是公钥，B 是私钥。&lt;/p&gt;

&lt;p&gt;这就是著名的&lt;strong&gt;椭圆曲线算法&lt;/strong&gt;，&lt;strong&gt;被用于生成公钥、私钥，是比特币系统中的第一个密码学方法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;椭圆曲线算法难以被破解（ &lt;em&gt;基于「离散对数困难问题」&lt;/em&gt; ），但&lt;strong&gt;并非不能被破解，足够强大的量子计算可以找到多项式算法&lt;/strong&gt;，通过 A 和 C 计算出 B，也就是可以通过公钥算出私钥。所以，&lt;strong&gt;如果真的进入到量子计算时代，椭圆曲线算法是需要被新的抗量子计算的算法替换的&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;量子计算与椭圆曲线算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比特币采用的椭圆曲线数字签名算法的安全性是 2^128（secp256-k1 曲线群的阶接近于 2^256，椭圆曲线攻击算法的复杂度大约都是 O(sqrt(N))，对 2^256 开平方，得到2^128 ）。这是个天文数字。&lt;/p&gt;

&lt;p&gt;在量子计算的情况下，使用 Peter Shor 提出的 Shor 算法，它攻击椭圆曲线的复杂度大概是 O(log(N)^3) ，对于比特币而言，理论上的计算量级是 128^3 次。&lt;/p&gt;

&lt;p&gt;相关论文研究显示，构造一个攻击 secp256-k1 曲线的量子计算机，假设该计算机能把比特错误率降低到 10^-4，那么有希望在使用 170 万个量子比特的情况下，在 7 天之内完成计算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在比特币系统中，还有另一个密码学方法，&lt;strong&gt;哈希函数 SHA-256&lt;/strong&gt;，它&lt;strong&gt;被用于生成与公钥对应的钱包地址&lt;/strong&gt;。该算法很好理解，&lt;strong&gt;就是把一个输入以一种不可逆的方式转换成一个输出，它有非常强的单向性，想通过输出来计算输入是不可能的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因此，&lt;strong&gt;哈希函数只能通过暴力的方式破解&lt;/strong&gt;，也就是变换输入值一次次去试，直到可以用某个输入值算出目标输出值。&lt;/p&gt;

&lt;p&gt;相较于经典计算机，&lt;strong&gt;量子计算机在暴力搜索上具有可观的优势&lt;/strong&gt;，不过仍然是一种多项式级别的性能优化，我们&lt;strong&gt;可以通过加倍安全位数，比如采用 SHA-512 来维持安全性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比特币钱包地址是公钥经过两次哈希计算得到的，一次是 &lt;strong&gt;SHA-256&lt;/strong&gt;，一次是 &lt;strong&gt;RIPEMD-160&lt;/strong&gt;（ &lt;em&gt;另一种哈希函数&lt;/em&gt; ），量子计算很难攻破两道哈希关口，通过钱包地址「撞」出公钥。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;量子计算与 SHA-256&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;目前在量子算法里可以加速计算SHA-256 的是Lov Grover 在1996年提出来的 Grover 算法，它可以将暴力搜索的性能提高到平方倍。假设我们要在一个 N× N 的巨大方格里寻找一根针，经典计算机需要逐一搜索每一个方格，最坏情况下需要搜索N×N 次；但Grover 算法即使是在最坏的情况下也只需要搜索 N 次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;：比特币中有两种基础密码算法，一是椭圆曲线算法，一是哈希函数 SHA-256。目前能够找到前者的高效量子计算方法，实现破解；但并没有找到后者的高效量子计算方法。当然，破解的前提是量子计算真的发展到足够强大，要知道，谷歌最新的量子芯片只有 54 个量子比特。&lt;/p&gt;

&lt;h2 id=&#34;我们的比特币安全吗&#34;&gt;我们的比特币安全吗？&lt;/h2&gt;

&lt;p&gt;如果进入到量子计算时代，我们只需要用抗量子计算的密码学算法生成公钥、私钥、钱包地址即可。但假如用户未能升级公钥私钥，他们钱包中的比特币是否就一定会被窃取？答案是否定的。&lt;/p&gt;

&lt;p&gt;大致有如下几种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果钱包地址中的比特币从未被使用过，那么该地址的公钥是不被人知晓的，其他人所知道的只有钱包地址（ &lt;em&gt;只有当我们花费某地址上的比特币时才需要给出公钥，不过哪怕只花费过一次，公钥就会被广播到全网&lt;/em&gt; ）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如前文所述，SHA-256 是难以被量子计算破解的，这意味着其他人是无法通过钱包地址算出公钥的。所以，即使可以通过公钥算出私钥，那些没有暴露过公钥的钱包地址也是安全的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果有好的比特币使用习惯，一个钱包地址只使用一次，那么同理，新地址的公钥也是不被人知晓的，新地址中的比特币是安全的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果用户重复使用一个钱包地址，那么该地址对应的公钥就处于暴露状态；如果量子计算破解了椭圆曲线算法，那么该地址中的比特币就面临被窃取的危险。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;据统计截止到当前，&lt;strong&gt;有将近 500 万个比特币是存放于公钥暴露的地址中的&lt;/strong&gt;，此外还有将近 177 万个比特币使用的是 P2PK 地址，这是最早期的比特币账户格式，公钥是公开的，其中就包括被认为是中本聪的账户。&lt;strong&gt;如果这些比特币不更换地址，它们是在量子计算攻击范围内的&lt;/strong&gt;。（数据来源：安比实验室）&lt;/p&gt;

&lt;p&gt;除了钱包地址，在比特币系统中还有一个重要的地方使用到了 SHA-256，那就是挖矿。挖矿就是暴力破解哈希函数的过程，通过调整输入值「撞」出落在目标区间的输出值。&lt;/p&gt;

&lt;p&gt;如前文所述，从理论上讲，&lt;strong&gt;量子计算机芯片在暴力搜索时是可以「碾压」经典计算机芯片的&lt;/strong&gt;，但我们同样需要考虑到它的技术发展水平和芯片制作工艺。此外，芯片本就是随着技术的发展不断升级的，&lt;strong&gt;量子计算对挖矿的影响更多的是芯片升级的经济问题，而不是安全问题&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;量子计算下的安全-格密码&#34;&gt;量子计算下的安全：格密码&lt;/h2&gt;

&lt;p&gt;在量子计算发展的同时，量子安全密码学也在飞速发展，这其中最具代表性的是「&lt;strong&gt;格密码&lt;/strong&gt;」，它是基于格的密码体制（ &lt;em&gt;lattice-based cryptography&lt;/em&gt; ）。&lt;/p&gt;

&lt;p&gt;「格」是一个系数为整数的向量空间，可以把它理解成一个高维度空间，它有两个基本的「格困难问题」，一是&lt;strong&gt;最短向量问题&lt;/strong&gt;，一是&lt;strong&gt;最近向量问题&lt;/strong&gt;，求解这类问题需要指数时间的复杂度，那么如果因子为多项式，这类问题就不存在多项式时间算法，对于量子计算也是一种计算上的不可能性。&lt;/p&gt;

&lt;p&gt;这听起来有些抽象，也许可以这么去理解：用笔在一张 A4 纸上画出很多黑色的点，然后换支笔在纸上画下一个红色的点，我们需要做的是找到距离红点最近的黑点，这很容易；现在从 A4 纸这个二维空间到一个三维空间，想象一下空间里漂浮着很多黑色的点，这时放一个红色的点进去，同样是去找距离红点最近的黑点，这并不算很难，但&lt;strong&gt;相对于二维空间，其困难度已经不在一个级别了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;现在，我们把三维空间变成一个三百维的空间，给定一个红点去找距离它最近的黑点，这个黑点一定存在，但想想看，找出它是不是几乎不可能？这就是&lt;strong&gt;格困难问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;格空间与椭圆曲线是相似的&lt;/strong&gt;。在椭圆曲线上，可以有数学公式（ &lt;em&gt;椭圆曲线算法&lt;/em&gt; ）把公钥和私钥放在一个等式的两头，在格空间里，也有数学公式（ &lt;em&gt;比如LLL算法&lt;/em&gt; ）可以把类似黑点和红点的东西放在一个等式的两头，那么我们就可以利用这类公式来生成公钥和私钥。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在椭圆曲线算法中，因为「离散对数困难问题」，传统计算机无法通过公钥计算出私钥；在格密码的算法中，因为「格困难问题」，量子计算机也无法通过公钥算出私钥。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;格密码发展很快，基于格我们不仅有抗量子计算的公钥和私钥，还有抗量子计算的对应于经典密码概念的一系列密码学算法或协议，它们可以被用于数字签名、密钥交换、零知识证明等等应用领域。&lt;/p&gt;

&lt;p&gt;「宇宙相信加密。加密容易，解密难。」在可以预见的未来，依然如此。所以，不用担心，对于比特币是这样，对于区块链也是。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;[1] Arute, Frank, Kunal Arya, Ryan Babbush,Dave Bacon, Joseph C. Bardin, Rami Barends, Rupak Biswas et al. &amp;ldquo;Quantumsupremacy using a programmable superconducting processor.&amp;rdquo; Nature 574,no. 7779 (2019): 505-510.&lt;/p&gt;

&lt;p&gt;[2] Andreas M. Antonopoulos答疑量子计算问题：
www.youtube.com/watch?v=eo7mwcsUbdo；www.youtube.com/watch?v=wlzJyp3Qm7s&lt;/p&gt;

&lt;p&gt;[3] Gentry, Craig. &amp;ldquo;Fully homomorphic encryption using ideallattices.&amp;rdquo; In Stoc, vol. 9, no. 2009, pp. 169-178. 2009.&lt;/p&gt;

&lt;p&gt;[4] Aggarwal,Divesh, Gavin K. Brennen, Troy Lee, Miklos Santha, and Marco Tomamichel.&amp;ldquo;Quantum attacks on Bitcoin, and how to protect against them.&amp;rdquo; arXivpreprint arXiv:1710.10377 (2017).&lt;/p&gt;

&lt;p&gt;[5]Stewart, I., D. Ilie, Alexei Zamyatin, Sam Werner, M. F. Torshizi, and WilliamJ. Knottenbelt. &amp;ldquo;Committing to quantum resistance: a slow defence forBitcoin against a fast quantum computing attack.&amp;rdquo; Royal Society openscience 5, no. 6 (2018): 180410.&lt;/p&gt;

&lt;p&gt;[6] Regev,Oded. &amp;ldquo;Lattice-based cryptography.&amp;rdquo; In Annual International CryptologyConference, pp. 131-141. Springer, Berlin, Heidelberg, 2006.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>读心术：从零知识证明中提取「知识」</title>
      <link>https://sec-bit.github.io/blog/2019/08/28/extractor-and-proof-of-knowledge/</link>
      <pubDate>Wed, 28 Aug 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/08/28/extractor-and-proof-of-knowledge/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;探索零知识证明系列（三）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;导言：有些理论非常有趣，零知识证明便是其中之一，摸索了许久，想写点什么，与大家一起讨论。本文是『探索零知识证明』系列的第三篇。全文约 8,000 字，少量数学公式。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/1/zkp-back.md&#34;&gt;（一）初始「零知识」与「证明」&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/2/zkp-simu.md&#34;&gt;（二）理解「模拟」&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;And what, Socrates, is the food of the soul? Surely, I said, knowledge is the food of the soul.  苏格拉底，什么是灵魂的食物？我说过，当然是知识。
—— 柏拉图&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;零知识-vs-可靠性&#34;&gt;「零知识」vs. 「可靠性」&lt;/h2&gt;

&lt;p&gt;我们在许多介绍零知识证明的文章中都能看到这样三个性质：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Completeness —— 完备性&lt;/li&gt;
&lt;li&gt;Soundness —— 可靠性&lt;/li&gt;
&lt;li&gt;Zero-Knowledge —— 零知识&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是少有文章深入解释这个特性背后的深意和洞见。&lt;/p&gt;

&lt;p&gt;在『&lt;a href=&#34;https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/2/zkp-simu.md&#34;&gt;系列（二）理解「模拟」&lt;/a&gt;』一文中，我们介绍了「模拟器」这个概念。许多介绍文章也避而不谈「模拟」，但「模拟」可以说是安全协议中核心的核心，因为它是定义「安全性」的重要武器。&lt;/p&gt;

&lt;p&gt;通常，我们定义安全会采用这样一种方式，首先列出一些安全事件，然后说明：如果一个系统安全，那么列出来的安全事件都不会发生。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rather than giving a list of the events that are &lt;em&gt;not allowed&lt;/em&gt; to occur, it (the definition of zero-knowledge proof) gives a maximalist &lt;em&gt;simulation&lt;/em&gt; condition.&lt;/p&gt;

&lt;p&gt;— Boaz Barak&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;借用密码学家 Boaz Barak 的话，翻译一下，「零知识证明」并不是通过给出一个&lt;strong&gt;不允许发生的事件列表&lt;/strong&gt;来定义，而是直接给出了一个最极致的「模拟条件」。&lt;/p&gt;

&lt;p&gt;所谓「模拟条件」是指，通过「模拟」方法来实现一个「理想世界」，使之与「现实世界」不可区分；而由于在理想世界中不存在知识，所以可以推导出结论：现实世界满足「零知识」。&lt;/p&gt;

&lt;p&gt;我们继续分析下一个交互系统（安全协议）的三个性质：「完备性」、「可靠性」与「零知识」。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;可靠性（Soundness）：Alice 在没有知识的情况下不能通过 Bob 的验证。&lt;/p&gt;

&lt;p&gt;完备性（Completeness）：Alice 在有知识的情况下可以通过 Bob 的验证。&lt;/p&gt;

&lt;p&gt;零知识（Zero-knowledge）：Alice 在交互的过程中不会泄露关于知识的任何信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以看出来「可靠性」和「完备性」有一种「对称性」。可靠性保证了恶意的 Alice 一定失败，而完备性保证了诚实的 Alice 一定成功。&lt;/p&gt;

&lt;p&gt;「完备性」比较容易证明，只要 Alice 诚实，Bob 也诚实，那么皆大欢喜。这好比，写好一段代码，喂了一个测试用例，跑完通过收工。&lt;/p&gt;

&lt;p&gt;我们来想想「可靠性」应该如何定义？这个可靠性的逆否命题是：（在现实世界中）如果 Alice 能通过 Bob 的验证，那么 Alice 一定有知识。或者说：Alice 知道那……个「秘密」！&lt;/p&gt;

&lt;p&gt;下面的问题是如何证明 Alice 知道一个「秘密」？&lt;/p&gt;

&lt;p&gt;这好像也很难，对不对？假如我们需要证明一台机器知道一个「秘密」，最简单的办法就是我们在机器的硬盘里，或者内存中找到这个「秘密」，但是这样暴露了秘密。如果这台机器是黑盒子呢？或者是 Alice 呢？我们没有读心术，猜不到她心里的那个秘密。&lt;/p&gt;

&lt;p&gt;如何定义「To Know」？&lt;/p&gt;

&lt;p&gt;「零知识」保证了 验证者 Bob 没有（计算）能力来把和「知识」有关的信息「抽取」出来。不能抽取的「知识」不代表不存在。「可靠性」保证了知识的「存在性」。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;只有「知识」在存在的前提下，保证「零知识」才有意义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文将探讨「可靠性」和「To Know」。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;为了进一步分析「知识」，接下来首先介绍一个非常简洁，用途广泛的零知识证明系统 —— Schnorr 协议。这个协议代表了一大类的安全协议，所谓的 Σ-协议，而且 Schnorr 协议扩展也是 &lt;a href=&#34;https://github.com/sec-bit/zkPoD-node&#34;&gt;零知识数据交换协议 zkPoD&lt;/a&gt; [1] 的核心技术之一。&lt;/p&gt;

&lt;h1 id=&#34;简洁的-schnorr-协议&#34;&gt;简洁的 Schnorr 协议&lt;/h1&gt;

&lt;p&gt;Alice 拥有一个秘密数字，&lt;code&gt;a&lt;/code&gt;，我们可以把这个数字想象成「私钥」，然后把它「映射」到椭圆曲线群上的一个点 &lt;code&gt;a*G&lt;/code&gt;，简写为 &lt;code&gt;aG&lt;/code&gt;。这个点我们把它当做「公钥」。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sk = a&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;PK = aG&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请注意「映射」这个词，我们这里先简要介绍「同态」这个概念。椭圆曲线群有限域之间存在着一种同态映射关系。有限域，我们用 &lt;code&gt;Zq&lt;/code&gt;这个符号表示，其中素数 &lt;code&gt;q&lt;/code&gt;是指有限域的大小，它是指从 &lt;code&gt;0, 1, 2, …, q-1&lt;/code&gt; 这样一个整数集合。而在一条椭圆曲线上，我们通过一个基点，&lt;code&gt;G&lt;/code&gt;，可以产生一个「循环群」，标记为 &lt;code&gt;0G, G, 2G, …, (q-1)G&lt;/code&gt;，正好是数量为 &lt;code&gt;q&lt;/code&gt;个 曲线点的集合。任意两个曲线点正好可以进行一种「特殊的二元运算」，&lt;code&gt;G + G = 2G&lt;/code&gt;，&lt;code&gt;2G + 3G = 5G&lt;/code&gt;，看起来这个二元运算好像和「加法」类似，满足交换律和结合律。于是我们就用 &lt;code&gt;+&lt;/code&gt;这个符号来表示。之所以把这个群称为循环群，因为把群的最后一个元素 &lt;code&gt;(q-1)G&lt;/code&gt;，再加上一个 &lt;code&gt;G&lt;/code&gt;就回卷到群的第一个元素 &lt;code&gt;0G&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;给任意一个有限域上的整数 &lt;code&gt;r&lt;/code&gt;，我们就可以在循环群中找到一个对应的点 &lt;code&gt;rG&lt;/code&gt;，或者用一个标量乘法来表示 &lt;code&gt;r*G&lt;/code&gt;。但是反过来计算是很「困难」的，这是一个「密码学难题」—— 被称为离散对数难题[2]。&lt;/p&gt;

&lt;p&gt;也就是说，如果任意给一个椭圆曲线循环群上的点 &lt;code&gt;R&lt;/code&gt;，那么到底是有限域中的哪一个整数对应 &lt;code&gt;R&lt;/code&gt;，这个计算是很难的，如果有限域足够大，比如说 256bit 这么大，我们姑且可以认为这个反向计算是不可能做到的。&lt;/p&gt;

&lt;p&gt;Schnorr 协议充分利用了有限域和循环群之间单向映射，实现了最简单的零知识证明安全协议：Alice 向 Bob 证明她拥有 &lt;code&gt;PK&lt;/code&gt; 对应的私钥 &lt;code&gt;sk&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一步：为了保证零知识，Alice 需要先产生一个随机数，&lt;code&gt;r&lt;/code&gt;，这个随机数的用途是用来保护私钥无法被 Bob 抽取出来。这个随机数也需要映射到椭圆曲线群上，&lt;code&gt;rG&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第二步：Bob 要提供一个随机数进行挑战，我们把它称为 &lt;code&gt;c&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第三步：Alice 根据挑战数计算 &lt;code&gt;z = r + a * c&lt;/code&gt;，同时把 &lt;code&gt;z&lt;/code&gt;发给 Bob，Bob通过下面的式子进行检验：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;z*G ?= R + c*PK = rG + c*(aG)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;大家可以看到 Bob  在第三步「同态地」检验 &lt;code&gt;z&lt;/code&gt; 的计算过程。如果这个式子成立，那么就能证明 Alice 确实有私钥 &lt;code&gt;a&lt;/code&gt;。可是，这是为什么呢？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;z&lt;/code&gt; 的计算和验证过程很有趣，有几个关键技巧：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先 Bob 必须给出一个「随机」挑战数，然后 Bob 在椭圆曲线上同态地检查 &lt;code&gt;z&lt;/code&gt; 。如果我们把挑战数 &lt;code&gt;c&lt;/code&gt; 看成是一个未知数，那么 &lt;code&gt;r+a*c=z&lt;/code&gt; 可以看成是一个一元一次方程，其中 &lt;code&gt;r&lt;/code&gt; 与 &lt;code&gt;a&lt;/code&gt; 是方程系数。请注意在 &lt;code&gt;c&lt;/code&gt; 未知的前提下，如果 &lt;code&gt;r + a*x = r&#39; + a&#39;*x&lt;/code&gt; 要成立，那么根据 Schwatz-Zippel 定理[3]，极大概率上 &lt;code&gt;r=r&#39;&lt;/code&gt;，&lt;code&gt;a=a&#39;&lt;/code&gt; 都成立。也就是说， Alice 在 &lt;code&gt;c&lt;/code&gt; 未知的前提下，想找到另一对不同的 &lt;code&gt;r&#39;&lt;/code&gt;,&lt;code&gt;a&#39;&lt;/code&gt; 来计算 &lt;code&gt;z&lt;/code&gt; 骗过 Bob 是几乎不可能的。这个随机挑战数 &lt;code&gt;c&lt;/code&gt; 实现了&lt;code&gt;r&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 的限制。虽然 Bob 随机选了一个数，但是由于 Alice 事先不知道，所以 Alice 不得不使用私钥 &lt;code&gt;a&lt;/code&gt; 来计算 &lt;code&gt;z&lt;/code&gt;。这里的关键： &lt;code&gt;c&lt;/code&gt; 必须是个随机数。&lt;/li&gt;
&lt;li&gt;Bob 验证是在椭圆曲线群上完成。Bob 不知道&lt;code&gt;r&lt;/code&gt;，但是他知道 &lt;code&gt;r&lt;/code&gt; 映射到曲线上的点&lt;code&gt;R&lt;/code&gt;；Bob 也不知道 &lt;code&gt;a&lt;/code&gt;，但是他知道 &lt;code&gt;a&lt;/code&gt; 映射到曲线群上的点 &lt;code&gt;PK&lt;/code&gt;，即 &lt;code&gt;a*G&lt;/code&gt;。通过同态映射与Schwatz-Zippel 定理，Bob 可以校验 &lt;code&gt;z&lt;/code&gt; 的计算过程是否正确，从而知道 Alice 确实是通过 &lt;code&gt;r&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 计算得出的 &lt;code&gt;z&lt;/code&gt;，但是又不暴露 &lt;code&gt;r&lt;/code&gt; 与 &lt;code&gt;a&lt;/code&gt; 的值。&lt;/li&gt;
&lt;li&gt;还有，在协议第一步中产生的随机数 &lt;code&gt;r&lt;/code&gt; 保证了 &lt;code&gt;a&lt;/code&gt; 的保密性。因为任何一个秘密当和一个符合「一致性分布」的随机数相加之后的和仍然符合「一致性分布」。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;证明零知识&#34;&gt;证明零知识&lt;/h2&gt;

&lt;p&gt;我们这里看一下 Schnorr 协议如何证明一个弱一些的「零知识」性质——「SHVZK」：&lt;/p&gt;

&lt;p&gt;注：这里我们证明的仅仅是 Special Honest Verifier Zero-Knowledge（SHVZK）。SHVZK 要求协议中的 Bob 的行为不能不按常理出牌，比如他必须按协议约定，在第二步时，去传送带上取一个新鲜的随机数，并且立即使用。而通常意义上的「零知识」是不会对 Bob 做任何要求，所以我们说这里是一个弱一些的性质。虽然目前 Schnorr 协议不能证明完全的「零知识」，但经过添加一些协议步骤，就可以达到完全零知识的目的，细节这里不展开，有兴趣的读者请参考文献[4]。以后我们在讨论 Fiat-Shamir 变换时，还会再次讨论这个问题。&lt;/p&gt;

&lt;p&gt;首先「模拟器」模拟一个「理想世界」，在理想世界中模拟出一个 Zlice 和 Bob 对话，Zlice 没有 Schnorr 协议中的知识，&lt;code&gt;sk&lt;/code&gt;，而 Bob 是有公钥 &lt;code&gt;PK&lt;/code&gt;的。请大家看下图，Bob 需要在 Schnorr 协议中的第二步出示一个随机数 &lt;code&gt;c&lt;/code&gt;，这里有个额外的要求， 就是 Bob 只能「诚实地」从一个外部「随机数传送带」上拿一个随机数，每一个随机数都必须是事先抛k次「硬币」产生的一个 &lt;code&gt;2^k&lt;/code&gt; 范围内的一次性分布随机数。Bob 不能采用任何别的方式产生随机数，这就是为何我们要求 Bob 是诚实的。&lt;/p&gt;

&lt;p&gt;下面演示 Zlice 如何骗过 Bob：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-sim-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;序幕：请注意 Zlice 没有关于&lt;code&gt;sk&lt;/code&gt;的知识，这时 Bob 的随机数传送带上已经预先放置了一些随机数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-sim-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一步：Zlice 产生一个一致性分布的随机数&lt;code&gt;c&lt;/code&gt;，并且利用一个新的「超能力」，将刚刚产生的随机数 &lt;code&gt;c&lt;/code&gt; 替换掉 Bob 的随机数传送带上第一个随机数。这时候，Bob 无法察觉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-sim-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二步：Zlice 再次产生一个随机数 &lt;code&gt;z&lt;/code&gt;，然后计算 &lt;code&gt;R&#39;=z*G - c*PK&lt;/code&gt;，并将 &lt;code&gt;R&#39;&lt;/code&gt;发送给 Bob。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-sim-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第三步：这时候Bob 会从随机数传送带上取得 &lt;code&gt;c&lt;/code&gt;，并且将 &lt;code&gt;c&lt;/code&gt; 发送给 Zlice。请注意这个&lt;code&gt;c&lt;/code&gt; 正好就是第一步中 Zlice 产生的 &lt;code&gt;c&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-sim-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第四步：Zlice 将第三步产生的随机数 &lt;code&gt;z&lt;/code&gt; 发送给 Bob，Bob 按照 Schnorr 协议的验证公式进行验证，大家可以检查下，这个公式完美成立。&lt;/p&gt;

&lt;p&gt;大家可以再对比下「现实世界」的 Schnorr 协议，在两个世界中，Bob 都能通过验证。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但区别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在「理想世界中」，Zlice 没有 &lt;code&gt;sk&lt;/code&gt;；而在「现实世界中」，Alice 有 &lt;code&gt;sk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在「理想世界中」，&lt;code&gt;z&lt;/code&gt; 是一个随机数，没有涉及 &lt;code&gt;sk&lt;/code&gt;；而在「现实世界中」，&lt;code&gt;z&lt;/code&gt; 的计算过程里面包含 &lt;code&gt;sk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在「理想世界中」，Zlice 使用了超能力，替换了 Bob 的随机数；而在「现实世界中」，Alice 看不到 Bob 的随机数传送带，也无法更改传送带上的数字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里请大家思考下：Schnorr 协议中，Bob 在第二步发挑战数能不能和第一步对调顺序？也就是说 Bob 能不能先发挑战数，然后 Alice 再发送 &lt;code&gt;R = r*G&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;（两分钟后……）&lt;/p&gt;

&lt;p&gt;答案是不能。&lt;/p&gt;

&lt;p&gt;如果 Alice 能提前知道随机数，那么 （现实世界中的）Alice 就可以按照模拟器 Zlice 做法来欺骗 Bob。&lt;/p&gt;

&lt;h2 id=&#34;再遇模拟器&#34;&gt;再遇模拟器&lt;/h2&gt;

&lt;p&gt;其实，「可靠性」和「零知识」这两个性质在另一个维度上也是存在着一种对称性。可靠性保证了恶意的 Alice 一定失败，零知识保证了恶意的 Bob 一定不会成功。有趣地是，这种对称性将体现在模拟出来的「理想世界」中。&lt;/p&gt;

&lt;p&gt;我们分析下可靠性这个定义：Alice 没有知识 &lt;strong&gt;导致&lt;/strong&gt; Bob 验证失败。它的逆否命题为：Bob 验证成功 &lt;strong&gt;导致&lt;/strong&gt; Alice 一定有知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们再次求助模拟器&lt;/strong&gt;，让他在可以发挥超能力的「理想世界」中，去检验 Alice 的知识。&lt;/p&gt;

&lt;p&gt;再次，请大家设想在平行宇宙中，有两个世界，一个是叫做「理想世界」，另一个叫做「现实世界」。理想世界有趣的地方在于它是被「模拟器」模拟出来的，同时模拟器可以在理想世界中放入带有超能力的 NPC。这次把 Alice 的两个分身同时放入「理想世界」与「现实世界」。&lt;/p&gt;

&lt;p&gt;假设「你」扮演 Bob 的角色，你想知道和你对话的 Alice 是否真的是「可靠的」。 于是把你放入「理想世界」，借助一个具有超能力的 NPC，你可以把对面的 Alice 的知识「抽取」出来。&lt;/p&gt;

&lt;p&gt;W&amp;hellip;hat？我们不是刚刚证明过：协议是零知识的吗？零知识就意味着 Bob 抽取不出任何的「知识」碎片。这里敲黑板，「零知识」是对于「现实世界」而言的。我们现在正在讨论的是神奇的「理想世界」。&lt;/p&gt;

&lt;p&gt;重复一遍，在「理想世界」中，你可以借助一个有超能力的 NPC 来抽取 Alice 的知识，从而可以保证「现实世界」中的 Alice 无法作弊。可以想象一下，一个作弊的 Alice，她肯定没有知识，没有知识也就不可能在「理想世界」中让 NPC 抽取到任何东西。&lt;/p&gt;

&lt;p&gt;然而在「现实世界」中，你无法借助 NPC，当然也就看不到 Alice 的知识，也就不会和「零知识」性质冲突。因为两个世界发生的事件是「不可区分」的，我们可以得到这样的结论：在「现实世界」中，Alice 一定是存在知识的。&lt;/p&gt;

&lt;p&gt;整理一下思路：如何证明在一个交互会话中 Alice 不能作弊呢？我们需要为这个交互会话定义一个「模拟算法」，该算法可以模拟出一个「理想世界」，其中有一个特殊的角色叫做「抽取器」(Extractor)，也就是我们前面说的 NPC，它能够通过「超能力」来「抽取」Alice 的知识，但是让对方「无所察觉」。&lt;/p&gt;

&lt;p&gt;注意，超能力是必不可少的！这一点在『&lt;a href=&#34;https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/2/zkp-simu.md&#34;&gt;系列（二）理解「模拟」&lt;/a&gt;』有解释，如果模拟器在没有超能力的情况下具备作弊能力，那相当于证明了协议「不可靠」（Unsoudness）。同样地，如果「抽取器」在没有超能力的情况下具备抽取信息能力，那相当于证明了协议不零知（Not-zero-knowledge）。&lt;/p&gt;

&lt;p&gt;最后一点，超能力是什么？这个要取决于具体的交互系统的证明，我们接下来就先拿我们刚刚讲过的Schnorr 协议切入。&lt;/p&gt;

&lt;h2 id=&#34;proof-of-knowledge-知识证明&#34;&gt;Proof of Knowledge ：「知识证明」&lt;/h2&gt;

&lt;p&gt;我们来证明一下 Schnorr 协议的「可靠性」，看看这个超能力 NPC 如何在「理想世界」中把 Alice 私钥抽取出来。而这个「超能力」，仍然是「时间倒流」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-extractor-1.png&#34; alt=&#34;schnorr-extractor-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一步：Alice 选择一个随机数 &lt;code&gt;r&lt;/code&gt;，并且计算 &lt;code&gt;R=r*G&lt;/code&gt;，并将 &lt;code&gt;R&lt;/code&gt; 发给「抽取器」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-extractor-2.png&#34; alt=&#34;schnorr-extractor-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二步：抽取器也选择一个随机的挑战数&lt;code&gt;c&lt;/code&gt;，并且发给 Alice&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-extractor-3.png&#34; alt=&#34;schnorr-extractor-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第三步：Alice 计算并且回应 &lt;code&gt;z&lt;/code&gt;，然后抽取器检查 &lt;code&gt;z&lt;/code&gt;是否正确&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-extractor-4.png&#34; alt=&#34;schnorr-extractor-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第四步：抽取器发现  &lt;code&gt;z&lt;/code&gt; 没有问题之后，发动超能力，将时间倒回第二步之前&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-extractor-5.png&#34; alt=&#34;schnorr-extractor-5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第五步：抽取器再次发送一个不同的随机挑战数 &lt;code&gt;c&#39;&lt;/code&gt;给 Alice，这时候 Alice 回到第二步，会有一种似曾相识的感觉，但是无法感知到时间倒回这个事实&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-extractor-6.png&#34; alt=&#34;schnorr-extractor-6&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第六步：Alice 再次计算了 &lt;code&gt;z&#39;&lt;/code&gt;，然后发给抽取器检查&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/schnorr-extractor-7.png&#34; alt=&#34;schnorr-extractor-7&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第七步：这时候抽取器有了&lt;code&gt;z&lt;/code&gt;和&lt;code&gt;z&#39;&lt;/code&gt;，就可以直接推算出 Alice 所拥有的私钥 &lt;code&gt;a&lt;/code&gt;，达成「知识抽取」&lt;/p&gt;

&lt;p&gt;到这里，「可靠性」就基本证明完了。大家是不是对可靠性和零知性的「对称性」有点感觉了？&lt;/p&gt;

&lt;p&gt;总结一下：「抽取器」在「理想世界」中，通过时间倒流的超能力，把 Alice 的「知识」完整地「抽取」出来，这就保证了一个没有知识的 Alice 是无法让抽取器达成目标，从而证明了「可靠性」。&lt;/p&gt;

&lt;p&gt;注：并不是所有的可靠性都必须要求存在抽取器算法。采用抽取器来证明可靠性的证明系统被称为「Proof of Knowledge」。&lt;/p&gt;

&lt;h2 id=&#34;解读-ecdsa-签名攻击&#34;&gt;解读 ECDSA 签名攻击&lt;/h2&gt;

&lt;p&gt;在区块链系统中到处可见的ECDSA 签名方案&lt;strong&gt;也是&lt;/strong&gt;一个朴素的零知识证明系统。椭圆曲线数字签名方案 ECDSA 与 Schnorr 协议非常接近，基于 Schnorr 协议的签名方案发表在 1991年的『密码学杂志』[5]上。1991年，正值美国国家标准局（NIST）选择数字签名算法，优雅的 Schnorr 签名方案居然被申请了专利，因此 NIST 提出了另一套签名方案 DSA（Digital Signature Algorithm），随后这个方案支持了椭圆曲线，于是被称为 ECDSA。中本聪在构思比特币时，选择了 ECDSA 作为签名算法，但是曲线并没有选择 NIST 标准推荐的椭圆曲线 —— secp256-r1，而是 secp256-k1。因为江湖传言，NIST 可能在椭圆曲线参数选择上做了手脚，导致某些机构可以用不为人知的办法求解离散对数难题，从而有能力在「现实世界」中具备超能力。有不少人在怀疑，也许当年中本聪在设计比特币时，也有这种考虑，故意选择了 secp256-k1 这样一条貌似安全性稍弱的曲线。&lt;/p&gt;

&lt;p&gt;我们拆解下 ECDSA 签名，用交互的方式定义一个类似 ECDSA 的认证方案，交互见下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/ecdsa.png&#34; alt=&#34;ecdsa-sig&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一步：Alice 仍然是选择一个随机数 &lt;code&gt;k&lt;/code&gt;，并将 &lt;code&gt;k&lt;/code&gt; 映射到椭圆曲线上，得到点 &lt;code&gt;K&lt;/code&gt; ，然后发送给 Bob&lt;/p&gt;

&lt;p&gt;第二步：Bob 需要产生两个随机数，&lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt;，然后交给 Alice&lt;/p&gt;

&lt;p&gt;第三步：Alice 计算 &lt;code&gt;s&lt;/code&gt;，并且发送给 Bob，他来验证 &lt;code&gt;s&lt;/code&gt; 的计算过程是否正确&lt;/p&gt;

&lt;p&gt;注：对熟悉 ECDSA 签名方案的读者，这里略作解释，Bob 产生的 &lt;code&gt;c&lt;/code&gt; 对应被签消息的 Hash 值 &lt;code&gt;Hash(m)&lt;/code&gt;，而 &lt;code&gt;e&lt;/code&gt; 则是由一个转换函数 &lt;code&gt;F(K)&lt;/code&gt;来产生。其中 &lt;code&gt;F(.)&lt;/code&gt; 是取椭圆曲线上的点的 x 坐标经过 &lt;code&gt;(mod q)&lt;/code&gt; 得到[6]。&lt;/p&gt;

&lt;p&gt;江湖上流传着一个说法：ECDSA 签名方案有个严重的安全隐患，如果在两次签名中使用了同一个随机数，那么签名者的私钥将会暴露出来。其实 Schnorr 签名方案也有同样的问题。&lt;/p&gt;

&lt;p&gt;当年 Sony  PlayStation 3 的工程师在调用 ECDSA 库函数时，本来应该输入随机数的参数位置上，却传入了一个常数。熟悉密码学的黑客们发现了这个严重的后门。2011年1月，神奇小子 Geohot 公开发布了 Sony PS3 的主私钥，这意味着任何用户都可以轻松拿到游戏机的 root 权限。Sony 随后大为光火…… （后续故事大家可以上网搜）&lt;/p&gt;

&lt;p&gt;如果 Alice 在两次交互过程中使用了同一个 &lt;code&gt;K&lt;/code&gt;，那么 Bob 可以通过发送两个不同的 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;c&#39;&lt;/code&gt; 来得到 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;s&#39;&lt;/code&gt;，然后通过下面的公式算出私钥 &lt;code&gt;a&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;k = (c - c&amp;#39;)/(s - s&amp;#39;)
a = (k * s - c)/e&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;那么我们应该怎么来看这个「安全后门」呢？大家想想看，这个安全后门和我们前面证明过的 Schnorr 协议的可靠性证明几乎一模一样！这个算法正是 ECDSA 认证协议的「可靠性」证明中的「抽取器」算法。只不过在可靠性证明中，为了让 Alice 使用同一个随机数 &lt;code&gt;k&lt;/code&gt; 来认证两次，「抽取器」需要利用「时间倒流」的超能力。&lt;/p&gt;

&lt;p&gt;但是在 Sony PS3 系统中，随机数被不明所以的工程师写成了一个固定不变的值，这样相当于直接赋予了黑客「超能力」，而这是在「现实世界」中。或者说，黑客在不需要「时间倒流」的情况下就能实现「抽取器」。&lt;/p&gt;

&lt;p&gt;提醒下，不仅仅是随机数不能重复的问题。而是随机数必须是具有密码学安全强度的随机数。&lt;/p&gt;

&lt;p&gt;设想下，如果随机数 &lt;code&gt;r&lt;/code&gt; 是通过一个利用「线性同余」原理的伪随机数生成器产生，虽然 &lt;code&gt;r&lt;/code&gt;的值一直在变化，但是仍然不能阻止「知识抽取」。假设线性同余算法为 &lt;code&gt;r2= d*r1 + e (mod m)&lt;/code&gt;，还回到 Schnorr 协议的第三步：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;1: z1 = r1 + c1*a
2: z2 = r2 + c2*a&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果攻击者让 Alice 连续做两次签名，那么将 &lt;code&gt;r2&lt;/code&gt; 代入  &lt;code&gt;r1&lt;/code&gt; 之后，就出现了两个线性方程求解两个未知数 &lt;code&gt;(r1, a)&lt;/code&gt; 的情况，&lt;code&gt;z1, z2, c1, c2, d, e&lt;/code&gt; 对于 攻击者是已知的，这个方程组只用初中数学知识就可以求解。&lt;/p&gt;

&lt;p&gt;请注意，这并不是 Schnorr 协议（或 ECDSA 协议）的「设计缺陷」，恰恰相反，这是 Schnorr 协议设计比较精巧的地方，它&lt;strong&gt;从原理上保证了协议的可靠性&lt;/strong&gt;。类似技巧在密码学协议中频繁出现，达到一目了然的「简洁」。但是也不得不说，如果不清楚协议的内在机制，尤其是区分不清楚「理想世界」与「现实世界」，使用者很容易引入各种花式的「安全漏洞」。&lt;/p&gt;

&lt;p&gt;作为一个能写出可靠软件的靠谱码农，我们需要了解哪些？彻底理解安全协议的设计机制当然是最好的，但是绝大多数情况下是非常耗费精力的。一般来说，我们把各种密码学工具当做「黑盒」来用，可能是不够的，我们最好还能了解下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;「安全定义」是什么？&lt;/li&gt;
&lt;li&gt;「安全假设」到底是什么？&lt;/li&gt;
&lt;li&gt;「理想世界」中的「超能力」到底是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;脑洞-我们生活在模拟世界中吗&#34;&gt;脑洞：我们生活在模拟世界中吗&lt;/h2&gt;

&lt;p&gt;第一次读懂「模拟器」时，我第一时间想到的是电影『黑客帝国』。我们生活所在「现实世界」也许是某一个模拟器模拟出来的「理想世界」，我们所看到、听到的以及感知到的一切都是被「模拟」出来的。在「现实世界」里，我们活在一个母体中。然而我们并不能意识到这一点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/matrix.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;早在春秋战国时期，庄子也在思考类似的问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;昔者庄周梦为胡蝶，栩栩然胡蝶也，自喻适志与，不知周也。俄然觉，则蘧蘧然周也。不知周之梦为胡蝶与，胡蝶之梦为周与？周与胡蝶，则必有分矣。此之谓物化。——《庄子·齐物论》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通俗地解释下：庄子有一天睡着了，梦见自己变成了一只蝴蝶，翩翩起舞，醒来之后发现自己还是庄子，在梦中，蝴蝶并不知道自己是庄子。于是庄子沉思到底是他梦中变成了蝴蝶，还是蝴蝶梦中变成了庄子呢？如果梦境足够真实，……&lt;/p&gt;

&lt;p&gt;「缸中之脑」是美国哲学家 Gilbert Harman 提出的这样一个想法：一个人的大脑可以被放入一个容器里面，然后插上电线，通过模拟各种电信号输入，使得大脑以为自己活在真实世界中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/brain-in-a-vat.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个想法源自哲学家笛卡尔的《第一哲学沉思集》[7]，在书中他论证我们应该怀疑一切，需要逐一检验所有人类的知识，数学，几何，以及感知到的世界。然而他发现除了「我思故我在」之外，所有的知识都可能不靠谱，因为我们的大脑很可能被一个具有「超能力」的 Evil Demon 所欺骗。&lt;/p&gt;

&lt;p&gt;2003 年牛津大学的哲学教授 Nick Bostrom 郑重其事地写了一篇论文『我们生活在计算机模拟世界中吗？』[8]。认为以下三个事实中，至少有一个成立：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;人类文明彻底灭绝。&lt;/li&gt;
&lt;li&gt;人类文明已经到达可以完全模拟现实世界的科技水平，但是处于某种原因，没有一个人愿意去创造出一个新的模拟世界，充当上帝的角色。&lt;/li&gt;
&lt;li&gt;我们现在的人类文明就生活在一个模拟世界中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;硅谷企业家 Elon Musk 在一次公开采访中，谈到「我们生活在基础现实世界」的概率只有「十亿分之一」。也就是说，他认为我们生活在一个电脑游戏（模拟世界）中，在模拟世界之外，有一个程序员，他开发并操纵了这个世界，我们每个人都是一个游戏角色（ NPC）。&lt;/p&gt;

&lt;p&gt;在玩腻越狱 iPhone 和自动驾驶之后，神奇小子 Geohot 在今年三月份的「西南偏南」大会上做了一个题为「Jailbreaking the Simulation」的演讲[9]。他认为，我们被生活在一个模拟世界中，所谓的上帝就是外部世界里活蹦乱跳的码农们，他们编程创造了我们的「现实世界」，当然，他们可能启动了不止一个世界副本。然而，他们可能也生活在一个外层「模拟世界」中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/sxsw.jpg&#34; alt=&#34;Jailbreaking the Simulation&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们确实生活在模拟世界中，或许我们可以在地球的某个地方找到一个后门——「Simulation Trapdoor」，从而获得「模拟器」的超能力，抽取出不可思议的「秘密知识」。&lt;/p&gt;

&lt;p&gt;如果我们的世界的确是被程序模拟出来的，这个程序也许会有 Bug，如果有 Bug 存在，说不定我们可以利用这个 Bug 进行越狱，跳出「理想世界」，到达外面一层的世界中，与可爱的码农上帝聊一聊。&lt;/p&gt;

&lt;p&gt;这是在开玩笑吗？下面摘自自知乎的一个段子[10]：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;问题：「如果世界是虚拟的，有哪些实例可以证明？」。&lt;/li&gt;
&lt;li&gt;回答：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;为什么宏观上丰富多彩，但是微观的基本粒子却都是一模一样的？这正和图片富多彩，但是像素是一模一样的一回事&lt;/li&gt;
&lt;li&gt;为什么光速有上限？因为机器的运行速度有限&lt;/li&gt;
&lt;li&gt;为什么会有普朗克常量？因为机器的数据精度有限&lt;/li&gt;
&lt;li&gt;为什么微观粒子都是几率云？这是为了避免系统陷入循环而增加的随机扰动&lt;/li&gt;
&lt;li&gt;为什么有泡利不相容原理？看来系统采用的数据组织是多维数组&lt;/li&gt;
&lt;li&gt;为什么量子计算机运行速度那么快，一瞬间可以尝试所有可能？因为这个本质上是调用了宿主机的接口&lt;/li&gt;
&lt;li&gt;为什么会有量子纠缠？这实际上是引用同一个对象的两个指针&lt;/li&gt;
&lt;li&gt;为什么会有观察者效应？这显然是lazy updating&lt;/li&gt;
&lt;li&gt;为什么时间有开端？系统有启动时间&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;未完待续&#34;&gt;未完待续&lt;/h2&gt;

&lt;p&gt;设计一个密码学协议就好像在走钢丝，如果你想同时做到「零知识」和「可靠性」就意味着既要让协议内容充分随机，又要保证「知识」能够参与协议的交互。如果协议没有正确设计，亦或没有正确工程实现，都将导致系统安全性坍塌。比如可能破坏了零知性，导致「知识」在不经意间泄露；或者也许破坏了可靠性，导致任何人都能伪造证明。而且这种安全性，远比传统的代码底层机制漏洞来得更加严重，并且更难被发现。严格数学论证，这似乎是必不可少的。&lt;/p&gt;

&lt;p&gt;我们的世界真的是某个「三体文明」模拟出来的吗？不能排除这个可能性，或许，我们需要认真地重新审视自己的各种执念。不过那又怎么样呢？至少自己的「思想」是真实的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you would be a real seeker after truth, it is necessary that at least once in your life you doubt, as far as possible, all things.  如果你是一个真正的真理探求者，在你人生中至少要有一次，尽可能地质疑所有的事情。
    —— 笛卡尔&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;致谢：特别感谢 Shengchao Ding, Jie Zhang，Yu Chen 以及安比实验室小伙伴们(p0n1, even, aphasiayc, Vawheter, yghu, mr)的建议和指正。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;参考文献&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[1] zkPoD: 区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易. 安比实验室. 2019.&lt;/li&gt;
&lt;li&gt;[2] Hoffstein, Jeffrey, Jill Pipher, Joseph H. Silverman, and Joseph H. Silverman. An introduction to mathematical cryptography. Vol. 1. New York: springer, 2008.&lt;/li&gt;
&lt;li&gt;[3] Schwartz–Zippel Lemma. Wikipedia.  &lt;a href=&#34;https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma&#34;&gt;https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] Damgård, Ivan. &amp;ldquo;On Σ-protocols.&amp;rdquo; &lt;em&gt;Lecture Notes, University of Aarhus, Department for Computer Science&lt;/em&gt; (2002).&lt;/li&gt;
&lt;li&gt;[5] Schnorr, Claus-Peter. &amp;ldquo;Efficient signature generation by smart cards.&amp;rdquo; &lt;em&gt;Journal of cryptology&lt;/em&gt; 4.3 (1991): 161-174.&lt;/li&gt;
&lt;li&gt;[6] Brown, Daniel RL. &amp;ldquo;Generic groups, collision resistance, and ECDSA.&amp;rdquo; &lt;em&gt;Designs, Codes and Cryptography&lt;/em&gt; 35.1 (2005): 119-152.&lt;/li&gt;
&lt;li&gt;[7] 笛卡儿, 徐陶. 第一哲学沉思集. 九州出版社; 2008.&lt;/li&gt;
&lt;li&gt;[8] Bostrom, Nick. &amp;ldquo;Are we living in a computer simulation?.&amp;rdquo; The Philosophical Quarterly 53.211 (2003): 243-255.&lt;/li&gt;
&lt;li&gt;[9] Nick Statt. &amp;ldquo;Comma.ai founder George Hotz wants to free humanity from the AI simulation&amp;rdquo;. Mar 9, 2019. &lt;a href=&#34;https://www.theverge.com/2019/3/9/18258030/george-hotz-ai-simulation-jailbreaking-reality-sxsw-2019&#34;&gt;https://www.theverge.com/2019/3/9/18258030/george-hotz-ai-simulation-jailbreaking-reality-sxsw-2019&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[10] doing@知乎. &amp;ldquo;如果世界是虚拟的，有哪些实例可以证明？&amp;rdquo;. 2017. &lt;a href=&#34;https://www.zhihu.com/question/34642204/answer/156671701&#34;&gt;https://www.zhihu.com/question/34642204/answer/156671701&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>从「模拟」理解零知识证明：平行宇宙与时光倒流</title>
      <link>https://sec-bit.github.io/blog/2019/08/06/understand-zero-knowledge-proof-by-simulator/</link>
      <pubDate>Tue, 06 Aug 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/08/06/understand-zero-knowledge-proof-by-simulator/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;探索零知识证明系列（二）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I know that I know nothing  —— 苏格拉底&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相信很多人都听说过零知识证明，但是只有极少数人听说过模拟，然而模拟是理解零知识的关键。&lt;/p&gt;

&lt;p&gt;我们在第一篇文章『初识「零知识」与「证明」』（链接）[1]中介绍了一个简单的零知识交互系统：地图三染色问题。那么这个系统真的是零知识的吗？我们为什么要相信这个结论呢？有证明吗？在  Alice 与 Bob 的对话过程中，如果不零知识，Alice就被坑了。交互式系统的设计者「我」需要让 Alice 确信，这个对话确实是零知识的。&lt;/p&gt;

&lt;p&gt;如果从直觉主义角度解释，要证明一个交互系统中存在信息泄露，那么你只需要指证：第几个 bit 导致信息泄露即可；但如果要证明不存在信息泄露，那么你要对着所有信息流中的所有 bit 说，这从1，2，3，4，5，……  编号的 bit 都没泄露任何信息。看官们，这是不是很难？&lt;/p&gt;

&lt;p&gt;本文约八千字，略微烧脑。&lt;/p&gt;

&lt;h2 id=&#34;安全的定义与不可区分性&#34;&gt;安全的定义与不可区分性&lt;/h2&gt;

&lt;p&gt;首先，一个交互式系统，也就是一个对话，它的「零知识」需要证明。毕竟，现代密码学是建立在严格的形式化系统之上。在证明之前，还需要明确「安全假设」到底有哪些。所谓安全假设，比如我们说一个系统的权限隔离做得无比精确，每一个用户只能看到被授权的信息，但是这基于一个安全假设：管理员账号没有被破解。又比如在手机银行软件里，只能通过短信认证码，才能完成转账功能，这也基于一个安全假设：你的手机 SIM 卡没有被克隆。如果我们深入地分析每一个我们感觉安全的系统，都存在大量的似乎不那么稳固的安全假设。比特币私钥安全吗？比特币账户的安全假设也不少：首先你的助记词不能让别人知道，手机钱包里私钥保存加密算法足够强，密钥派生算法正规，你不能忘记助记词，等等等。&lt;/p&gt;

&lt;p&gt;脱离安全假设来谈安全都是在耍流氓。一切安全都有前提的。只有经过数学证明之后，大家才能够确信这个 算法/方案 的安全性基于一些&lt;strong&gt;非常明确&lt;/strong&gt;的「安全假设」。&lt;/p&gt;

&lt;p&gt;在证明之前，还缺少一个东西，那就是「安全定义」。在多数人的认知系统中，安全就是一个框，什么都可以往里装。大家应该好好提醒下自己，当谈论安全二字的时候，有没有想过到底什么是安全？怎么算安全？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「安全」需要有一个数学意义上的严格定义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;伟大的科学家香农（Claude Shannon）从信息论的角度给出了一个非常靠谱的安全性定义[2]：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;完美安全：假设你是一个攻击者，你通过密文获取不到任何有价值的信息，破解的唯一手段就是靠瞎蒙。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大家想一想，这个定义很有趣，通过密文获取不到信息，这就意味着你没有获得任何额外的计算能力，能够帮助让你以更短的时间来计算出明文。&lt;/p&gt;

&lt;p&gt;但是这个定义太完美，以至于使用的加密算法都很难满足这个安全性定义。后来 Goldwasser 与 Micali 等人写了另一篇载入史册的经典『概率加密』[2]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/probenc.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这篇论文中定义了这样一个概念：语义安全。所谓语义安全在完美安全的定义上放松了些要求。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;语义安全：假设你是一个攻击者，你通过密文在多项式时间内计算不出来任何有价值的信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好了，这个看起来靠谱多了。接下来一个问题就是，怎么理解「计算不出来信息」这个概念？这看来要对信息进行度量，信息的定义又是什么呢？&lt;/p&gt;

&lt;p&gt;我们又引入一个概念——「不可区分性」，来重新表述加密算法的安全性：假设你是一个攻击者，而我有一个加密算法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你随机产生两段等长的明文，&lt;code&gt;m1&lt;/code&gt;=「白日依山尽，黄河入海流」，&lt;code&gt;m2&lt;/code&gt;=「烫烫烫烫烫，烫烫烫烫烫」&lt;/li&gt;
&lt;li&gt;你把这两段明文，&lt;code&gt;m1&lt;/code&gt; 与 &lt;code&gt;m2&lt;/code&gt; 交给我&lt;/li&gt;
&lt;li&gt;我随机挑选一个明文，不告诉你是哪一个，然后进行加密，产生一个密文 &lt;code&gt;c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我把密文 &lt;code&gt;c&lt;/code&gt; 出示给你看，让你猜这个&lt;code&gt;c&lt;/code&gt; 究竟是由唐诗加密产生，还是乱码加密产生&lt;/li&gt;
&lt;li&gt;如果你用一台计算机来破解&lt;code&gt;c&lt;/code&gt;，在多项式时间内破解不出来，也就是说你没办法区分&lt;code&gt;c&lt;/code&gt;的来源，那么就说明加密算法是语义安全的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OK，理解完「不可区分性」，我们再回到「零知识」，如何证明一个交互式系统是「零知识」呢？首先我们要定义下零知识这个概念。&lt;/p&gt;

&lt;p&gt;注：不可区分性是概率意义上的不可区分；在学术上，它可以分为「完全不可区分」，「统计不可区分」，还有「计算不可区分」。在本文中，我们暂时不需要理解这些概念的差别。&lt;/p&gt;

&lt;h2 id=&#34;遇见模拟器&#34;&gt;遇见模拟器&lt;/h2&gt;

&lt;p&gt;先开个脑洞，设想在平行宇宙中，有两个平行的世界，一个叫做「理想世界」（Ideal World），另一个叫做「现实世界」（Real World）。我们每一个个体可以在两个平行世界中愉快地玩耍，但是两个世界的普通人无法互相感知，也无法互相沟通。&lt;/p&gt;

&lt;p&gt;假设「你」是一个很厉害的密码破解者，而且「你」不是普通人，具备在平行宇宙之间穿梭的能力。而 Alice 有一个地图三染色的答案，你的目的是通过和 Alice 对话来获取地图三染色的答案，会话的过程参考上一篇文章的「地图三染色问题」协议。&lt;/p&gt;

&lt;p&gt;继续脑洞，Alice 只存在「现实世界」中；在「理想世界」，Alice 被「替换」成了一个长相与声音一模一样的个体，我们称替身为 Zlice。下一步，把「你」同时放入两个世界中，但不让你知道是你当前位于哪一个世界。你的两个分身所面对的都是一个 “Alice”模样的人。&lt;/p&gt;

&lt;p&gt;再重复一遍，在「现实世界」中， 与你对话的是一个真实的，并且诚实的 Alice；而在「理想世界」中，与你对话的是  Zlice （假 Alice），Zlice 虽然相貌语言与 Alice 并无二致，但差异是，Zlice 并不知道「知识」，即不知道一个三染色问题的答案。&lt;/p&gt;

&lt;p&gt;接下来在这两个世界中，你的两个分身将同时与真假 Alice 进行对话。神奇的事情发生了，最终在两个世界中，你的两个分身都被说服了，都经过&lt;code&gt;n&lt;/code&gt;轮挑战，没有发现对方作弊，即「你」的两个分身都认为对方确实知道「答案」。换句话说，「你」没有能力「区分」出来自己到底在 「现实世界」 还是 「理想世界」，当然也没能力「区分」和自己对话的究竟是 Alice 还是 Zlice。不仅如此，对于吃瓜群众我而言，如果把「我」作为观察者放入任何一个世界中，我会和你一样「无法区分」出来眼前的 这个长相为 “Alice” 的人到底是真还是假。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/indist.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是烧脑结论：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个交互系统为何是「零知识」？因为 Zlice 是没有任何知识，而且她和 Alice 不可区分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我再换个方式解释：因为你和我都没办法区分我们究竟是在哪个世界中，两个世界发生的交互过程几乎不可区分，而且其中一个世界中根本就不存在知识，因此，我们说这个交互协议——「地图三染色问题」是「零知识的」。&lt;/p&gt;

&lt;p&gt;这里还有个前提，&lt;code&gt;理想世界&lt;/code&gt;必须是算法可构造的。然后，有一个「神」，他通过算法「模拟」了一个「理想世界」，其中构造了一个算法叫做 Zlice，她没有「知识」作为输入，也即「零知识」；除此之外，「理想世界」与「现实世界」一模一样。&lt;/p&gt;

&lt;p&gt;设想你在对话过程中，如果真 Alice 泄露了信息，那么你就能立即区分出面前这个人是 真 Alice 还是 Zlice，&lt;strong&gt;Zlice 是不可能伪装泄露信息的&lt;/strong&gt;。因此可以得出结论：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;真Alice 没有泄露任何信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个神，被称为「模拟器」（Simulator），而在理想世界中，和你对话的这个 Zlice 幻象其实也是「模拟器」，你在理想世界中，所有能感知到的东西都是模拟器「模拟」出来的。&lt;/p&gt;

&lt;p&gt;好了，到这里，我们用「模拟器」这个概念对「零知识」进行了定义。&lt;/p&gt;

&lt;p&gt;接下来，我们开始进入证明零知识的环节。&lt;/p&gt;

&lt;h2 id=&#34;区分两个世界&#34;&gt;区分两个世界&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;（Save World State as Snapshot X）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;证明的零知识过程，等价于构造（寻找）一个「模拟」算法，这个算法能够让模拟器来模拟出一个「没有知识」的理想世界。如果这个算法存在，而且两个世界不可区分，那么就证明完毕。&lt;/p&gt;

&lt;p&gt;等等，可能「你」会觉得哪里不对劲。&lt;/p&gt;

&lt;p&gt;假如说真的存在这种算法，而且它能够在没有知识的情况下骗过我，那么在「现实世界」中，不排除真  Alice 也使用了这样的算法来欺骗我。这样一来，我岂不是在两个世界中都被欺骗了。那么这个交互协议就失去意义了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/inception.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其实，这里有个关键点，借用电影『盗梦空间』中的剧照，在「理想世界」中有点东西是和「现实世界」本质不同的。这个东西是区分两个世界的关键，而它要让我们「无法感知」。这个东西不是梦境中的陀螺，它是一种「超能力」，模拟器 Simulator 所具备的超能力。&lt;/p&gt;

&lt;p&gt;比如这样一种超能力：「时光倒流」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/time-rewind.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;（上图是电影『土拨鼠之日』的剧照，剧中主人公每次睡醒都会回到2月2日的早上，这样他永远活在同一天里）&lt;/p&gt;

&lt;p&gt;等等，各位看官，不是刚才我们一直在讨论不可区分性吗？怎么两个世界又需要区分啦？“我糊涂了”。不要慌，所谓的不可区分性针对的是理想世界中的个体认知而言。而「可区分性」是对位于世界外部的神而言。&lt;/p&gt;

&lt;p&gt;设想下在我们周围，如果有一个人有时空穿越能力，或者他能让时间回退到一年前，那么我们这些凡夫俗子完全是一脸茫（meng）然（bi）的，无从感知。那么，如果「模拟器」可以在他构造出的「理想世界」中实现「时间倒流」，那么他就可以达成一些神奇的事情，从而骗过作为验证者身份的「你」，也能骗过观察者「我」。对于「你」而言，你明白，在「理想世界」中，时间是可以回退的，但是在「现实世界」中，显然真 Alice 不可能拥有超能力。虽然你和我不能区分在哪个世界里，但是&lt;strong&gt;至少我们知道在两个世界中的其中「现实世界」里，对面那个Alice是没办法欺骗我们的&lt;/strong&gt;，当然我们却不能说出我们到底在哪个世界中。&lt;/p&gt;

&lt;p&gt;到此，交互协议的「零知识」已经证明完了。各位是否已经明白了？我再给大家再梳理下证明思路：&lt;/p&gt;

&lt;p&gt;首先「零知识」是为了保护 Alice 的利益，因为 Alice 不想在交互过程中透露更多的信息给 Bob，不想让 Bob 知道她所拥有的秘密 &lt;code&gt;w&lt;/code&gt;，甚至不想让 Bob 从交互的过程中分析出哪怕一丁点的信息。那么怎么保证这一点呢？「模拟器」这时候登场了，它能模拟出一个和现实世界外表一模一样的「理想世界」，然后「模拟器」在这个世界中可以轻松地骗过任何一个对手，让对方无法分辨自己是在现实世界中，还是理想世界中。因为「模拟器」手里没有那个秘密 &lt;code&gt;w&lt;/code&gt;，「理想世界」是零知识的。又因为两个世界的不可区分性，所以我们可以得出结论：Alice 的交互协议是「零知识」的。&lt;/p&gt;

&lt;p&gt;我们来看一个具体的例子，上一篇文章[1]中提到的地图3染色问题。&lt;/p&gt;

&lt;h2 id=&#34;地图三染色问题的零知识证明&#34;&gt;地图三染色问题的零知识证明&lt;/h2&gt;

&lt;p&gt;回忆一下「地图三染色问题交互系统」：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-123.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一步：Alice 把地图染色答案做一次完全置换，然后将所有顶点盖上纸片，交给 Bob&lt;/li&gt;
&lt;li&gt;第二步：Bob 随机挑选一条边&lt;/li&gt;
&lt;li&gt;第三步： Alice 打开指定边的两端顶点的纸片，Bob检验两个顶点的颜色是否相同，如果不同则通过，如果相同则失败&lt;/li&gt;
&lt;li&gt;回到第一步，重复 &lt;code&gt;n&lt;/code&gt; 遍&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们接下来就来证明上述这个交互是零知识的，这里先假设验证者 Bob 是诚实的，这有助于大家理解这个证明过程。然后我们再讨论，如果 Bob 不诚实的证明方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk0.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在「理想世界」中，跟 Bob 对话的是一个「模拟器」，它模拟出了整个世界的样子。Bob 按照三染色问题的交互协议进行交互。模拟器并没有一个三染色答案，它索性把所有的顶点都染成了灰色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先，模拟器模仿 Alice ，把每个顶点用纸片盖起来。然后发给 Bob。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bob 随机挑选了一条边，挑战证明者。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;模拟器这时候不能打开纸片，因为这条边两端的颜色都是灰色啊。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这时候，模拟器要发挥「超能力」了，他运用时间倒流的技能，回到对话第一步之前。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;模拟器现在处于第一步，他把最下面那条边的两端染上任意不同的颜色，然后重新盖上纸片，并发给 Bob。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bob 这时候无法感知到时间已经倒退回第一步了，对他来说，一切都是新鲜的，他「诚实」地再次选择了最下面的边。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-zk7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这时候模拟器就可以放心地打开纸片，让 Bob 检查。Bob 很显然会被骗过。然后 Bob 一轮轮地重复这个过程，每一次模拟器都能用时间倒流的方式骗过 Bob。&lt;/p&gt;

&lt;p&gt;于是在理想世界中，模拟器并没有任何三染色答案的「知识」，却同样能骗过Bob，并且从概率上来看，与「现实世界」中被观察到的交互过程高度地一致（完全一致的概率分布）。于是上面的过程&lt;strong&gt;展示了模拟器的算法的存在性，也就相当于证明了交互系统的「零知识性质」&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;不诚实的-bob&#34;&gt;不诚实的 Bob&lt;/h4&gt;

&lt;p&gt;在上面的证明过程中，有一个相当强的假设，就是每次时间倒流之后，Bob都会选择同一条边。如果 Bob 每次都会换一条不同的边呢？没关系，如果在模拟器第一次实施时间倒流之后，Bob又选择了不同的边，那么模拟器可以把颜色打乱之后，再次运行时间倒流，在多次时间倒流之后，Bob 极大的概率总会一次选择模拟器进行染色的那条边，然后这时候模拟器才走到第三步，打开纸片。&lt;/p&gt;

&lt;h2 id=&#34;阿里巴巴-洞穴与芝麻开门&#34;&gt;阿里巴巴、洞穴与芝麻开门&lt;/h2&gt;

&lt;p&gt;在网上众多的讲解「零知识证明」的中文科普文章中，有一个例子流传非常广，这就是阿里巴巴与强盗的故事。可惜地是，这些不同版本的故事都&lt;strong&gt;只讲了一半&lt;/strong&gt;。那么我接下来讲一个不一样的「阿里巴巴」与「四十大盗」的故事：&lt;/p&gt;

&lt;p&gt;在很久很久以前，在一个叫做巴格达的城市里，住着一个人叫阿里巴巴。每天阿里巴巴会到集市上买东西。&lt;/p&gt;

&lt;p&gt;有一天，阿里巴巴被一个盗贼抢了钱包，于是他一路追着盗贼到了一个山洞口，然后盗贼就消失了。阿里巴巴发现洞口里面有两条岔路，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/alibaba2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;阿里巴巴不知道盗贼往哪边跑了，于是他决定去「左边」岔道看看，很快阿里巴巴就发现这是个死胡同，也不见盗贼踪影。然后他又去「右边」岔道检查，也是个死胡同，不见盗贼踪影。阿里巴巴自言自语道：「该死的盗贼跑哪去了呢？」&lt;/p&gt;

&lt;p&gt;第二天，阿里巴巴又去集市买东西，这次另一个盗贼抢了他的篮子，然后阿里巴巴追着这个盗贼到了昨天同样的山洞口，然后盗贼又不见了，这一次阿里巴巴决定先去「右边」岔道看看，没有发现盗贼，然后再去左边看看，也同样不见盗贼。这好奇怪。&lt;/p&gt;

&lt;p&gt;第三天，第四天，……，第四十天，同样的故事上演，阿里巴巴追着第四十个大盗到了神秘的洞口，盗贼就消失了。阿里巴巴想，这个山洞里面一定有机关，于是他躲在「右边」岔道的尽头，耐心地等了很长时间，这时一个盗贼跑了进来，走道岔道尽头之后，念了一个咒语「芝麻开门」。这时候墙壁居然打开了，盗贼跑进去之后，然后墙壁又合上了，这时候另一个受害者追了进来，找了半天，一无所获。&lt;/p&gt;

&lt;p&gt;阿里巴巴随后等他们走了之后，试验了一下这个咒语，果然非常有效，而且阿里巴巴发现这个墙壁通向「左边」岔道。后来，阿里巴巴找到了更换咒语的办法，并且把一个新咒语和洞穴的地理位置写在了一张羊皮纸上。&lt;/p&gt;

&lt;p&gt;注：到这里，故事并没有结束&amp;hellip;. （上字幕）很久很久以后&lt;/p&gt;

&lt;p&gt;在很多年后，到了80年代，阿里巴巴的羊皮纸流落到了几个密码学家手里，他们跑到巴格达，找到了洞穴的位置，尽管过了几个世纪，咒语居然仍然有效，这几个密码学家兴奋地打开墙壁，在两个岔道之间跑来跑去。&lt;/p&gt;

&lt;p&gt;一家电视台很快知道了这个奇异事件，一个密码学家 Mick Ali（与密码学家 Micali 发音相似）决定向电视观众展示他知道这个咒语，首先，电视节目主持人把摄像机架在洞口，然后让所有人都在山洞口等待，这时候 Mick Ali一个人进入到山洞中，然后主持人抛一个硬币，来决定让 Mick Ali 从哪个岔道跑出来。为了纪念阿里巴巴与四十大盗，Mick Ali 重复了四十遍每次都成功。&lt;/p&gt;

&lt;p&gt;节目非常成功。但很快，另外一个电视台眼红，也想拍一个类似的节目，但是Mick Ali 因为签了独家协议，没办法参与这个新节目。怎么办呢？第二个电视台的主持人心生一计，他找了一个和 Mick Ali 很像的演员，穿着打扮、姿态和说话口音都模仿 Mick Ali。然后他们开拍了，每次主持人掷硬币后，都让这个演员跑出来，但是很显然，演员并不知道咒语，没办法打开那个墙壁。于是有时候演员碰巧会成功，有时候则会失败，于是演员很辛苦，重复了将近一百次，才成功了四十次。最后这个狡猾的新节目主持人，把&lt;strong&gt;录制视频进行了剪辑&lt;/strong&gt;，只保留了成功的片段，错误的片段都删除了。然后这个新节目和 Mick Ali 的节目在同一时间，不同频道播出。然后观众们&lt;strong&gt;完全无法区分&lt;/strong&gt;哪个视频是真的，哪个视频是假的。第一个电视台的主持人完全明白 Mick Ali 是真正知道墙壁的咒语的人，但是他却不能把这个事实传递给无辜的观众们。&lt;/p&gt;

&lt;p&gt;看到这里，大家是不是对「模拟」慢慢有了感觉？这里第二个电视台的主持人通过剪辑视频的方式，而不是「时间倒流」。他对「理想世界」，也就是电视中播出的内容所在的世界，进行了外部干预，达到了同样的效果。对理想世界而言，这种剪辑本质上就是一种超能力。&lt;/p&gt;

&lt;p&gt;这个故事其实来源于一篇论文『如何向你的孩子解释零知识证明』（How to Explain Zero-Knowledge Protocols to Your Children）[3]，发表在1989年的美密会议上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/alibaba.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;模拟与图灵机&#34;&gt;模拟与图灵机&lt;/h2&gt;

&lt;p&gt;一谈到超能力，大家有没有觉得这玩意不科学。是的，如果我们无脑地用「超能力」来解释任何事情，那么我们逻辑就无法自恰（Consistent）。&lt;strong&gt;在理想世界中，模拟器是不能随便开挂的&lt;/strong&gt;，比如模拟器肯定不能直接修改 Bob 的内部状态，比如 Bob 在验证步骤明明验证失败，但是模拟器强硬去把验证结果改为「接受」，这会导致我们可以证明：「任何的交互系统都是零知识的」，这个错误结论。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;模拟器不是理想世界中全能的上帝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么模拟器到底可以是什么呢？模拟器其实只是一个图灵机。所谓的「时间倒流」，「剪辑录像」这类的所谓超能力并不是玄乎的超自然能力，而是图灵机可以实现的功能。计算机专业的朋友们肯定都用过 VMWare，虚拟机之类的软件，本文讲的「模拟器」完全可以想象成一个「虚拟机」软件，它能虚拟出一个计算机环境，这个虚拟环境就是我们上文说的「理想世界」。「时间倒流」如何解释呢？不知道大家有没有用过虚拟机软件的「快照」功能（Snapshot），使用快照的时候，虚拟机软件可以把整个虚拟计算机的所有状态保存下来，然后在任意时刻，虚拟机软件都可以重新回到保存快照的位置继续运行。&lt;/p&gt;

&lt;p&gt;注：其实所谓时间倒流是计算机中的一个基本操作，在程序语言理论中有一个概念叫做 Continuation。抽象地讲，Continuation 表示从现在开始到未来的计算。Continuation这是控制流的一个显式抽象，而 goto，call-with-current-continuation，甚至 thread scheduling  都可以看做是操作 Continuation 的操作符。比如采用call/cc，也就是call-with-current-continuation 就可以轻松地实现「回溯」功能。保存快照可以理解为保存当前的 Continuation，而回到过去的某一刻，就是应用这个Continuation。&lt;/p&gt;

&lt;p&gt;不管 Zlice 还是 Bob，还有我们的每一个观察者，都是一个个可执行程序。&lt;strong&gt;这些程序被拷贝到了虚拟机里&lt;/strong&gt;。Zlice 与 Bob 的会话实际上就是这两个程序之间的通讯。观察者是 Hook 在 Zlice 与 Bob 进程 IO 上的程序。在上文的地图三染色「理想世界」的诚实 Bob，实际上是 Bob 进程调用了虚拟机的「随机数发生器」，而这个随机数发生器是能被 Zlice 操纵的。「现实世界」是外部运行虚拟机软件的计算机环境。&lt;/p&gt;

&lt;p&gt;大家是不是又有所悟，我再强调一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;证明零知识的过程，就是要寻找一个算法，或者更通俗点说，写出一段代码，它运行在外部计算机系统中，但是实现了虚拟机的功能。而且在虚拟机中，需要有一个不带有「知识」作为输入的 Zlice，可以骗过放入虚拟机运行的 Bob。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果还没理解上面我这句话，请&lt;strong&gt;时光回退&lt;/strong&gt;到『区分两个世界』这一小节，重新思考模拟。:P &lt;em&gt;（Load World State from Snapshot X）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;柏拉图的洞穴寓言&#34;&gt;柏拉图的洞穴寓言&lt;/h2&gt;

&lt;p&gt;模拟无处不在，哥德尔不完备性定理就使用了模拟的概念，用哥德尔数（Godel Numbers）模拟了形式算术。图灵提出了「Universal Turing Machine」（通用图灵机）的概念，这种图灵机可以模拟自身。&lt;/p&gt;

&lt;p&gt;但最早的「模拟」概念，出自『理想国』一书的第七卷[4]中，古希腊哲学家柏拉图讲了这么一则寓言——Allegory of Cave：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/plato-cave.jpeg&#34; alt=&#34;plato&#39;s cave&#34; /&gt;&lt;/p&gt;

&lt;p&gt;设想在一个暗无天日的山洞中，有一排被锁链锁住的囚徒，他们从小就只能看到前方的墙壁。这些囚徒们身后是一堵墙，再后面有一堆放着火，在火与墙壁之间，有一些人举着道具和木偶来回走，这样道具木偶就会在火光映射下在墙壁上投下影子。而这些囚徒们整天就只能看着这些影子。因为这些囚徒们从打出生起，所闻所见就只是前方洞壁上的各种影子，他们会以为所看到的这些影子就是真实的世界。&lt;/p&gt;

&lt;p&gt;然而有一天，一个囚徒偶然挣脱锁链，他回头看到了火。但是他从小到大仅能看到暗淡的影子，他第一次看到了明亮的火光。看到了道具和木偶，假如有人告诉他，这些道具和木偶才是实物，他一定会嗤之以鼻，会坚持认为影子才是真实的。&lt;/p&gt;

&lt;p&gt;柏拉图假设说，如果这个囚徒强制拖出洞穴，到外面去看到真实的世界， 一开始囚徒会不适应真实世界的光亮而感到刺目眩晕，他会因此而愤怒。 但是当他慢慢适应了这个世界，看到太阳，树木，河流，看到星空，他逐渐明白，这个世界比洞穴中那个世界更为优越高级。他再也不想回到黑暗的洞穴生活中了。&lt;/p&gt;

&lt;p&gt;过了一段时间，他对洞穴中的囚徒心生怜悯，于是想去把他们都带出来。但是当他再次返回洞穴中，他因为已经适应了外面明亮的世界，回到洞穴中反而看不清楚。被锁的囚徒们反而认为他的视力受损，胡言乱语，是个疯子，最后当他想尽办法把这群囚徒带出洞穴时，被囚徒们联手杀死。&lt;/p&gt;

&lt;p&gt;这是则人类命运的寓言，就和那一排被锁链锁着的囚徒类似， 我们以为眼睛看到的就是世界的真相,但实际上，那也许是幻象，就像洞穴墙壁上投下的影子一样。&lt;/p&gt;

&lt;h2 id=&#34;未完待续&#34;&gt;未完待续&lt;/h2&gt;

&lt;p&gt;本文章介绍了理解零知识所需的关键概念——模拟。任何一个零知识的协议，都可以通过构造一个「理想世界」来理解。第一次接触这个概念的读者需要反复琢磨。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;计算机科学中有两个方法论至关重要，第一个是「抽象」，第二个是「模拟」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回顾一下在地图三染色问题中，Bob 在「理想世界」与「现实世界」中的对话。虽然 Bob 无法区分两个世界，但是有一点，他可以确信：现实世界中，Alice 没有超能力。&lt;/p&gt;

&lt;p&gt;问题来了，Alice 没有超能力，并不能直接证明 Alice 真的有答案。万一这个交互协议并不能保证 Alice 一定有知识呢？「零知识」保护了 Alice 的利益，谁来保证 Bob 的利益呢？这个问题留给下一篇。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;致谢&lt;/strong&gt;: 本文受密码学教授 Matthew Green 发表在2014年与2017年的两篇个人博客文章[10-11]启发。&lt;/p&gt;

&lt;h3 id=&#34;参考文献&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[1] 初识「零知识」与「证明」. 安比实验室. 2019.&lt;/li&gt;
&lt;li&gt;[2] Shafi Goldwasser and Silvio Micali, Probabilistic Encryption, Special issue of Journal of Computer and Systems Sciences, Vol. 28, No. 2, pages 270-299, April 1984.&lt;/li&gt;
&lt;li&gt;[3]Quisquater, J.J., Quisquater, M., Quisquater, M., Quisquater, M., Guillou, L., Guillou, M.A., Guillou, G., Guillou, A., Guillou, G. and Guillou, S., 1989, August. How to explain zero-knowledge protocols to your children. In &lt;em&gt;Conference on the Theory and Application of Cryptology&lt;/em&gt; (pp. 628-631). Springer, New York, NY.&lt;/li&gt;
&lt;li&gt;[4] 柏拉图 and 吴献书, 1986. 理想国 (Vol. 1, No. 986, p. 1). 商务印书馆.&lt;/li&gt;
&lt;li&gt;[5] Goldwasser, Shafi, Silvio Micali, and Charles Rackoff. &amp;ldquo;The knowledge complexity of interactive proof systems.&amp;rdquo; &lt;em&gt;SIAM Journal on computing&lt;/em&gt; 18.1 (1989): 186-208.&lt;/li&gt;
&lt;li&gt;[6] Oded, Goldreich. &amp;ldquo;Foundations of cryptography basic tools.&amp;rdquo; (2001).&lt;/li&gt;
&lt;li&gt;[7] Rackoff, Charles, and Daniel R. Simon. &amp;ldquo;Non-interactive zero-knowledge proof of knowledge and chosen ciphertext attack.&amp;rdquo; Annual International Cryptology Conference. Springer, Berlin, Heidelberg, 1991.&lt;/li&gt;
&lt;li&gt;[8] Goldreich, Oded, Silvio Micali, and Avi Wigderson. &amp;ldquo;Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems.&amp;rdquo; Journal of the ACM (JACM) 38.3 (1991): 690-728.&lt;/li&gt;
&lt;li&gt;[9] zkPoD: 区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易. 安比实验室. 2019.&lt;/li&gt;
&lt;li&gt;[10] Matthew Green. Zero Knowledge Proofs: An illustrated prime. 2014. &lt;a href=&#34;https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/&#34;&gt;https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[11] Matthew Green. Zero Knowledge Proofs: An illustrated primer, Part 2. 2017. &lt;a href=&#34;https://blog.cryptographyengineering.com/2017/01/21/zero-knowledge-proofs-an-illustrated-primer-part-2/&#34;&gt;https://blog.cryptographyengineering.com/2017/01/21/zero-knowledge-proofs-an-illustrated-primer-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>初识「零知识」与「证明」</title>
      <link>https://sec-bit.github.io/blog/2019/07/31/zero-knowledge-and-proof/</link>
      <pubDate>Wed, 31 Jul 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/07/31/zero-knowledge-and-proof/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;探索零知识证明系列（一）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;引言&#34;&gt;引言：&lt;/h2&gt;

&lt;p&gt;我认为区块链很难称为一个“技术”。它更像是一个领域，包罗万象。或者形而上地说，区块链更像一个有机体，融合了各种不同的理论技术。&lt;/p&gt;

&lt;p&gt;零知识证明是构建信任的重要技术，也是区块链这个有机体中不可缺少的一环。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;零知识证明是打通链上数据与链下计算的关键技术，也是实现链上数据隐私保护的重要途径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要解释「零知识证明」，我们需要先解释「证明」，然后解释什么是「知识」，最后再解释什么是「零知识」。&lt;/p&gt;

&lt;h2 id=&#34;证明-的前世今生&#34;&gt;&amp;ldquo;证明&amp;rdquo; 的前世今生&lt;/h2&gt;

&lt;p&gt;什么是证明？很多人可能和我一样，看到这两个字，会不禁想起中学考卷中各种三角相似的几何图形，当老师在神奇地画出一条辅助线后，证明过程突然显而易见，然后会懊悔自己为何没想到。&lt;/p&gt;

&lt;h4 id=&#34;古希腊-证明-洞见&#34;&gt;古希腊：「证明」 == 「洞见」&lt;/h4&gt;

&lt;p&gt;数学证明最早源于古希腊。他们发明（发现）了公理与逻辑，他们用证明来说服对方，而不是靠权威。这是彻头彻尾的「去中心化」。自古希腊以降，这种方法论影响了整个人类文明的进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/345.png&#34; alt=&#34;勾股定理的证明&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图是「勾股定理」的巧妙证明。历史上曾出现过许许多多精巧的证明，神奇的思路，天才的灵感。一旦一个命题被证明，上帝都无能为力。嗯，对了，还有那个「上帝不是万能的」证明：上帝不能造出一块他举不起来的石头。&lt;/p&gt;

&lt;p&gt;一个数学证明往往暗藏无比深刻的「洞见」，相信很多人都看过「费马大定理」的故事[1]，这个定理证明横跨四百年，从费马写下「这里空间太小，我写不下」，到怀尔斯最终登顶，耗费了许多代人的聪明才智。最近如「彭加莱猜想」，稍微带点年代感的如「哥德巴赫猜想」，还有我非常敬佩的华裔科学家张益唐十年磨一剑，在仔细研究了「Goldston-Pintz-Yıldırım」和 「Bombieri-Friedlander-Iwaniec.」的证明「洞见」之后，证明了「质数间的有界间隔」[2]。&lt;/p&gt;

&lt;p&gt;自十七世纪，莱布尼茨起，人们就梦想找到一种机械的手段，可以来自动完成证明，而不再依赖天才的灵光一现。&lt;/p&gt;

&lt;h4 id=&#34;二十世纪初-证明-符号推理&#34;&gt;二十世纪初：「证明」 == 「符号推理」&lt;/h4&gt;

&lt;p&gt;时间到了十九世纪末，康托、布尔、弗雷格、希尔伯特、罗素、布劳威、哥德尔等人定义了形式化逻辑的符号系统。而「证明」则是在利用形式化逻辑的符号语言编写的推理过程。逻辑本身靠谱么？逻辑本身「自恰」吗？逻辑推理本身对不对，能够证明吗？这让 数学家/逻辑学家/计算机科学家 发明（发现） 了符号系统，语法 vs. 语义，可靠 vs. 完备，递归 vs. 无穷。（这部分精彩故事请参看『逻辑的引擎』一书[3]）。&lt;/p&gt;

&lt;p&gt;1910年，罗素发表了洪(zhuan)荒(tou)巨著『数学原理』。在书中，罗素与怀特海试图将数学完整地「形式化」下来。如果能达到这样的目标，所有的数学成果都将以证明的方式建立在坚实的基础上。下图就是『数学原理（卷二）』中的一页：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/principle.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;110.643&lt;/code&gt;这是一个命题：「1+1=2」，然后接下来就是这个定理的证明。大家可能奇怪，难道 1+1 还需要证明吗？是的，在数学原理一书中，数字 0，1，2，…… 都有严格定义，「加法」、「乘法」、「等于」都要严格定义，然后每一步的推理都需要指出依据。证明意味着什么？证明是可能繁琐无比的、但是每一步推理都严格无误。书中大量的证明都机械式的，按照公理和推理规则进行一种证明的构造，寻找证明就好像可以交给一个人，然后他无脑在公理与推理规则的集合中进行机械查找。&lt;/p&gt;

&lt;p&gt;似乎人们距离「定理的自动证明」并不遥远了。&lt;/p&gt;

&lt;p&gt;不幸的是，哥德尔在 1931 年证明了「哥德尔不完备性定理」[4]，图灵在 1936 年证明了图灵机停机问题的不可判定性[5]。这些成果彻底终结了这个几百年的幻想。无论公理系统如何精巧设计，都无法抓住所有的真理。&lt;/p&gt;

&lt;p&gt;证明不仅仅是一个严格推理，而且凝结了似乎很难机械化的创造性思维。证明中蕴含了大量的「知识」，每一次的突破，都将我们的认知提升到一个新的高度。不管是「洞见」，还是推理过程中所构造的「算法」，一个定理的证明的内涵往往远超出定理本身的结论。&lt;/p&gt;

&lt;h4 id=&#34;六十年代-证明-程序&#34;&gt;六十年代：「证明」 == 「程序」&lt;/h4&gt;

&lt;p&gt;又过了半个世纪，到了六十年代，逻辑学家 Haskell Curry 和 William Howard 相继发现了在「逻辑系统」和「计算系统— Lambda 演算」中出现了很多「神奇的对应」，这就是后来被命名的「Curry-Howard Correspondence」。这个发现使得大家恍然大悟，「编写程序」和「编写证明」实际在概念上是完全统一的。而在这之后的 50 年，相关理论与技术发展使得证明不再停留在草稿纸上，而是可以用程序来表达。这个同构映射非常有趣：程序的类型对应于证明的定理；循环对应于归纳；……（这里推荐一本书：『软件基础』（Software Foundations 中译本）[6]）。在直觉主义框架中，证明就意味着构造算法，构造算法实际上就是在写代码。(反过来也成立，嗯，码农码的不是代码，是数学证明，:P)&lt;/p&gt;

&lt;p&gt;目前在计算机科学领域，许多理论的证明已经从纸上的草图变成了代码的形式，比较流行的「证明编程语言」有 Coq，Isabelle，Agda 等等。采用编程的方式来构造证明，证明的正确性检查可以机械地由程序完成，并且许多啰嗦重复性的劳动可以由程序来辅助完成。数学理论证明的大厦正在像计算机软件一样，逐步地构建过程中。1996 年 12 月 W. McCune 利用自动定理证明工具 EQP 证明了一个 长达 63 年历史的数学猜想「Ronbins 猜想」，『纽约时报』随后发表了一篇题为「Computer Math Proof Shows Reasoning Power」的文章[7]，再一次探讨机器能否代替人类创造性思维的可能性。&lt;/p&gt;

&lt;p&gt;利用机器的辅助确实能够有效帮助数学家的思维达到更多的未知空间，但是「寻找证明」仍然是最有挑战性的工作。「验证证明」，则必须是一个简单、机械、并且有限的工作。这是种天然的「不对称性」。&lt;/p&gt;

&lt;h4 id=&#34;八十年代-证明-交互&#34;&gt;八十年代：「证明」 == 「交互」&lt;/h4&gt;

&lt;p&gt;时间拨到1985年，乔布斯刚刚离开苹果，而 S. Goldwasser 博士毕业后来到了 MIT，与 S. Micali，Rackoff 合写了一篇能载入计算机科学史册的经典：『交互式证明系统中的知识复杂性』[8]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/gmr89.png&#34; alt=&#34;GMR89&#34; /&gt;&lt;/p&gt;

&lt;p&gt;他们对「证明」一词进行了重新的诠释，并提出了交互式证明系统的概念：通过构造两个图灵机进行「交互」而不是「推理」，来证明一个命题在概率上是否成立。「证明」这个概念再一次被拓展。&lt;/p&gt;

&lt;p&gt;交互证明的表现形式是两个（或者多个图灵机）的「对话脚本」，或者称为 Transcript。而这个对话过程，其中有一个显式的「证明者」角色，还有一个显式的「验证者」。其中证明者向验证者证明一个命题成立，同时还「不泄露其他任何知识」。这种就被称为「零知识证明」。&lt;/p&gt;

&lt;p&gt;再强调一遍，证明凝结了「知识」，但是证明过程确可以不泄露「知识」，同时这个证明验证过程仍然保持了简单、机械，并且有限性。这听上去是不是有点「反直觉」？&lt;/p&gt;

&lt;h2 id=&#34;交互式证明&#34;&gt;交互式证明&lt;/h2&gt;

&lt;p&gt;Alice: 我想向你证明我有一个方程的解，&lt;code&gt;w^3 - （w+1)^2 + 7 = 0&lt;/code&gt; （方程的解：&lt;code&gt;w=3&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;Bob: 好啊，我听着呢&lt;/p&gt;

&lt;p&gt;Alice: 但是我不会告诉你 x 具体是多少，除非你愿意掏钱，我才告诉你。&lt;/p&gt;

&lt;p&gt;Bob: 可以啊，但是你要先证明你有方程的解，我再给钱你。&lt;/p&gt;

&lt;p&gt;Alice: @#$%^&amp;amp; （黑科技）&lt;/p&gt;

&lt;p&gt;Bob:  ?????? （黑科技）&lt;/p&gt;

&lt;p&gt;Alice: &amp;amp;*#$@! （黑科技）&lt;/p&gt;

&lt;p&gt;Bob: ??????（黑科技）&lt;/p&gt;

&lt;p&gt;&amp;hellip;&amp;hellip; （继续黑科技）&lt;/p&gt;

&lt;p&gt;Alice: 好了，完了&lt;/p&gt;

&lt;p&gt;Bob: 好吧，你确实有方程的解，不过是不是我掏了钱，你就会把答案告诉我？&lt;/p&gt;

&lt;p&gt;Alice: 别废话，掏钱！&lt;/p&gt;

&lt;p&gt;上面例子就是一个「交互式证明」。假设Alice知道方程的解， &lt;code&gt;f(w) = 0&lt;/code&gt;，那么 Alice 如何让 Bob 确信她知道 &lt;code&gt;w&lt;/code&gt; 呢？Alice 在 「黑科技阶段」 告诉了 Bob 一大堆的信息。好了，关键问题是，Bob 能不能从 Alice 所说的一大堆信息中猜出&lt;code&gt;w&lt;/code&gt; 到底是几，或者能分析出关于 &lt;code&gt;w&lt;/code&gt; 的蛛丝马迹呢？如果 Bob 有这个能力，Bob也许就没必要掏钱了，因为他已经获得了这个值钱的信息。&lt;/p&gt;

&lt;p&gt;请注意，如果 Alice 与 Bob 的对话是 「零知识」 的，那么 Bob 除了知道 &lt;code&gt;w&lt;/code&gt; 是 &lt;code&gt;f(w)=0&lt;/code&gt; 的解之外，不能获取其它任何关于 &lt;code&gt;w&lt;/code&gt; 的信息。 这一点非常重要，这是保护 Alice 的利益。&lt;/p&gt;

&lt;p&gt;现在回顾一下「零知识证明」这个词，英文叫 「Zero-Knowledge Proof」 。这个词包含三个关键部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;零&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;知识&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;证明&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各位可能已经有点感觉了，我们来尝试着解读一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;零： Alice 泄露了关于 &lt;code&gt;w&lt;/code&gt; 的「零」知识，也就是没有泄露知识。&lt;/li&gt;
&lt;li&gt;知识：这里就是指的就是 &lt;code&gt;w&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;证明：就是Alice与Bob对话中的「黑科技部分」。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了，证明也就是黑科技部分还没讲。看官们不要急，且听我慢慢道来。&lt;/p&gt;

&lt;h2 id=&#34;零知识证明有什么用处&#34;&gt;零知识证明有什么用处？&lt;/h2&gt;

&lt;p&gt;一提零知识证明技术，很多人就想到了匿名 Coin，比如 Monero, 比如 ZCash。确实，这几个 Coin 很好地普及了零知识证明，我本人也是通过 ZCash 才第一次听说了零知识证明这个词。但是在更深入地了解这个技术之后，深深感觉这个技术的威力远不止这一点。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;零知识证明技术可以解决数据的信任问题，计算的信任问题！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;张三说他有100块钱，李四说他北大毕业，王五说要和八菲特共进午餐。空口无凭，&lt;code&gt;Show me the proof&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/showmeproof.jpg&#34; alt=&#34;show-me-the-proof&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么「零知识证明」能解决数据的信任如何理解呢？在上一篇文章『zkPoD: 区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易』[9]里面，我提到了一个概念「模拟」：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;零知识证明技术可以「模拟」出一个第三方，来保证某一个论断是可信的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换句话说，当我们收到一个加了密的数据， 然后还有一个零知识证明。这个零知识证明是说 「关于数据的 X 断言成立」，那么这等价于有一个天使在我们耳边悄声说，「关于数据的X 断言成立」！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/angel.png&#34; alt=&#34;trusted-party&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对于这个 &lt;code&gt;X 断言&lt;/code&gt;，可以非常灵活，它可以是一个 &lt;code&gt;NP&lt;/code&gt;复杂度的算法。大白话讲只要我们能写一段程序（一个多项式时间的算法）来判断一个数据是否满足 &lt;code&gt;X 断言&lt;/code&gt;，那么这个断言就可以用零知识证明的方式来表达。通俗点讲，只要数据判定是客观的，那么就零知识证明就适用。&lt;/p&gt;

&lt;p&gt;零知识证明的一些用处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据的隐私保护：在一个数据表格中，多多少少都有一些信息不想被暴露，比如当年我的成绩单，我只想向人证明，我的成绩及格了，但是我不想让别人知道我到底考了61分还是62分，这会很尴尬。我没有心脏病，但是保险公司需要了解这一点，但是我不想让保险公司知道我的隐私信息。那我可以证明给保险公司看，我没有心脏病，但是病历的全部并不需要暴露。我是一家企业，我想向银行贷款，我只想向银行证明我具备健康的业务与还款能力，但是我不想让银行知道我们的一些商业秘密。&lt;/li&gt;
&lt;li&gt;计算压缩与区块链扩容：在众多的区块链扩容技术中，Vitalik 采用 zkSNARK 技术能够给现有的以太坊框架带来几十倍的性能提升。因为有了计算的证明，同样一个计算就没必要重复多次了，在传统的区块链架构中，同样的计算被重复多次，比如签名的校验，交易合法性校验，智能合约的执行等等。这些计算过程都可以被零知识证明技术进行压缩。&lt;/li&gt;
&lt;li&gt;端到端的通讯加密：用户之间可以互相发消息，但是不用担心服务器拿到所有的消息记录，同时消息也可以按照服务器的要求，出示相应的零知识证明，比如消息的来源、与发送的目的地。&lt;/li&gt;
&lt;li&gt;身份认证：用户可以向网站证明，他拥有私钥，或者知道某个只要用户自己才知道的秘密答案，而网站并不需要知道，但是网站可以通过验证这个零知识证明， 从而确认用户的身份&lt;/li&gt;
&lt;li&gt;去中心化存储：服务器可以向用户证明他们的数据被妥善保存，并且不泄露数据的任何内容。&lt;/li&gt;
&lt;li&gt;信用记录：信用记录是另一个可以充分发挥零知识证明优势的领域，用户可以有选择性的向另一方出示自己的信用记录，一方面可以有选择的出示满足对方要求的记录分数，同时证明信用记录的真实性。&lt;/li&gt;
&lt;li&gt;构造完全公平的线上数字化商品的交易协议[9]。&lt;/li&gt;
&lt;li&gt;更多的例子，可以是任何形式的数据共享，数据处理与数据传输。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;举例-地图三染色问题&#34;&gt;举例：地图三染色问题&lt;/h2&gt;

&lt;p&gt;下面讲一个经典的问题，地图的三染色问题。如何用三种颜色染色一个地图，保证任意两个相邻的地区都是不同的颜色。我们把这个「地图三染色问题」转变成一个「连通图的顶点三染色问题」。假设每个地区都有一个首府（节点），然后把相邻的节点连接起来，这样地图染色问题可以变成一个连通图的顶点染色问题。&lt;/p&gt;

&lt;p&gt;下面我们设计一个交互协议：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「证明者」Alice&lt;/li&gt;
&lt;li&gt;「验证者」 Bob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alice 手里有一个地图三染色的答案，请见下图。这个图总共有 6 个顶点，9 条边。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-0.png&#34; alt=&#34;3c-0&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在 Alice 想证明给 Bob 她有答案，但是又不想让 Bob 知道这个答案。Alice 要怎么做呢？&lt;/p&gt;

&lt;p&gt;Alice 先要对染过色的图进行一些「变换」，把颜色做一次大挪移，例如把所有的绿色变成橙色，把所有的蓝色变成绿色，把所有的绿色变成橙色。然后 Alice  得到了一个新的染色答案，这时候她把新的图的每一个顶点都用纸片盖上，然后出示给 Bob 看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-1.png&#34; alt=&#34;3c-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看下图，这时候 Bob 要出手了（请见下图），他要随机挑选一条「边」，注意是随机，不让 Alice 提前预测到的随机数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-2.png&#34; alt=&#34;3c-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设 Bob 挑选的是最下面的一条边，然后告诉 Alice。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-3.png&#34; alt=&#34;3c-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这时候 Alice 揭开这条边两端的纸片，让 Bob 检查，Bob 发现这两个顶点的颜色是不同的，那么 Bob 认为这次检验同构。这时候，Bob 只看到了图的局部，能被说服剩下的图顶点的染色都没问题吗？你肯定觉得这远远不够，也许恰好 Alice 蒙对了呢？其它没暴露的顶点可能是胡乱染色的。&lt;/p&gt;

&lt;p&gt;没关系，Bob 可以要求 Alice 再来一遍，看下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/3c-4.png&#34; alt=&#34;3c-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Alice 再次把颜色做一次变换，把蓝色改成紫色，改绿色改成棕色，把橙色改成灰色，然后把所有的顶点盖上纸片。然后 Bob 再挑选一条边，比如像上图一样，选择的是一条竖着的边，然后让 Alice 揭开纸片看看，如果这时候 Bob 再次发现这条边两端的顶点颜色不同，那么 Bob 这时候已经有点动摇了，可能 Alice 真的有这个染色答案。可是，两次仍然不够，Bob 还想再多来几遍。&lt;/p&gt;

&lt;p&gt;那么经过反复多次重复这三个步骤，可以让 Alice 作弊并能成功骗过 Bob 的概率会以指数级的方式减小。假设经过 &lt;code&gt;n&lt;/code&gt; 轮之后，Alice 作弊的概率为
$$
Pr[(G, c)\ | \ ThreeColor(G, c) = 0] &amp;lt; (1 - \frac{1}{|E|})^n
$$&lt;/p&gt;

&lt;p&gt;这里 &lt;code&gt;|E|&lt;/code&gt; 是图中所有边的个数， 如果 &lt;code&gt;n&lt;/code&gt; 足够大，这个概率 &lt;code&gt;Pr&lt;/code&gt; 会变得非常非常小，变得「微不足道」。&lt;/p&gt;

&lt;p&gt;可是，Bob 每次看到的局部染色情况都是 Alice 变换过后的结果，无论 Bob 看多少次，都不能拼出一个完整的三染色答案出来。实际上，Bob 在这个过程中，虽然获得了很多「信息」，但是却没有获得真正的「知识」。&lt;/p&gt;

&lt;h2 id=&#34;信息-vs-知识&#34;&gt;信息 vs. 知识&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;信息 「Information」&lt;/li&gt;
&lt;li&gt;知识 「Knowledge」&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在地图三染色问题的交互证明中，当重复交互很多次之后，Bob 得到了大量的信息，但是这好比 Alice 发给 Bob 一堆随机数一样，Bob 并没有「知道」更多的东西。打个比方，如果 Alice 告诉 Bob 「1+1=2」，Bob 得到了这个信息，可是 Bob 并没有额外获取更多的「知识」，因为这个事实人人皆知。&lt;/p&gt;

&lt;p&gt;假如 Alice 告诉 Bob &lt;code&gt;2^2^41-1&lt;/code&gt;这个数是一个质数，很显然这个是「知识」，因为要算出来这个数是不是一个质数，这需要耗费大量的算力。&lt;/p&gt;

&lt;p&gt;假如 Alice 告诉 Bob，总共有两个顶点用了绿颜色，那么 Bob 就获得了宝贵的「知识」，因为基于他刚刚获取的这个信息，Bob 可以用更短的时间用一台图灵机去求解三染色问题。假如 Alice 又透露给 Bob，最左边的顶点颜色是用橙色，那么很显然，这个「信息」对于 Bob 求解问题并没有实质上的帮助。&lt;/p&gt;

&lt;p&gt;我们可以尝试定义一下，如果 Bob 在交互过程中获得的「信息」，可以帮助提升 Bob 直接破解 Alice 秘密的能力，那么我们说 Bob 「获得了知识」。由此可见，知识这个词的定义与 Bob 的计算能力相关，如果信息并不能增加 Bob 的计算能力，那么信息不能被称为「知识」。比如在 Alice 与 Bob 交互过程中，Alice 每次都掷一个硬币，然后告诉 Bob 结果，从信息角度看，Bob 得到的信息只是一个「事件」，然而 Bob 并没有得到任何「知识」，因为 Bob 完全可以自己来掷硬币。&lt;/p&gt;

&lt;p&gt;下面引用『Foundations of Cryptography—— Basic Tools』一书[10]中的总结&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;「知识」是与「计算难度」相关，而「信息」则不是&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;「知识」是与公共所知的东西有关，而「信息」主要与部分公开的东西有关&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：曾有人问我，这里的信息与知识的定义是否与 Kolmogorov 复杂性有关。根据算法信息论，一段字符串的信息量可以用产生字符串的最小程序的长度来测量。这个问题我不是很懂，希望路过的专业人士留言。&lt;/p&gt;

&lt;h2 id=&#34;可验证计算与电路可满足性问题&#34;&gt;可验证计算与电路可满足性问题&lt;/h2&gt;

&lt;p&gt;看了上面的地图三染色问题，大家是不是没有感觉，好像这只是一个学术问题，如何跟现实问题关联起来？地图三染色问题是一个 NP-Complete 问题，这是「计算理论」中的一个名词。另外有一个叫做「电路可满足问题」也是同样是 NP-Complete 问题。NP-Complete 是一类问题，他的求解过程是多项式时间内难以完成的，即「求解困难」，但是验证解的过程是多项式时间可以完成的，即「验证简单」。&lt;/p&gt;

&lt;p&gt;那什么是电路呢？下面是三个不同的「算术电路」：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/circuits.png&#34; alt=&#34;circuits&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到一个电路由很多个门组成，其中有加法门，还有乘法门。每一个门有几个输入引脚，有几个输出引脚。每一个门做一次加法运算，或乘法运算。别看这么简单，我们平时跑的（没有死循环）代码，都可以用算术电路来表示。&lt;/p&gt;

&lt;p&gt;这意味着什么呢？我们下面结合「零知识证明」与「电路可满足性问题」来试着解决数据的隐私保护问题。&lt;/p&gt;

&lt;p&gt;下面请思考一个场景：Bob 交给 Alice 一段代码 &lt;code&gt;P&lt;/code&gt;，和一个输入 &lt;code&gt;x&lt;/code&gt;，让 Alice 来运行一遍，然后把运行结果告诉 Bob。可能这个计算需要消耗资源，而 Bob 把计算过程外包给了 Alice。然后 Alice 运行了一遍，得到了结果 &lt;code&gt;y&lt;/code&gt;。然后把 &lt;code&gt;y&lt;/code&gt; 告诉 Bob。下面问题来了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何让 Bob 在不运行代码的前提下，相信代码 &lt;code&gt;P&lt;/code&gt; 运行的结果一定是 &lt;code&gt;y&lt;/code&gt; 呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里是思考时间，大家可以想个五分钟 ……&lt;/p&gt;

&lt;p&gt;（五分钟后……）&lt;/p&gt;

&lt;p&gt;Alice 的一种做法是可以把整个计算过程用手机拍下来，这个视频里面包含了计算机 CPU，还有内存，在整个运行过程中的每一晶体管的状态。很显然这么做是不现实的。那么有没有更可行的方案呢？&lt;/p&gt;

&lt;p&gt;答案是 Bob 把程序 &lt;code&gt;P&lt;/code&gt; 转换成一个完全等价的算术电路，然后把电路交给 Alice。Alice 只要计算这个电路就可以了，然后这个过程是可以用手机拍下来的，或者用纸记下来，如果电路规模没有那么大的话。Alice 只要把参数 6 输入到电路，然后记录下电路在运算过程中，所有与门相连的引脚线上的值。并且最后的电路输出引脚的值等于 &lt;code&gt;y&lt;/code&gt;，那么 Bob 就能确信 Alice 确实进行了计算。Alice 需要把电路的所有门的输入与输出写到一张纸上，交给 Bob，这张纸就是一个计算证明。&lt;/p&gt;

&lt;p&gt;这样 Bob 完全可以在不重复计算电路的情况下来验证这张纸上的证明对不对，验证过程很简单：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bob 依次检查每一个门的输入输出能不能满足一个加法等式或者一个乘法等式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如 1 号门是一个加法门，它的两个输入是 3，4，输出是7，那么很容易就知道这个门的计算是正确的。当 Bob 检查完所有的门之后，就能确信：&lt;/p&gt;

&lt;p&gt;Alice 确确实实进行了计算，没有作弊。&lt;/p&gt;

&lt;p&gt;这张纸上的内容就是「满足」算术电路 &lt;code&gt;P&lt;/code&gt; 的一个解「Solution」。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;所谓的电路可满足性就是指，存在满足电路的一个解。如果这个解的输出值等于一个确定值，那么这个解就能「表示」电路的计算过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于 Alice 而言，Bob 如果用这种方式验证，她完全没有作弊的空间。但是这种方法很显然有个弊端：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;弊端一：如果电路比较大，那么证明就很大，Bob 检查证明的工作量也很大。&lt;/li&gt;
&lt;li&gt;弊端二：Bob 在验证过程中，知道了所有的电路运算细节，包括输入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;黑科技&#34;&gt;黑科技&lt;/h4&gt;

&lt;p&gt;我们再对刚才的 Alice 与 Bob 的场景做些修改。假如，Alice 自己还有一个秘密，比如说网银密码。而 Bob 想知道 Alice 的网银密码的长度是不是 20 位长。而 Alice 想了下，告诉他密码长度应该问题不大。这时候 Bob 把一个计算字符串长度的代码转换成了电路 Q，并且发给 Alice。Alice 用电路 Q 算了一下自己的密码，然后把电路所有门的引脚发给了 Bob，并带上运算结果 20。&lt;/p&gt;

&lt;p&gt;Wai……t，这是有问题的，Bob 拿到电路运算过程中的所有内部细节之后，不就知道密码了吗？是的，Alice 显然不能这么做。那么 Alice 应该怎么做？&lt;/p&gt;

&lt;p&gt;答案是有很多种办法，热爱区块链技术的读者最耳熟的就是 zkSNARK[11]，还有zkSTARK[12]，子弹证明BulletProof[13]，以及一些比较小众的技术，都可以帮 Alice 做到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Alice 以一种零知识的方式，向 Bob 证明她计算过了电路，并且使用了她的秘密输入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换句话说，这些「零知识的电路可满足性证明协议」为 Alice 提供了强大的武器来向 Bob 证明她的网银密码长度为 20，并且除此之外， Bob 再也得不到任何其它有用的信息。除了网银密码，Alice 理论上可以向 Bob 证明任何她的隐私数据的某些特性，但是并不暴露任何别的信息。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「零知识的电路可满足性证明协议」提供了一种最直接的保护隐私/敏感数据的技术&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近几年来，零知识证明构造技术发展日新月异，并且在区块链技术领域得到了越来越多的应用。最新的零知识证明技术，有的技术可以让 Bob 高速验证证明（在移动设备上几毫秒验证完成）；有的技术可以让所有吃瓜群众帮忙验证（非交互式零知识证明）；有的技术支持非常小的证明大小（小到几十个字节）。后续文章我们会逐步展开介绍。&lt;/p&gt;

&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;无论是精妙的数论定理，地图三染色问题，还是电路可满足性问题。证明存在的意义是什么？所有的证明都体现了「证明」与「验证」的「不对称性」。证明可能是一个非常耗费算力，或者脑力的活动，无论是耗时几百年的「费马大定理」，还是比特币中的 POW 证明，这些证明都凝结了在寻找证明过程中所消耗的能量，证明过程可能是超乎寻常的复杂，偶尔需要天才横空出世。而验证过程一定（或者应该）是一个非常简单的，机械的，在（多项式）有效时间内且能终止的活动。某种意义上，这个不对称性真正体现了证明的意义，展示了零知识证明的价值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;粗略看，「证明」是「逻辑」的产物，但「逻辑」与「计算」却又有着密不可分的联系，大家可能模模糊糊感觉到一些关于「证明」与「计算」之间的关联，它们贯穿始终：如机械推理、证明表达、交互计算 。这是一个有趣但更宏大的哲学问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;提醒：文章内容难免有不准确或不严谨的描述，还请各位专业人士拨冗指正。&lt;/p&gt;

&lt;p&gt;本文将在 Github 进行更新。&lt;/p&gt;

&lt;h3 id=&#34;参考文献&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[1] 西蒙, 辛格, 薛密. 费马大定理: 一个困惑了世间智者 358 年的谜[M]. 上海译文出版社, 1998.&lt;/li&gt;
&lt;li&gt;[2]  Alec Wilkinson. The Pursuit of Beauty: Yitang Zhang solves a pure-math mystery. The New Yorker. Feb. 2015.&lt;/li&gt;
&lt;li&gt;[3] 马丁, 戴维斯, 张卜天. 逻辑的引擎[M]. 湖南科学技术出版社, 2012.&lt;/li&gt;
&lt;li&gt;[4] Raymond Smullyan. Gödel&amp;rsquo;s Incompleteness Theorems, Oxford Univ.Press. 1991.&lt;/li&gt;
&lt;li&gt;[5] Turing, Alan. &amp;ldquo;On computable numbers, with an application to the Entscheidungsproblem.&amp;rdquo; &lt;em&gt;Proceedings of the London mathematical society&lt;/em&gt; 2.1 (1937): 230-265.&lt;/li&gt;
&lt;li&gt;[6] Pierce, Benjamin C., et al. &amp;ldquo;Software foundations.&amp;rdquo; 中文译文: &amp;lt;&lt;a href=&#34;https://github.com/Coq-zh/SF-zh&#34;&gt;https://github.com/Coq-zh/SF-zh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[7] Kolata, Gina. &amp;ldquo;Computer math proof shows reasoning power.&amp;rdquo; &lt;em&gt;Math Horizons&lt;/em&gt; 4.3 (1997): 22-25.&lt;/li&gt;
&lt;li&gt;[8] Goldwasser, Shafi, Silvio Micali, and Charles Rackoff. &amp;ldquo;The knowledge complexity of interactive proof systems.&amp;rdquo; &lt;em&gt;SIAM Journal on computing&lt;/em&gt; 18.1 (1989): 186-208.&lt;/li&gt;
&lt;li&gt;[9] zkPoD: 区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易. 安比实验室. 2019.&lt;/li&gt;
&lt;li&gt;[10] Oded, Goldreich. &amp;ldquo;Foundations of cryptography basic tools.&amp;rdquo; (2001).&lt;/li&gt;
&lt;li&gt;[11] Gennaro, Rosario, et al. &amp;ldquo;Quadratic span programs and succinct NIZKs without PCPs.&amp;rdquo; Annual
International Conference on the Theory and Applications of Cryptographic Techniques. Springer Berlin, Heidelberg, 2013.&lt;/li&gt;
&lt;li&gt;[12] Ben-Sasson, Eli, et al. &amp;ldquo;Scalable, transparent, and post-quantum secure computational integrity.&amp;rdquo; &lt;em&gt;IACR Cryptology ePrint Archive&lt;/em&gt; 2018 (2018): 46.&lt;/li&gt;
&lt;li&gt;[13] Bünz, Benedikt, et al. &amp;ldquo;Bulletproofs: Short proofs for confidential transactions and more.&amp;rdquo; 2018
IEEE Symposium on Security and Privacy (SP). IEEE, 2018.&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>zkSNARKs 合约库「输入假名」漏洞致众多零知项目存在安全风险</title>
      <link>https://sec-bit.github.io/blog/2019/07/29/the-input-aliasing-bug-caused-by-a-contract-library-of-zksnarks/</link>
      <pubDate>Mon, 29 Jul 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/07/29/the-input-aliasing-bug-caused-by-a-contract-library-of-zksnarks/</guid>
      
        <description>

&lt;p&gt;大量零知识证明项目由于错误地使用了某个 zkSNARKs 合约库，引入「输入假名 (Input Aliasing) 」漏洞，可导致伪造证明、双花、重放等攻击行为发生，且攻击成本极低。众多以太坊社区开源项目受影响，其中包括三大最常用的 zkSNARKs 零知开发库 snarkjs、ethsnarks、ZoKrates，以及近期大热的三个混币（匿名转账）应用 hopper、Heiswap、Miximus。&lt;/p&gt;

&lt;h2 id=&#34;双花漏洞-最初暴露的问题&#34;&gt;双花漏洞：最初暴露的问题&lt;/h2&gt;

&lt;p&gt;semaphore 是一个使用零知识证明技术的匿名信号系统，该项目由著名开发者 barryWhiteHat 此前的混币项目演化而来。&lt;/p&gt;

&lt;p&gt;俄罗斯开发者 poma 最先指出该项目&lt;a href=&#34;https://github.com/kobigurk/semaphore/issues/16&#34;&gt;可能存在双花漏洞&lt;/a&gt;[1]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;poma-found.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;问题出在&lt;a href=&#34;https://github.com/kobigurk/semaphore/blob/602dd57abb43e48f490e92d7091695d717a63915/semaphorejs/contracts/Semaphore.sol#L83&#34;&gt;第 83 行代码&lt;/a&gt;[2]，请仔细看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;semaphore_bug_full.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该函数需要调用者构造一个零知识证明，证明自己可从合约中提走钱。为了防止「双花」发生，该函数还读取「废弃列表」，检查该证明的一个指定元素是否被标记过。如果该证明在废弃列表中，则合约判定校验不通过，调用者无法提走钱。开发者认为，这样一来相同的证明就无法被重复提交获利，认为此举可以有效防范双花或重放攻击。&lt;/p&gt;

&lt;p&gt;然而事与愿违，这里忽视了一个致命问题。攻击者可根据已成功提交的证明，利用「输入假名」漏洞，对原输入稍加修改便能迅速「伪造证明」，顺利通过合约第 82 行的零知识证明校验，并绕过第 83 行的防双花检查。&lt;/p&gt;

&lt;p&gt;该问题最早可追溯到 2017 年，由 Christian Reitwiessner 大神，也就是 Solidity 语言的发明者，提供的 zkSNARKs 合约密码学&lt;a href=&#34;https://gist.github.com/chriseth/f9be9d9391efc5beb9704255a8e2989d&#34;&gt;实现示例&lt;/a&gt;[3]。&lt;strong&gt;其后，几乎以太坊上所有使用 zkSNARKs 技术的合约，都照用了该实现。因此都可能遭受以下流程的攻击。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;attack-flow.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;混币应用-该安全问题的重灾区&#34;&gt;混币应用：该安全问题的重灾区&lt;/h2&gt;

&lt;p&gt;零知识证明技术在以太坊上最早和最广泛的应用场景是混币合约，或匿名转账、隐私交易。由于以太坊本身不支持匿名交易，而社区对于隐私保护的呼声越来越强烈，因此涌现出不少热门项目。这里以混币合约的应用场景为例，介绍「输入假名」漏洞对零知项目的安全威胁。&lt;/p&gt;

&lt;p&gt;混币合约或匿名转账涉及两个要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;证明自己有一笔钱&lt;/li&gt;
&lt;li&gt;证明这笔钱没有花过&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了方便理解，这里简单描述一下流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A 要花一笔钱。&lt;/li&gt;
&lt;li&gt;A 要证明自己拥有这笔钱。A 出示一个 zkproof，证明自己知道一个 hash (HashA) 的 preimage，且这个 hash 在以 root 为标志的 tree 的叶子上，且证明这个 preimage 的另一种 hash 是 HashB。其中 HashA 是 witness，HashB 是 public statement。由于 A 无需暴露 HashA，所以是匿名的。&lt;/li&gt;
&lt;li&gt;合约校验 zkproof，并检查 HashB 是否在废弃列表中。若不在，则意味着这笔钱未花过，可以花（允许 A 的此次调用）。&lt;/li&gt;
&lt;li&gt;如果可以花，合约需要把 HashB 放入废弃列表中，标明以 HashB 为代表的钱已经被花过，不能再次花了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面代码中的第 82 行 &lt;code&gt;verifyProof(a, b, c, input)&lt;/code&gt; 用来证明这笔钱的合法性，&lt;code&gt;input[]&lt;/code&gt; 是 public statement，即公共参数。第 83 行通过 &lt;code&gt;require(nullifiers_set[input[1]] == false)&lt;/code&gt; 校验这笔钱是否被花过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;很多 zkSNARKs 合约尤其是混币合约，核心逻辑都与第 82 行和 83 行类似，因此都存在同样的安全问题，可利用「输入假名」漏洞进行攻击。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;漏洞解析-一笔钱如何匿名地重复花-5-次&#34;&gt;漏洞解析：一笔钱如何匿名地重复花 5 次？&lt;/h2&gt;

&lt;p&gt;上面 &lt;code&gt;verifyProof(a, b, c, input)&lt;/code&gt; 函数的作用是根据传入的数值在椭圆曲线上进行计算校验，核心用到了名为 &lt;code&gt;scalar_mul()&lt;/code&gt; 的函数，&lt;a href=&#34;https://github.com/iden3/snarkjs/blob/0349d90824bd25688e3013ca26f7f73b51bc7755/templates/verifier_groth.sol#L202&#34;&gt;实现了椭圆曲线上的标量乘法&lt;/a&gt;[4]。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;/// @return the product of a point on G1 and a scalar, i.e.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/// p == p.scalar_mul(1) and p.add(p) == p.scalar_mul(2) for all points p.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;scalar_mul&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;G1Point&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;internal&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;G1Point&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;memory&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;assembly&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sub&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x80&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// Use &amp;#34;invalid&amp;#34; to make gas estimation work
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;invalid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们知道以太坊内置了多个预编译合约，进行椭圆曲线上的密码学运算，降低 zkSNARKs 验证在链上的 Gas 消耗。函数 &lt;code&gt;scalar_mul()&lt;/code&gt; 的实现则调用了以太坊预编译 7 号合约，根据 &lt;a href=&#34;https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md&#34;&gt;EIP 196&lt;/a&gt; 实现了椭圆曲线 alt_bn128 上的标量乘法[5]。下图为黄皮书中对该操作的定义，我们常称之为 ECMUL 或 ecc_mul。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./yellow_paper_ecmul.png&#34; alt=&#34;以太坊黄皮书定义&#34; /&gt;&lt;/p&gt;

&lt;p&gt;密码学中，椭圆曲线的 &lt;code&gt;{x,y}&lt;/code&gt; 的值域是一个基于 mod p 的有限域，这个有限域称之为 Zp 或 Fp。也就是说，一个椭圆曲线上的一个点 &lt;code&gt;{x,y}&lt;/code&gt; 中的 x,y 是 Fp 中的值。一条椭圆曲线上的某些点构成一个较大的循环群，这些点的个数称之为群的阶，记为&lt;code&gt;q&lt;/code&gt;。基于椭圆曲线的加密就在这个循环群中进行。如果这个循环群的阶数（&lt;code&gt;q&lt;/code&gt;）为质数，那么加密就可以在 mod q 的有限域中进行，该有限域记作 &lt;code&gt;Fq&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一般选取较大的循环群作为加密计算的基础。在循环群中，任意选定一个非无穷远点作为生成元 &lt;code&gt;G&lt;/code&gt;（通常这个群的阶&lt;code&gt;q&lt;/code&gt;是个大质数，那么任选一个非零点都是等价的），其他所有的点都可以通过 &lt;code&gt;G+G+....&lt;/code&gt; 产生出来。这个群里的元素个数为 &lt;code&gt;q&lt;/code&gt;，也即一共有 &lt;code&gt;q&lt;/code&gt; 个点，那么我们可以用 &lt;code&gt;0,1,2,3,....q-1&lt;/code&gt; 来编号每一个点。在这里第 0 个点是无穷远点，点&lt;code&gt;1&lt;/code&gt; 就是刚才提到的那个 &lt;code&gt;G&lt;/code&gt;，也叫做基点。点&lt;code&gt;2&lt;/code&gt; 就是 &lt;code&gt;G+G&lt;/code&gt;，点&lt;code&gt;3&lt;/code&gt; 就是 &lt;code&gt;G+G+G&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;于是当要表示一个点的时候，我们有两种方式。第一种是给出这个点的坐标 &lt;code&gt;{x,y}&lt;/code&gt;，这里 &lt;code&gt;x,y&lt;/code&gt; 属于&lt;code&gt;Fp&lt;/code&gt;。第二种方式是用 &lt;code&gt;n*G&lt;/code&gt; 的方式给出，由于 G 是公开的，于是只要给出 n 就行了。n 属于 &lt;code&gt;Fq&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;看一下 &lt;code&gt;scalar_mul(G1Point point, uint s)&lt;/code&gt; 函数签名，以 point 为生成元，计算 &lt;code&gt;point+point+.....+point&lt;/code&gt;，一共 n 个 point 相加。这属于使用上面第二种方法表示循环群中的一个点。&lt;/p&gt;

&lt;p&gt;在 Solidity 智能合约实现中需要使用 uint256 类型来编码 &lt;code&gt;Fq&lt;/code&gt;，但 uint256 类型的最大值是大于&lt;code&gt;q&lt;/code&gt; 值，那么 会出现这样一种情况：在 uint256 中有&lt;strong&gt;多个数&lt;/strong&gt; 经过 mod 运算之后都会对应到同一个 &lt;code&gt;Fq&lt;/code&gt;中的值。比如 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;s + q&lt;/code&gt; 表示的其实是同一个点，即第&lt;code&gt;s&lt;/code&gt;个点。这是因为在循环群中点&lt;code&gt;q&lt;/code&gt; 其实等价于 点&lt;code&gt;0&lt;/code&gt;（每个点分别对应 &lt;code&gt;0,1,2,3,....q-1&lt;/code&gt;）。同理，&lt;code&gt;s + 2q&lt;/code&gt; 等均对应到点&lt;code&gt;s&lt;/code&gt; 。&lt;strong&gt;我们把可以输入多个大整数会对应到同一个 &lt;code&gt;Fq&lt;/code&gt;中的值 这一现象称作「输入假名」，即这些数互为假名。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以太坊 7 号合约实现的椭圆曲线是 &lt;code&gt;y^2 = ax^3+bx+c&lt;/code&gt;。p 和 q 分别如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;yellow_paper_curve.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里的 &lt;code&gt;q&lt;/code&gt; 值即上文中提到的群的阶数。那么在 uint256 类型范围内，共有 &lt;code&gt;uint256_max / q&lt;/code&gt; 个，算下来也就是最多会有 5 个整数代表同一个点（ 5 个「输入假名」）。&lt;/p&gt;

&lt;p&gt;这意味着什么呢？让我们回顾上面调用 &lt;code&gt;scalar_mul(G1Point point, uint s)&lt;/code&gt; 的 &lt;code&gt;verifyProof(a, b, c, input)&lt;/code&gt; 函数，&lt;code&gt;input[]&lt;/code&gt; 数组里的每个元素实际就是 &lt;code&gt;s&lt;/code&gt;。对于每个 &lt;code&gt;s&lt;/code&gt;，在 uint256 数据类型范围内，会最多存在其他 4 个值，传入后计算结果与原值一致。&lt;/p&gt;

&lt;p&gt;因此，当用户向合约出示零知识证明进行提现后，合约会把 &lt;code&gt;input[1]&lt;/code&gt; （也就是某个 &lt;code&gt;s&lt;/code&gt;）放入作废列表。用户（或其他攻击者）还可以使用另外 4 个值再次进行证明提交。&lt;strong&gt;而这 4 个值之前并没有被列入「废弃列表」，因此“伪造”的证明可以顺利通过校验，利用 5 个「输入假名」一笔钱可以被重复花 5 次，而且攻击成本非常低！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;还有更多受影响的项目&#34;&gt;还有更多受影响的项目&lt;/h2&gt;

&lt;p&gt;存在问题的远远不止 semaphore 一个。其他很多以太坊混币项目以及 zkSNARKs 项目都存在同样的允许「输入假名」的问题。&lt;/p&gt;

&lt;p&gt;这当中，影响最大的要数几个大名鼎鼎的 zkSNARKs 库或框架项目，包括 snarkjs、ethsnarks、ZoKrates 等。许多应用项目会直接引用或参考他们的代码进行开发，从而埋下安全隐患。因此，上述三个项目迅速进行了安全修复更新。另外，多个利用了 zkSNARKs 技术的知名混币项目，如 hopper、Heiswap、Miximus 也立刻进行了同步修复。&lt;strong&gt;这些项目在社区热度都十分高，其中 Heiswap 更是被人们称为 「Vitalik 最喜爱的项目」。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;输入假名-漏洞的解决方案&#34;&gt;「输入假名」漏洞的解决方案&lt;/h2&gt;

&lt;p&gt;事实上，所有使用了该 zkSNARKs 密码学合约库的项目都应该立即开展自查，评估是否受影响。那么应该如何修复这个问题？&lt;/p&gt;

&lt;p&gt;所幸的是，修复很简单。仅需在验证函数中添加对输入参数大小的校验，强制要求 input 值小于上面提到的 q 值。即严禁「输入假名」，杜绝使用多个数表示同一个点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;scalar_fix.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;暴露的深层问题值得反思&#34;&gt;暴露的深层问题值得反思&lt;/h2&gt;

&lt;p&gt;该「输入假名」导致的安全漏洞值得社区认真反思。我们再回顾一下整个故事。2017 年 Christian 在 Gist 网站贴出了自己的 zkSNARKs 合约计算实现。作为计算库，我们可以认为他的实现并没有安全问题，没有违反任何密码学常识，完美地完成了在合约中进行证明验证的工作。事实上，作为 Solidity 语言的发明者，Christian 在这里当然不会犯任何低级错误。而两年后的今天，这段代码却引发了如此的安全风波。两年多的时间内，可能有无数同行和专家看过或使用过这段只有两百多行的代码，却没有发现任何问题。&lt;/p&gt;

&lt;p&gt;核心问题出在哪里？可能出在底层库的实现者和库的使用者双方间对于程序接口的理解出现了偏差。换句话说：底层库的实现者对于应用开发者的不当使用方式欠缺考虑；而上层应用开发者没有在使用中没有深入理解底层实现原理和注意事项，进行了错误的安全假设。&lt;/p&gt;

&lt;p&gt;所幸的是，目前常见的 zkSNARKs 合约库都火速进行了更新，从底层库层面杜绝「输入假名」。&lt;strong&gt;安比（SECBIT）实验室认为，底层库的更新诚然能够很大程度上消除掉后续使用者的安全隐患，但若该问题的严重性没有得到广泛地宣传和传播，依旧会有开发者不幸使用到错误版本的代码，或者是根据错误的教程进行开发（就像因为整数溢出而归零的那些 Token 一样），从而埋下安全隐患。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;「输入假名」漏洞不禁让我们回想起此前频繁曝出的「整数溢出」漏洞。二者相似之处颇多：都是源于大量开发者的错误假设；都与 Solidity 里的 uint256 类型有关；波及面都十分广；网络上也都流传着很多存在隐患的教程代码或者库合约。但显然「输入假名」漏洞显然更难检测，潜伏时间更长，需要的背景知识更多（涉及到复杂的椭圆曲线和密码学理论）。安比（SECBIT）实验室认为，随着 zkSNARKs、零知识证明应用、隐私技术的兴起，社区会涌现出更多的新应用，而背后暗藏的更多安全威胁可能会进一步暴露出来。希望这波新技术浪潮中，社区能充分吸收以往的惨痛教训，重视安全问题。&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://github.com/kobigurk/semaphore/issues/16&#34;&gt;https://github.com/kobigurk/semaphore/issues/16&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://github.com/kobigurk/semaphore/blob/602dd57abb43e48f490e92d7091695d717a63915/semaphorejs/contracts/Semaphore.sol#L83&#34;&gt;https://github.com/kobigurk/semaphore/blob/602dd57abb43e48f490e92d7091695d717a63915/semaphorejs/contracts/Semaphore.sol#L83&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://gist.github.com/chriseth/f9be9d9391efc5beb9704255a8e2989d&#34;&gt;https://gist.github.com/chriseth/f9be9d9391efc5beb9704255a8e2989d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] &lt;a href=&#34;https://github.com/iden3/snarkjs/blob/0349d90824bd25688e3013ca26f7f73b51bc7755/templates/verifier_groth.sol#L202&#34;&gt;https://github.com/iden3/snarkjs/blob/0349d90824bd25688e3013ca26f7f73b51bc7755/templates/verifier_groth.sol#L202&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[5] &lt;a href=&#34;https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md&#34;&gt;https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>PoD-Tiny——实现零信任交易的最简协议</title>
      <link>https://sec-bit.github.io/blog/2019/07/24/zkpod-explained-pod-tiny/</link>
      <pubDate>Wed, 24 Jul 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/07/24/zkpod-explained-pod-tiny/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;zkPoD 原理解读系列（一）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文面向有一定密码学基础，或者对密码学感兴趣的读者。文中虽然有大量数学公式出现，但是都比较简单易于理解。&lt;/p&gt;

&lt;h2 id=&#34;导言-zkpod-是什么&#34;&gt;导言：zkPoD 是什么？&lt;/h2&gt;

&lt;p&gt;zkPoD 实现了去中心化的「零知识有条件支付」，支持上 GB 数据的零信任公平交易。关于「零知识有条件支付」的概念请看这篇概述文章 &lt;a href=&#34;此处请换成公号文章链接&#34;&gt;『zkPoD：区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易』&lt;/a&gt;。zkPoD 是一个全新的实现 ZKCP 目标的方案。目前 zkPoD 已经支持上 GB 的数据，支持低 TPS 公链，也支持高 TPS 联盟链；既支持二进制数据，也支持带有内部丰富类型与结构的表格数据。与传统的「受信第三方」相比，zkPoD 利用区块链来作为一个「Trustless 第三方」，实现了的「零信任公平交易」。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;zkPoD 也是一个实现数据与价值双向流通的底层基础协议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;zkPoD 开源代码与更多文档请见：&lt;a href=&#34;https://github.com/sec-bit/zkPoD-node&#34;&gt;https://github.com/sec-bit/zkPoD-node&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;proof-of-delivery-pod-协议&#34;&gt;Proof-of Delivery (PoD) 协议&lt;/h4&gt;

&lt;p&gt;PoD 是实现 zkPoD系统的核心协议。PoD 协议实现了借用区块链智能合约来进行「数据」和 「Token」的原子交换，并且保证买卖双方的公平性。PoD 并没有像 ZKCP[1] 那样采用单一的 zkSNARK 方案来实现原子交换，而是利用了 Pedersen Commitment，Schnorr Protocol 等密码学经典方案来实现。这样 PoD 可以做得更高效，同时易扩展。同时 PoD 协议的目标做到「可证安全」、「可证公平」。利用形式化的证明来构建坚实的「信任根基」。&lt;/p&gt;

&lt;p&gt;本文介绍一个极简的 PoD 协议——PoD-Tiny，这个协议简化了很多问题，并不实用，但是可以帮助读者快速理解 PoD 的原理和面临的挑战。&lt;/p&gt;

&lt;p&gt;假设我是卖家，而你需要从我手里买一个数据文件，这个协议的一个大致流程是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;步骤一：我把「数据」&lt;strong&gt;加密&lt;/strong&gt;后，传给你&lt;/li&gt;
&lt;li&gt;步骤二：你把「Token」交给区块链「智能合约」&lt;/li&gt;
&lt;li&gt;步骤三：我用「密钥」&lt;strong&gt;交换&lt;/strong&gt;「智能合约」手里的「Token」，然后你紧接着可以从智能合约中读取「密钥」进行「数据」&lt;strong&gt;解密&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是不是很简单？聪明的你此刻正在高度怀疑这个过程是不是哪有问题。&lt;/p&gt;

&lt;h4 id=&#34;公平交易-中的关键问题&#34;&gt;「公平交易」中的关键问题&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关键问题(1)&lt;/strong&gt;：你收到的加密数据确实是你想要的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键问题(2)&lt;/strong&gt;：你收到加密数据之后，不付钱就跑路怎么办&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键问题(3)&lt;/strong&gt;：而我出示给智能合约的密钥必须是真密钥，否则拿不到 Token&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键问题(4)&lt;/strong&gt;：我出示真密钥之后，必须要能拿到 Token&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们接下来就抽丝剥茧，讨论下上面这几个关键问题，帮忙大家理解 &lt;strong&gt;PoD-Tiny 是怎么巧妙解决这些问题的&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;锁定数据的特征-authenticator&#34;&gt;锁定数据的特征：Authenticator&lt;/h2&gt;

&lt;p&gt;对于&lt;strong&gt;关键问题(1)&lt;/strong&gt;，我们需要一个锚点，什么是你想要的数据。这里简单起见，假设我们事先约定了一个数据文件的唯一标签，或者特征。然后你购买的数据需要能和这个标签一一对应。&lt;/p&gt;

&lt;p&gt;一般来说，大家喜欢用 Hash 来标记对一个字符串的特征，比如计算&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;h = MD5(&amp;#34;hello,zkPoD!&amp;#34;)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们看下这个字符串  &lt;code&gt;&amp;quot;hello,zkPoD!&amp;quot;&lt;/code&gt; 总共有 12 个字节大小，也就是 96 个 bit。于是我们可以将这 12 个字节转换成一个有限域上的整数（这里我们假设有限域的大小接近 256 bit ）。这样我们可以把这个字符串编码成一个整数，我们姑且用一个符号表示这个整数， 假设是 $m$。&lt;/p&gt;

&lt;p&gt;我们通过下面的运算产生这个数据的「承诺」。&lt;/p&gt;

&lt;p&gt;$\sigma = g^{m}$&lt;/p&gt;

&lt;p&gt;承诺也叫 Commitment，它可以做到和数据的一一对应，同时并且能够隐藏数据的值。
这里的 $\sigma$ 在 zkPoD 系统中被称为「认证信息」 Authenticator（而这里的$g$ 是一个循环群$\mathbb{G}$的生成元，或者从实现角度讲，$g$ 是椭圆曲线群上的基点）。&lt;/p&gt;

&lt;p&gt;「认证信息」Authenticator 可以向所有人公开，我们不用担心会泄露原始数据信息。这是因为，通过 $\sigma$ 是难以反算出来 $m$，这个逆运算是一个有限域的「求对数」的运算。假如有限域比较大的话，这个对数运算是非常非常困难的。这就是常说的「离散对数难题」假设，即 Discrete Log Problem。抛开这些理论细节，我们只要知道，Authenticator 就可以放心交给任何人，而不用担心$m$ 被逆向破解。&lt;/p&gt;

&lt;p&gt;「认证信息」为什么采用这种群指数形式，而不是采用大家所熟悉的 Hash 运算。这是因为「认证信息」具有&lt;strong&gt;加法运算同态性&lt;/strong&gt;。所谓同态性质，大家可以这么理解：明文数据具有的某种运算，可以映射到密文的运算中。假设有三个数据明文，m1， m2 还有 m3，其中  m1 = m2 + m3。&lt;/p&gt;

&lt;p&gt;他们的 Authenticator 分别计算如下：&lt;/p&gt;

&lt;p&gt;$\sigma_1=g^{m_1}$, $\sigma_2=g^{m_2}$,   $\sigma_3 = g^{m_3}$,&lt;/p&gt;

&lt;p&gt;我们可以计算&lt;/p&gt;

&lt;p&gt;$\sigma_1 \overset{?}{=} \sigma_2 \cdot \sigma_3$&lt;/p&gt;

&lt;p&gt;来验证 $ m_1 \overset{?}{=} m_2 + m_3 $。大家可以发现，虽然一个吃瓜群众知道了 $\sigma_3$，他也不能反算出$m_3$。但是他知道 $m_3$ 等于另外两个数的和，虽然他完全不知道这个三个数具体是多少。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：这里的加法是模加，$a + b$ 是 $a + b \mod p$。简化起见，后续的加减乘除一律约定是有限域上的运算。&lt;/p&gt;

&lt;p&gt;剩下的事情就简单了，在协议步骤一，我可以选一个随机数 $k$ 作为密钥，计算 $\overline{m}=k + m$
$\overline{m}$ 就是加密数据。我可以把 $K= g^k$ 也发给你，这样你手里有三样东西， $\sigma$，$K$，还有$\overline{m}$。你就可以用下面的公式来「同态地」校验加了密的$\overline{m}$ 确实是数据$m$的密文：&lt;/p&gt;

&lt;p&gt;$g^{\overline{m}} \overset{?}{=} K\cdot \sigma$&lt;/p&gt;

&lt;p&gt;并且，通过上面的公式，你还能知道一个关键信息：密钥是一个关联到 $K$ 的数值。尽管这时候你完全不知道 $m$ 和 密钥 $k$。这个信息也是解决&lt;strong&gt;关键问题(3)&lt;/strong&gt;的关键所在。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通过同态性，买家可以在数据加密的情况验证数据是否满足一些条件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回忆一下关键问题(2)：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关键问题(2)&lt;/strong&gt;：你收到加密数据之后，不付钱就跑路怎么办&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决这个问题是核心方法是「零知识证明」。如果买家拿到加密数据之后，从中分析不出来任何多余的信息，那么就不会损害卖家利益，也就能解决关键问题(2)。简单讲，如果加密数据是零知识的，就不怕买家拿了加密数据不给钱就跑路。所谓的「零知识」，大家可以这么通俗理解：买家拿到的加密数据后，就像拿到一堆随机数一样，没有任何信息量。怎么做到零知识呢？PoD-Tiny 使用了一个经典的 Schnorr 协议。&lt;/p&gt;

&lt;h2 id=&#34;插播科普-schnorr-协议-与-零知识&#34;&gt;插播科普：Schnorr 协议 与 「零知识」&lt;/h2&gt;

&lt;p&gt;Schnorr 协议是非常经典的教课书例子，我这里快速带大家过一遍这个协议。Schnorr 协议的用途之一是用来做身份认证，它是一个两方安全协议，一方证明者「Alice」 ，向另一方「验证者」Bob证明她拥有一个公钥对应的私钥。&lt;/p&gt;

&lt;p&gt;首先 Alice 产生一对「公私钥」，$(pk, sk)$。然后 Bob 持有 Alice 的公钥 $pk$。当 Alice 要向 Bob 证明身份时，他们会通过一个「三步交互协议」来完成证明：证明 Alice 拥有私钥 $sk$。如果 Bob 接受了这个证明，那么 Bob 会认为 对面证明她有私钥的人就是 Alice。下面简单描述下这个协议：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;schnorr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;$sk = \alpha,  pk=g^\alpha$&lt;/p&gt;

&lt;p&gt;公开输入：$pk=g^\alpha$&lt;/p&gt;

&lt;p&gt;Alice私有输入：$sk = \alpha$&lt;/p&gt;

&lt;p&gt;第一步：Alice 选择一个随机数 $r$，并且发送 $r$ 的「承诺」$R = g^r$ 给 Bob&lt;/p&gt;

&lt;p&gt;第二步：Bob 发回一个随机数 $c$，作为挑战数&lt;/p&gt;

&lt;p&gt;第三步：Alice 计算 $z=r+c\cdot \alpha$，然后将 $z$ 发送给 Bob，然后 Bob 通过如下的公式来验证：&lt;/p&gt;

&lt;p&gt;验证公式：$g^z \overset{?}{=} R \cdot pk^c = g^r\cdot g^{c\cdot \alpha}$&lt;/p&gt;

&lt;p&gt;这个 Schnorr 协议具有三个性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Completeness&lt;/li&gt;
&lt;li&gt;Special Soundness&lt;/li&gt;
&lt;li&gt;Special Honest Verifier Zero-Knowledge&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中第三个性质就是「零知识」，这个性质保证了：在这个协议交互过程中，Bob 无论如何都不会得到关于私钥的任何信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;:严格地讲， Schnorr 协议并不是「Full-ZK」，只能保证「HVZK」，这是一个相对弱一些的零知识性质。不过大家暂时不用纠结这一点，Schnorr 协议可以通过一些技巧升级为「Full-ZK」。&lt;/p&gt;

&lt;h2 id=&#34;pod-tiny-一个简单的-pod-协议&#34;&gt;PoD-Tiny：一个简单的 PoD 协议&lt;/h2&gt;

&lt;p&gt;如果大家已经大概记住了 Schnorr 协议的细节，那么我来展示一个协议叫做 PoD-Tiny。&lt;/p&gt;

&lt;p&gt;PoD-Tiny 是一个非常简化的 PoD 协议，虽然不实用，但帮助大家理解 PoD 协议的工作原理。&lt;/p&gt;

&lt;p&gt;协议描述：假设 Alice 拥有一个数据明文 $m$，然后 Bob 拥有这个数据的 Authenticator（$\sigma_m$），这里还有一个 「Trustless 第三方」，我们暂且叫她 Julia。请大家记住：她是一个智能合约。&lt;/p&gt;

&lt;h3 id=&#34;协议&#34;&gt;协议：&lt;/h3&gt;

&lt;p&gt;开场前的道具：$m$, $\sigma_m$, $g$, 一个随机数产生器  $Rand(\cdot)$&lt;/p&gt;

&lt;p&gt;角色：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Alice：拥有 ECC参数 $g$，数据 $m$，一次性密钥 $k=Rand()$&lt;/li&gt;
&lt;li&gt;Bob：拥有 ECC参数 $g$，$\sigma_m$&lt;/li&gt;
&lt;li&gt;Julia: 拥有 ECC参数 $g$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;pod-tiny-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：Alice 产生一个随机数，$r \overset{\$}\leftarrow Rand()​$ ，然后发给 Bob 两个数 $K=g^k​$ 和 $R=g^r$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：Bob 产生一个随机数 $c\overset{\$}\leftarrow Rand()$，发送给 Alice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：Alice 计算两个数字 $\overline{m}=k + m​$，$z=r+c\cdot k​$，并且发送给 Bob。这两个数，第一个 $\overline{m}​$ 是用一次性密钥 $k​$ 加密后的密文，而 $z​$ 是「对密钥加密」生成的密文。&lt;/p&gt;

&lt;p&gt;注：什么？对密钥加密？没错，这里 Alice 用第一步生成的随机数 $r$，加上第二步 Bob 提供的挑战数对 $k$ 做了加密，得到了 $z$。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：Bob 对收到的数据密文 $\overline{m}$ 进行验证（公式(1) ），并且对密钥的密文进行验证（公式(2) ）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;验证公式(1)：$g^{\overline{m}} \overset{?}{=} \sigma_m \cdot K$&lt;/li&gt;
&lt;li&gt;验证公式(2)：$g^{z} \overset{?}{=} R  \cdot K^c$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：在第四步中，Bob 需要搞明白两件事情：首先传给他的密文数据（$\overline{m}$）是不是能对应到之前数据的锚点（$\sigma_m$）；然后密文数据（$\overline{m}$）是不是由某一个未知密钥 $X$ 加密的，并且这个「未知密钥」的密文&lt;strong&gt;应该等于&lt;/strong&gt;第三步中 Alice 发过来的「密钥密文」（$z$）。倘若如此，在未来的某个时刻，若 Bob 得到「密钥密文的密钥」（$r$） 之后，就可以做两次解密动作来成功拿到数据明文（$m$）。两次解密动作为：首先 Bob 用「密钥密文的密钥」$r$ 还有挑战数 $c$ 解密 密钥密文 $z$，得到数据密钥 $k$，然后再用数据密钥来解密 数据密文$\overline{m}$，从而得到数据明文 $m$。&lt;/p&gt;

&lt;p&gt;再注：上面的协议第一步到第四步，其实大家可以发现和 Schnorr 协议非常类似。只不过把 $\alpha$ 替换成了一个一次性密钥 $k$。然后另一个不同点是，$K = g^k$ 相当于原 Schnorr 协议中的公钥，并不是一开始发给了Bob，而是在协议的第一步和$R$ 一起发送给 Bob。不管如何，从整体上，这四步协议正是一个 Schnorr 协议的扩展。当然到这里还没完，接下来区块链要登场了，Bob，Alice 要和 Julia开始进行交互。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第五步&lt;/strong&gt;：如果 Bob 在第四步中验证公式(1)和公式(2)通过，那么说明 Alice 发的数据都是正确的。这时候 Bob 要发给 Julia 一个「数据交付收据」(Delivery-Receipt)。&lt;/p&gt;

&lt;p&gt;注：这个收据是为了告诉 Julia，Bob他已经收到了加过密的数据了，但是密钥还没收到。密钥需要 Julia 帮他接收并验证。那么验证的凭据是什么呢？正是「密钥密文的密钥」对应的「承诺」，是不是有点绕，这个收据就是协议第一步 Alice 发给 Bob 的 $R$。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第六步&lt;/strong&gt;：Alice 向 Julia 出示「密钥密文的密钥」，也就是 $r$。Julia 检查下面这个关键公式。如果验证通过，Julia 可以将 Bob 账户上的 Token 转给 Alice。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;验证公式(3)：$R\overset{?}{=} g^r$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们看看关键问题(3)是如何解决的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关键问题(3)&lt;/strong&gt;：Alice 出示给智能合约的密钥必须是真密钥，否则拿不到 Token&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在协议的第一步，Alice 给 Bob 发送了一个「密钥的密钥」的「承诺」$R$；然后在协议的第五步，Bob 把 $R$ 转交给了 Julia；第六步，Alice 兑现承诺，揭示对应的 $r$。如果 Alice 出示一个错误的值，Julia 立即就会发现公示(3)不成立。&lt;/p&gt;

&lt;p&gt;还有一个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关键问题(4)&lt;/strong&gt;：Alice 出示真密钥之后，必须要能拿到 Token&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在协议的第六步，Julia 要检验公式(3)。在 Alice 出示正确的 $r$ 的情况下，如果等式不成立，那么只有两种情况：（1）Julia 故意捣乱， （2）$R$ 的值不正确。对于前一种情况，需要保证 Julia 的合约代码确实没有漏洞，功能正常，这个需要额外采用「形式化验证」的方法来解决。对于后一种情况，这里需要 Alice 在第六步先检查一下，在第五步中 Bob 提交的 $R$ 是不是一个正确的值。这里请注意：Julia 是一个公开的智能合约，她拿到的任何数据都是公开可见的，她的任何内部状态与计算过程都是公开可见的。&lt;/p&gt;

&lt;h3 id=&#34;协议的安全性与公平性分析&#34;&gt;协议的安全性与公平性分析&lt;/h3&gt;

&lt;p&gt;如果我们不考虑多次交易，PoD-Tiny 是一个「公平」的交易协议。我们接下来依次分析下为何这个协议是公平的。&lt;/p&gt;

&lt;p&gt;我们首先考虑 Alice 有哪些作弊手段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将假的数据 $m&amp;rsquo;$ 加密后传给 Bob&lt;/li&gt;
&lt;li&gt;加密数据时用的密钥 $k$，但是在加密密钥的时候却用的是 $k&amp;rsquo;$，并且 $k\not= k&amp;rsquo;$&lt;/li&gt;
&lt;li&gt;向 Julia 出示一个假的密文密钥 $r&amp;rsquo;$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里如果 Alice 采用作弊手法 A1，那么 Bob 在校验公式(1)时能够发现；如果 Alice 采用作弊手法 A2，那么 Bob可以通过计算公式(2)发现；如果 Alice 采用作弊手法 A3，那么 Julia 通过公式(3)就能发现。&lt;/p&gt;

&lt;p&gt;我们再考虑 Bob 都有哪些作弊手段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bob 在拿到加密数据 $\overline{m}$ 之后，就退出协议，然后尝试破解密文&lt;/li&gt;
&lt;li&gt;Bob 在验证加密数据之后，向 Julia 出示一个错误的「交付收据」&lt;/li&gt;
&lt;li&gt;Bob 账户没有足够的 Token&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分析：如果 Bob 采用作弊手段 B1，那么 Bob 是无法从加密数据中得到任何信息的，因为协议的前三步是「零知识的」（准确地说：Honest Verifier Zero-Knowledge）。如果 Bob 采用手段 B2，Alice 可以在第六步检查下 Julia 手里的「数据交付收据」$R$ 是不是和她在第一步发给 Bob 的相同，一旦 Bob 提交错误的收据，Alice 可以直接退出协议，拒绝出示密钥。同样，如果 Bob 采用手段 B3，Alice 可以在第六步的时候检查 Bob保存在 Julia 处的 Token 是否足够，如果不足则直接退出协议。&lt;/p&gt;

&lt;p&gt;最后，Julia 有没有可能作弊呢？Julia 是智能合约，她的任何行为和内部状态都能被任何人读取，那么通过 Julia 是有可能产生信息泄露的，从而对 Alice 或者 Bob 不利。但是请大家注意下，Julia 其实并不接触任何和数据明文 $m$ 相关的信息，也就从链上不会泄露 $m$ 的信息。Julia 接触到的信息只有两个，$R$ 和 $r$。&lt;/p&gt;

&lt;h2 id=&#34;压缩到最简协议&#34;&gt;压缩到最简协议&lt;/h2&gt;

&lt;p&gt;我们数一数上面的协议的交互步骤总共有五步，分别是 Alice 与 Bob交互三次，Bob 与 Julia 交互一次，Alice 与 Julia 交互一次。安全协议里面有一个叫做 Fiat-Shamir Heuristic 变换，它可以将
PoD-Tiny 协议中的前三步，直接「压缩」成为一步。&lt;/p&gt;

&lt;h4 id=&#34;压缩前&#34;&gt;压缩前：&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Step&lt;/th&gt;
&lt;th&gt;Interaction&lt;/th&gt;
&lt;th&gt;Info&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一步&lt;/td&gt;
&lt;td&gt;Alice  =&amp;gt;  Bob&lt;/td&gt;
&lt;td&gt;$(K, R)$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;第二步&lt;/td&gt;
&lt;td&gt;Bob =&amp;gt; Alice&lt;/td&gt;
&lt;td&gt;$c$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;第三步&lt;/td&gt;
&lt;td&gt;Alice =&amp;gt; Bob&lt;/td&gt;
&lt;td&gt;$(\overline{m}, z)$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;第四步&lt;/td&gt;
&lt;td&gt;Bob =&amp;gt; Julia&lt;/td&gt;
&lt;td&gt;$R$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;第五步&lt;/td&gt;
&lt;td&gt;Alice =&amp;gt; Julia&lt;/td&gt;
&lt;td&gt;$r$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;压缩后&#34;&gt;压缩后：&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Step&lt;/th&gt;
&lt;th&gt;Interaction&lt;/th&gt;
&lt;th&gt;Info&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一步&lt;/td&gt;
&lt;td&gt;Alice  =&amp;gt;  Bob&lt;/td&gt;
&lt;td&gt;$(K, R, c, \overline{m}, z)$，这里 $c=Hash(\sigma_m || K || R)$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;第二步&lt;/td&gt;
&lt;td&gt;Bob =&amp;gt; Julia&lt;/td&gt;
&lt;td&gt;$R$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;第三步&lt;/td&gt;
&lt;td&gt;Alice =&amp;gt; Julia&lt;/td&gt;
&lt;td&gt;$r$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们发现最主要的不同是，在压缩后的PoD-Tiny 中挑战数不再由 Bob 产生，而是由 Alice 产生。这里大家可能会产生疑问，这样做会不会对 Bob 不公平？这相当于 三步的 Schnorr 协议直接压缩成一步就完成了。这里先下个结论：压缩后的协议保持零知识的性质，仍然对双方公平。原因是，压缩前的协议可以证明 HVZK(Honest Verifier Zero-Knowledge)；压缩后的协议可以证明出 NIZK (Non-Interactive Zero-Knowledge)。但是安全性在压缩前后的对比会比较 Subtle，这里不再展开。&lt;/p&gt;

&lt;p&gt;经过压缩，最后这个协议变得不可思议地简洁：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;pod-tiny.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;迈向实用性的挑战-安全与性能&#34;&gt;迈向实用性的挑战：安全与性能&lt;/h2&gt;

&lt;p&gt;最简协议 PoD-Tiny 只是万里长征的第一步，当面对纷繁冗杂的现实世界，要将理论变成代码时，会面临许许多多的问题。这些问题会相互纠缠在一起，反过来又会影响着协议在理论层面的设计。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何支持长度超过 1MB 的数据，甚至上 GB&lt;/li&gt;
&lt;li&gt;如何有效降低链上验证计算的开销&lt;/li&gt;
&lt;li&gt;如何支持以太坊，并免疫以太坊上的各式安全问题&lt;/li&gt;
&lt;li&gt;如何支持数据的复杂同态计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;zkPoD 在工程阶段做了不少的和安全和性能相关的改进和创新。请关注我们的后续文章，说说我们的感悟和体会。&lt;/p&gt;

&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;区块链到底能做什么？我在最近一年里看到了很多相当「悲观」的论调，我想 PoD 协议应该会给这些怀疑论者带来些许启发。区块链在 PoD 协议中起到了一个第三方的关键角色，而且让这个协议变得不可思议的简洁，这是我们始料未及。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>zkPoD：区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易</title>
      <link>https://sec-bit.github.io/blog/2019/07/14/zkpod-short-intro/</link>
      <pubDate>Sun, 14 Jul 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/07/14/zkpod-short-intro/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;这篇文章解释利用ZKP(零知识证明)与区块链来实现去中介的交易协议的原理，讲讲我们是怎么把这个理论变成实用的代码的，这是一篇概述，希望了解更多的朋友请关注后续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;[注]：如果你相信未来区块链技术能改变世界，请留意看文末&lt;/p&gt;

&lt;h2 id=&#34;没有第三-能保证交易的公平性吗&#34;&gt;没有第三⽅，能保证交易的公平性吗？&lt;/h2&gt;

&lt;p&gt;想象⼀下这样⼀个交易场景，⼀个买家拎着现⾦箱⼦，另⼀个卖家也拎着⼀个箱⼦，装着某种贵重货物。在电影中的情节⾥，买卖双⽅会坐在⼀个桌⼦两侧，双⽅倒数⼀、⼆、三，⼀起把箱⼦推给对⽅（很酷的姿势），当然双⽅最好都带武器，防⽌对⽅依然耍赖。除了买家卖家，没有任何第三⽅在场（可能是⼀个⿊市交易），这两⽅互不信任。可以想象，任何⼀⽅都不敢先出⼿，把⾃⼰的箱⼦交给对⽅，因为这样接下来很可能出现的场景是，对⽅拿到箱⼦会⽴即跑路，这样就导致钱货两空的结局。&lt;/p&gt;

&lt;p&gt;在上世纪90年代，正值互联⽹早期，电⼦商务已然是⼤家普遍看好的互联⽹应⽤。但在这些早期的在线交易实验中，会出现上述的两⽅交易难题：到底是卖家先发货，还是买家先付款？ 当然，卖家收到钱款后拒绝交付商品；或买家收货之后拒绝付款的现象，难以避免。于是如何实现买卖双⽅在线上进行「公平交易」，即实现可靠的 「⼀⼿交钱，⼀⼿交货」 成了⼀个热门经典的学术问题。但是很不幸地是，科学家们早就证明了这样⼀个结论[1-2]：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在没有可信第三⽅的前提下，⽆法实现买卖两⽅的公平交易&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓「公平交易」是指买卖双⽅在不相识（不互信）的情况下，能够放⼼进⾏交易⽽⽆需担⼼对⽅作弊。如果交易顺利完成，则买家得到商品，同时卖家得到钱款；若协议中途任何⼀⽅退出，或任何⼀⽅作弊，协议都会保证另⼀⽅的利益不会受损。&lt;/p&gt;

&lt;p&gt;在 Google 论⽂搜索引擎⾥⾯搜「Fair Exchange」，我们能看到多达两百多万篇学术论⽂。假如我以一天看十篇的速度估算，这一辈子都看不完。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;google.png&#34; alt=&#34;google-scholar&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在过去近 30 年的研究⾥，公平交易⽅案中都必须要求存在⼀个绝对可信、可靠的第三⽅。⽀付宝正是起到这样⼀个关键作⽤，担任⼀个⼤家都信赖的第三⽅，⼀旦买卖双⽅发⽣纠纷，⽀付宝负责介⼊事务并解决问题。 当互联⽹电⼦商务蓬勃发展到今天，这⼀类的信任第三⽅已经变成了巨⽆霸。而大家所感受不到的事实是，第三⽅所引⼊的「信任成本」正在急速攀升。毫⽆疑问，对第三⽅的过度依赖会带来严重的「隐私泄露」、「单点失效」还有「个⼈信息滥⽤」的问题。当然有⼀些学术成果表明，这个条件可以放宽，也就是依靠⼀个“半可信第三⽅”（Semi-trusted Third Party）。但是请诸位思考，所谓 &amp;ldquo;半可信&amp;rdquo; 这并不解决根本问题，半可信第三方只是停留在理论层面的一种设想。&lt;/p&gt;

&lt;p&gt;时间走到了 2008 年，⽐特币横空出世，中本聪给出了⼀种天才设计：在⼀个可以⽆任何准⼊许可的 P2P ⽹络中，采取「POW与最长链」共识协议，以⼀种⾮常公平的⽅式进⾏去中心化记账[3]。我们可以从另⼀个⻆度来理解中本聪的创新：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bitcoin 实现了⼀种分布式协议，它以去中⼼化的⽅式「模拟」出了⼀个「虚拟」的「可信第三⽅」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们在使⽤⽐特币时，可以完全想象存在着这么⼀个虚幻的可信第三⽅，它⾜够可靠，不会记错账。那么⼤家很容易联想到刚才的问题：⽐特币或者区块链能否也&lt;strong&gt;模拟&lt;/strong&gt;出⼀个虚拟的可信第三⽅来实现经典的&lt;strong&gt;公平交易&lt;/strong&gt;呢？这样⼀来，交易的买卖双⽅不就可以不再依赖⼀个实体第三⽅了吗？这样交易的效率会惊⼈地⼤幅提升，中介成本会降到极低。&lt;/p&gt;

&lt;p&gt;如果区块链技术真的可以做到这⼀点，那么实际上就可以实现：「零信任公平交易」。设想下，我们可以随意在⽹络上与完全不互信的另⼀⽅进⾏「数字化商品」交易，⽽且不⽤担⼼他会作弊，因为有区块链在旁边担任⼀个协助者，或者仲裁者的⻆⾊。这会将交易、商品流通或贸易的效率提升到一个无法想象的高度。&lt;/p&gt;

&lt;h2 id=&#34;实现零信任的两方公平交易的先驱-简述-zkcp&#34;&gt;实现零信任的两方公平交易的先驱——简述 ZKCP&lt;/h2&gt;

&lt;p&gt;⽐特币开发者 Greg Maxwell 早在 2011 年就在⽐特币维基⽹站上提出了 「零知识有条件⽀付」（ZKCP）的构想[4]。采用比特币这个被 &lt;strong&gt;模拟&lt;/strong&gt; 出来的第三方来充当 &lt;strong&gt;交易支付&lt;/strong&gt; 中的可信第三方。由于比特币网络是去中心化，因而这个第三方将会是一个 &lt;strong&gt;零信任第三方&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;zkcp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过这个⽅案，买卖双⽅可以通过 BTC 进⾏数据的交易，并且可以做到所谓的「原子交换」，卖家在收款的瞬间，买家拿到数据。这个原理其实⾮常简单，下面来讲述下整个过程：&lt;/p&gt;

&lt;h4 id=&#34;主角&#34;&gt;主角&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;卖家：Alice&lt;/li&gt;
&lt;li&gt;买家：Bob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;ab1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一步： Alice 将「数据」⽤⼀个「钥匙」 加密，锁在箱子里面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ab2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二步：Alice 将箱子发送给 Bob，Alice 还将附加⼀个「零知识证明」，证明两个事实：(1)箱子可以用钥匙打开，(2) 钥匙的哈希等于一个值 「h」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ab3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第三步：Bob 检查零知识证明，确认上述事实为真。然后 Bob 将零知识证明中的一部分撕下来作为「收货收据」。这个收据上写着钥匙的哈希，也就是「h」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ab4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第四步：Bob 创建⼀个智能合约，锁定 1BTC，写⼊「h」。⽀付脚本要求：凡是可以提供「h」的哈希原象的⼈可以提⾛这枚 BTC&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ab5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第五步：Alice 向智能合约出示钥匙&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ab6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第六步：智能合约检查「钥匙」是否和「收货收据」匹配&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ab7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第七步：如果智能合约通过检查，则它把 1BTC 付给 Alice，同时把钥匙交给 Bob。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ab8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第八步：Bob 用「钥匙」打开「箱子」，取出数据。至此，双方完成交易&lt;/p&gt;

&lt;p&gt;所谓原⼦交换是指，⼤家要么交换，要么不交换，这个交换动作不能再分割，像⼀个物理世界的原⼦⼀样。在第六到第八步，这个三个步骤是不可分割的。Alice ⽤「钥匙」提⾛ 1BTC，同时「钥匙」也就暴露在了区块链上，Bob 就可以拿⾛「钥匙」解密数据，同时得到了数据。「原⼦交换」是公平性的⼀个体现，保证买家卖家的交换能完成。好了，其实只有「原⼦交换」还不够。思考⼀下，这整个流程中，还有两个技术难点同样关键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题(1)&lt;/strong&gt;：数据 D 确实是 Bob 想要的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;问题(2)&lt;/strong&gt;：Alice 出示的密钥必须是正确的密钥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2016年 G. Maxwell 和 S. Bowe 等⼈实现了第⼀个基于区块链技术的「完美公平」交易案例[5]。这是一个了不起的实验，人类历史上第一次做到了，无需可信第三方的公平交易。实验完成了两笔数独答案的公平交易。他们采⽤ zkSNARK 技术来产⽣零知识证明，来同时解决上⾯的问题(1)与问题(2)。&lt;/p&gt;

&lt;h2 id=&#34;信任的产生-零知识证明技术&#34;&gt;信任的产生：零知识证明技术&lt;/h2&gt;

&lt;p&gt;零知识证明是如何解决 问题（1）与问题（2）。接下来我插播一下科普，零知识证明是什么呢？可能大家都听说过这个概念，特别是在一些匿名加密数字货币中。零知识证明的英文是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Zero-Knowledge Proof&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里面的每一个单词背后的深意，能值得好好聊聊（这里空间太小，写不下 :P）。但是这里我打算用大白话来尝试解释下。零知识证明是 1984 年由 Goldwasser、Micali 与 Rackoff 三个人提出，他们当时写了一篇文章，题目叫做《The Knowledge Complextiy of Interactive Proof Systems》，中文名翻译过来叫《交互式证明系统中的知识复杂性》。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;gmr89.png&#34; alt=&#34;gmr89&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大家仔细看这张图的左上角，可以看到这篇论文其实发表在 1989 年。由于这篇文章的思想太过超前，太过震撼，以至于从他们 1984 年写出初稿到 1989 年正式被采纳发表，经历了整整五年时间。正是这篇文章提出来了 &lt;strong&gt;零知识证明&lt;/strong&gt; 这个伟大概念，这个概念也逐步成为了现代密码学理论的根基之一。后来大家都知道在 2012 年，Goldwasser 和 Micali 两人因为这个开创性工作而分享了 &lt;strong&gt;图灵奖&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;【注】我们通常理解的零知识证明技术是特指狭义的&lt;code&gt;如何高效构造通用零知识证明&lt;/code&gt; 的理论和技术，而广义的「零知识」是密码学的核心理论根基。&lt;/p&gt;

&lt;p&gt;我想引用这篇文章的一句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一般来说，在协议的设计中经常会遇到这种问题：A 想让 B 相信某件事情。我们知道，如果此刻有一个「天使」（或者 B信赖的某个人）能够让 B 确信 A 说的是实话，那么这个协议是安全的。我们想让「零知识证明」这个概念能够在这里发挥作用，而不是依赖可信第三方，让这个协议仍然是安全的。 ——[GMR89]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;zkp_simu.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这段话是不是有点绕，但是用一句话就可以说明白：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;零知识证明提供的「信任」，能够代替一个「可信第三方」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;听上去很玄幻，不是吗？零知识证明怎么「凭空产生了信任」？我们怎么信任零知识证明？零知识证明的信任基础是什么呢？这些问题不难回答，其实它的信任基于比较客观的理论，一类是基础理论，包括「数论与代数」，「数理逻辑」，还有「计算理论」。还有一类是一些安全假设，比如「离散对数难题」，「Knowledge of Exponent」等等。如果我们信任数学，信任逻辑，信任这些安全假设没有被攻破，那么我们可以得出下面的结论：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;零知识证明实现了一类密码学理论技术，它基于一些安全假设「模拟」出了⼀个虚拟的&lt;strong&gt;可信第三⽅&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;听上去很耳熟对不对？我在前面说了类似的话，拷贝过来:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bitcoin 实现了⼀种分布式协议，它以去中⼼化的⽅式「模拟」出了⼀个虚拟的&lt;strong&gt;可信第三⽅&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很巧合是不是？自从 2016年 《经济学人》提出来的「区块链是信任机器」的说法，我就在一直思考这个问题：「信任机器」如何体现。自从深入思考零知识证明以后，我慢慢发现他们殊途同归，只是各自的维度不一样，区块链解决的是「分布式计算的信任」，零知识证明解决的是「数据的信任」。如果再加上形式化验证，就可以解决「逻辑的信任」。&lt;/p&gt;

&lt;p&gt;这三个点：&lt;strong&gt;逻辑 &amp;lt;-&amp;gt; 计算 &amp;lt;-&amp;gt; 数据&lt;/strong&gt; 才真正构成了一个闭环，也许才能真正实现「信任机器」这一构想。而我们正在践行的 zkPoD 项目正是从这三个不同的维度出发，摸黑前进。&lt;/p&gt;

&lt;p&gt;【思考】三个维度缺一不可，这个观点是否能解决区块链在现实场景难以落地的问题呢？&lt;/p&gt;

&lt;h2 id=&#34;zkcp的-局限性-与零知识证明漏洞&#34;&gt;ZKCP的“局限性”与零知识证明漏洞&lt;/h2&gt;

&lt;p&gt;ZKCP 的构想虽然 2011 年就被提出，但是好事多磨，这个构想⼀直到 2016年2月才正式实现。ZKCP基于当时最前沿的零知识证明技术 ——— zkSNARK [5]。来自 ZCash 团队的 Sean Bowe 编写了 ZKCP 的代码，并且 Gregory Maxwell 从 Sean Bowe 手里购买了 一个 16x16 的数独答案，花费了 0.1 BTC。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;maxwell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是 ZKCP ⽅案还只是一个玩具，难以⽀持稍微⼤⼀点的数据（比如⼤于 1MB ），因为这会为买家带来⽆法承受的计算量（计算量主要是为了产⽣ zkSNARK 零知识证明）。虽然这个⽅案还⽆法实际应⽤，但是它却显现出了区块链技术真正的威⼒：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;总体上我认为像这些 “Trustless” 的智能合约具有非常大的价值，不管是低价值但高频的自动交易——传统交易中的冲突开销（开销过大，而交易价值过低）剥夺了寻求严肃公正的参与度，亦或是高价值交易中的低速，不可靠(特别是需要诉诸司法)，或者传统交易冲突仲裁中的隐私保护缺失，都将会变得无法接受。&lt;/p&gt;

&lt;p&gt;当这个技术变得越来越实用时，我期待会出现非常激动人心的应用。&lt;/p&gt;

&lt;p&gt;————— Gregory Maxwell&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而在 2017年，M. Campanelli 等⼈发布在 ACM CCS 安全顶会上的一篇文章揭示了 ZKCP ⽅案中的一个安全漏洞[6]，ZKCP的实验对于卖家不公平，买家可以通过特定手段，使得零知识证明不再零知识，从而在不付钱的情况下拿走（部分）数独答案。他们在ZKCP的基础上进⾏改进，提出了 ZKCSP ⽅案，但是仍然没有解决实⽤性问题。2018年，S. Dziembowski 等⼈在朝着使用方向努力，在 ACM CCS 的论文里讲解了一个新思路—— FairSwap[7]。它可以⽀持多达数 GB 的数据⽂件交易。Fairswap 通过虚拟电路的⽅式来解决上⾯的问题(1)，对于问题(2)，Fairswap 采⽤了⼀种 “恶意⾏为举报” 的⽅式来应对。这个思路类似闪电⽹络 ， Plasma 等区块链⼆层协议，卖家 Alice ⾸先交付密钥，但是这时候买家 Bob 需要在⼀定时间内（⽐如说三个⼩时），检查密钥的正确性，如果不正确就赶紧举报，并且向区块链（或合约）提供证据，证明密钥或数据存在问题。这种⽅案要求买家必须能够在规定时间内完成举报动作。虽然从理论上，这种交易⽅案没有做到「⼀⼿交钱，⼀⼿交货」，但是仍然是零信任公平交易。只是对卖家 Alice ⽽⾔，她需要等到三个⼩时以后才能拿到货款。&lt;/p&gt;

&lt;h2 id=&#34;什么是-zkpod&#34;&gt;什么是 zkPoD&lt;/h2&gt;

&lt;p&gt;零信任公平交易是很多行业中普遍存在的需求，也是电子商务技术的未来。是我们&lt;strong&gt;安比实验室&lt;/strong&gt;推出的⼀个实⽤的，⽤以交易⼤批量数据（可数字化商品）的零信任公平交易系统。&lt;/p&gt;

&lt;p&gt;zk表示「零知识」，PoD是 底层安全协议的名字，是一种（非）交互式证明系统（PoD 代表 Proof of Delivery），用来实现可验证的数据交付（Verifiable data delivery，也可以理解成可验证的数据传输）。&lt;/p&gt;

&lt;p&gt;zkPoD 基于零知识证明[8-13]（包括GROTH09, Bulletproof, zkSNARK-Groth16等技术），结合区块链实现交易的零信任，既解决了 ZKCP ⽆法交易⼤数据⽂件的问题，也⽀持⽀付/交付动作的原⼦性，实现真正意义上的 “完美公平” 。与 FairSwap 相⽐，zkPoD 协议更加⾼效，⽹络通讯量更⼩，智能合约更轻量级，⽀持各种类型的区块链架构。任何的可数字化商品（Digitalized Commodities）都可以在链下完成商品交付，在链上同时完成⽀付。&lt;/p&gt;

&lt;p&gt;或者更直白点：zkPoD 是一个实用的「零知识有条件支付」 ZKCP 系统。其实，zkPoD 不仅实现ZKCP 中「原⼦交换」，也就是「⼀⼿交钱，⼀⼿交货」⾼效交易流程，同时也⽀持类似 Fairswap 的投诉⽅式证明。后者具有更高的数据吞吐量。&lt;/p&gt;

&lt;p&gt;zkPoD 在试图解决这样一些问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何在做到完美公平的前提下，达到实用，所谓实用不是交易几个字节的信息，而是上GB，甚至达到TB级别。&lt;/p&gt;

&lt;p&gt;如何有效融合并优化最前沿的零知识证明技术，使得我们可以使用手机和移动网络就可以参与。&lt;/p&gt;

&lt;p&gt;如何保证底层的协议与基础算法牢不可摧，这是在区块链这种开放式环境中保证安全的「唯一途径」。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;做一个安全并且实用的系统，相比纸上理论而言，要处理更多的现实问题：比如协议的设计要考虑以太坊平台的各种安全隐患，比如「Front-running Attack」，比如去年我们发现的针对FOMO3D游戏的「堵塞攻击」；比如协议要考虑各种交易方的恶意行为；比如协议要让各方成本达到一个可接受的水平；比如大计算量算法未来能否支持硬件加速；密码学安全强度是否合适等等。&lt;/p&gt;

&lt;h2 id=&#34;zkpod-如何解决两方交易中的公平性问题&#34;&gt;zkPoD 如何解决两方交易中的公平性问题&lt;/h2&gt;

&lt;p&gt;我们再重复下上面提到的有关「公平性」两个关键问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关键问题(1)&lt;/strong&gt;：被加密的数据确实是你想要的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键问题(2)&lt;/strong&gt;：而我出示给你的密钥必须是正确的密钥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先我们分析下问题(1)，zkPoD 如何保证买家在掏钱之前就知道数据的真实性？其实数据的真实性是一个可以很主观，也可以很客观的标准。比如，我买的音乐，mp3好听不好听，这是一个非常主观的判断。或者再退一步，我买的一首歌是不是某个明星真唱的？这是一个半主观的判断。再退一步，我想付费观看一部动作片，没想到买到的是喜羊羊，那么这个判断可以是很客观的吗？可以是，但是写一个算法来检验一部电影是否是恐怖片，还是动画片，并不简单。最后还有一种情况，那就是数据的真实度能够非常客观地来判定，比如 ZKCP 实验中，数据是一个数独游戏的答案。这是可以写一个算法来客观检验的。因此如果数据是存在一个算法，或者说可以通过写一个程序来自动判定真实性，那么这里可以直接构造一个「零知识证明」来向买家出示，这好比是「模拟出一个天使」，告诉用户虽然数据是加密的，但是数据的真实性是可信的。但是如果是另外几种情况呢？这个程序太复杂了，不好写，或者说根本判断是很主观的。为了应对这种情况，zkPoD 采用的是最简单粗暴的方案，用户可以先购买一点点数据，进行验货。确保数据无误后，再大批量购买。「试吃方案」无疑是在现实世界中最简单有效的方法。但是与普通的「试吃」不一样的是， zkPoD 可以额外保证：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;验货数据可以让用户来随机挑选&lt;/li&gt;
&lt;li&gt;验货次数不做任何限制&lt;/li&gt;
&lt;li&gt;多次验货，与大批量购买的数据必须来自于同一个数据集&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了保证上面这三点，zkPoD 也是采用了零知识证明技术来做到。更详细点，任何购买的数据都必须携带一个证明：证明该数据片段是来自于某一个「唯一确定」的数据集合。为了解决问题（1），zkPoD 当前版本采⽤ Pedersen Commitments 来实现隐藏和半同态计算，并且利⽤扩展的 Schnorr 认证协议来传输加密数据，并采用 J. Groth 等人的方法来构造零知识证明[8-13]，从而保证数据的真实性。&lt;/p&gt;

&lt;p&gt;我们再分析下问题（2），区块链在 zkPoD中的核心作用是检查这样一件事情：卖家出示的密钥必须是正确的密钥。这个问题我们可以想象一下，我把密钥出示给「智能合约」，它在完全不接触数据或者加密数据的情况下，如何来保证我出示的密钥，真的能解密？这听上去很难做到。其实，这里我们也可以用零知识证明「模拟出一个天使」，来告诉买家用户还有智能合约：我给你们出示的这个密钥是正确的密钥。这里的原理涉及到PoD安全协议，我在这篇文章里就不展开讲解原理了，只是讲一个大概的思路。首先，我（作为卖家）给你（买家）出示一个关于密钥的零知识证明，还有一把锁（并不锁任何东西，单纯锁起来的一把锁）。关于密钥的零知识证明了这样一个事实：凡是能打开这把锁的密钥一定能解密刚发给你的数据。而在交易的最后一步，你把这把锁交给智能合约，而我交出钥匙，而智能合约负责检查钥匙能不能打开这把锁。如果能正常打开，那么你就可以把钥匙拿走去解密数据了。如果打不开，那么说明我交出来的钥匙是假的，那么我拿不到付款。我们可以这么理解，通过零知识证明，我们把密钥有效性的检查「归结」（Reduce）到一个钥匙开锁问题。而这个问题是一个智能合约容易解决的问题。（zkPoD充分考虑了现有智能合约平台上进行计算的代价和实用性）。对于问题(2)，zkPoD 利⽤了安全哈希函数，并结合零知识证明技术来保证对于密钥的校验。zkPoD ⽬前仅支持以太坊，并且经过数次协议优化，⽬前在以太坊上的 Gas 消耗量已基本达到实⽤。&lt;/p&gt;

&lt;h2 id=&#34;零信任-形式化验证与安全性证明&#34;&gt;「零信任」、形式化验证与安全性证明&lt;/h2&gt;

&lt;p&gt;我们前面谈了区块链，谈了零知识证明，下面继续来谈谈「形式化验证」。在 zkPoD 里面，不管是零知识证明，还是智能合约，还是底层的椭圆曲线算法，这些都是 zkPoD 公平性的基础。我经常会被问到这样的问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那么这些底层玩意儿可信么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我想你也会有同样的疑问，尤其在这个群魔乱舞的区块链行业。凭什么我能相信你的零知识证明技术没问题，凭什么我相信区块链没问题？这篇文章的标题是「零信任」，其实这个说法并不准确。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;任何「信任」都需要基于某些信任基础（Trusted Computing Base），任何「安全」都有安全性假设&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;zkPoD 也不例外，它的可信度仍然要基于许多「可能没问题」的部件，甚至是很多「说不清楚」的东西。&lt;/p&gt;

&lt;p&gt;补上信任的最后一环正是「形式化验证」。这里不深入细节，我只简单讨论下「形式化验证」到底在 zkPoD 场景下能做到哪些，能解决什么问题。形式化验证实际上是为逻辑，流程或者业务进行形式化建模，你可以理解为用一种数学语言进行描述，模型就是一些数学概念（或数学对象），比如集合、代数、范畴等等。然后所有的形式化验证都在用「显式」的或「隐式」的方式「严格证明」某个结论（或者叫做定理）。一旦当某个部件的可靠性论点被「证明」了，那么他就可以被移出 Trusted Computing Base。&lt;/p&gt;

&lt;p&gt;【注】没有产生证明（包括隐式证明）的分析过程，不能称为形式化验证，因为这些分析过程没有客观的检验标准。&lt;/p&gt;

&lt;p&gt;上面我们提到了两个「模拟」，一个是区块链，另一个是零知识证明。他们之所以可信，是因为他们能够「模拟出可信第三方」。这个模拟过程是如何模拟的？首先下个结论：&lt;strong&gt;这两个模拟过程都是可以形式化的，并且是可证明的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 Goldwasser 和 Micali 的论文中，他们就阐述了如何证明「零知识」，如何证明「模拟」这个操作。到如今，模拟（Simulation）和安全性证明已是密码学界的共识，也是基本的形式化工具，没有经过证明/验证的模拟是无法让大家接受的。证明零知识的过程恰好就是一个直觉主义构造性证明：构造一个概率图灵机，他能够模拟出各种第三方，还有各种有趣的概念。我看过的绝大多数零知识证明科普文章中，鲜有提到「模拟」这个概念，更不会提到安全性证明。这导致再怎么解释零知识证明，读者理解起来就如同雾里看花一样，始终抓不住那个关键点，模模糊糊好像懂了，但是似乎又说不清楚。因为我研究了十几年的逻辑证明，在啃了一些论文和证明之后，慢慢从那些密码学安全性证明中体会到了「模拟」与「零知识」中所表达出的神奇理念。这些理念与当年我们验证操作系统、验证编译器工作中的理念非常吻合。另外一方面，学术界已经开始在对「区块链模拟」，也就是共识协议的信任进行非常严格的数学建模与证明[14-16]。&lt;/p&gt;

&lt;p&gt;形式化验证在 zkPoD 中解决「区块链」，「零知识证明」这些技术依赖的那些「信任基础」的可信度问题。理论上，所有客观标准都能进行验证，大到一个安全协议，小到一行代码，凡是经过形式化验证的部件，将会变成「零信任」。这是一个渐进的过程。我们正在对 PoD 安全协议进行形式化验证，对「零知识证明」相关的理论进行证明，我们正在对 zkPoD 中的以太坊智能合约（零信任第三方）进行形式化建模与验证。未来我们会利用形式化方法对交易协议进行更细致的建模与验证。&lt;/p&gt;

&lt;h2 id=&#34;zkpod-的演进&#34;&gt;zkPoD 的演进&lt;/h2&gt;

&lt;p&gt;zkPoD 这个项⽬源于去年国庆节，团队⽼胡说有个好玩的想法，⼤家听了很兴奋，于是很快搞出来⼀个⼩ Demo，但是令人沮丧的是，不久我们就发现了其中的理论漏洞。然后接下来是漫⻓的啃密码学，补理论的过程，那酸爽。请教过各路⼤神，也曾⽆⽐迷茫，每⼀次⼩突破却又能偷偷开⼼好⼀阵⼦。&lt;/p&gt;

&lt;p&gt;这⾥给⼤家讲⼏个测试数据。拿⼀个 1GB 的数据⽂件为例，卖家初始化这个数据，需要花 90 秒 ，也就是⼀分钟多⼀点，喝口水的时间。然后如果买卖双方要采用最慢的原子交易协议（zkPoD提供三种不同的协议），对接低 TPS 公链（比如 Ethereum），卖家需要计算产⽣较多的零知识证明，⼤概需要花费 9 个⼩时（普通PC，6核CPU），平均在 20KB/s 这个速度，这个速度已经⽐⼆⼗年前 Modem 拨号上⽹时代的下载速度快不少。单笔交易的以太坊消耗 Gas ⼤概在15万单位左右，相当于十美分，折合RMB 7毛钱。⽽如果是采⽤「投诉证明」方式的交易协议，卖家只需要花费 124秒 就可完成零知识证明的产⽣，⽽买家也基本以相同的时间 120秒 来接收并校验数据。请注意，在这种模式下，⽹络的通讯量要翻倍，也就是需要传输2GB 多的数据，以太坊 Gas 消耗⼩于 20万单位。总体上，传输速率可达 3MB/s，这已经接近⼆⼗年前普通局域⽹⽂件传输的速度。针对高TPS公链，或者联盟链，zkPoD 还提供了性能更好的协议模式。虽然 zkPoD 的核⼼性能已经可以达到⽀撑⽂本、⾳频、甚⾄视频的效果，但是系统还需要对协议做进⼀步的完善、改进和优化，才能⽀持丰富的上层应⽤。现在系统还只有⼀个粗陋的命令⾏界⾯：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;zkPoD.optimize.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;好奇的同学请点击这⾥观看一个完整的演示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/251240?autoplay=1&amp;amp;speed=2.71828182846&#34;&gt;https://asciinema.org/a/251240?autoplay=1&amp;amp;speed=2.71828182846&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更多的关于 zkPoD 的技术细节、系统架构、代码结构，测试结果，还有一个技术白皮书请参考我们的代码仓库：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sec-bit/zkPoD-node&#34;&gt;https://github.com/sec-bit/zkPoD-node&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也可以下载代码编译试运⾏，默认 zkPoD 将会链接我们部署在以太坊测试⽹络上的合约&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ropsten：0x07d04D5912383F8523208b978C73D4786a5b1e86&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽然 zkPoD 已可以达到 Demo 演示的状态，但是还是个半成品。周边各种协议⽀持，⼯具链还有客户端等都还待完善。zkPoD 还有许许多多好玩的扩展功能在路上，也有⼀些创意功能还没来得及实现。zkPoD 也将会对接更多的优秀公链。&lt;/p&gt;

&lt;p&gt;我们的想法是能不能把这么好玩的项⽬做成⼀个⾃由开源开放的社区项⽬，希望能有各种技能的⼩伙伴们加⼊一起协作。后续社区会整理⼀些技术⽂档包括经验分享，还有在这个过程中所了解到的各种有趣的知识，还请大家持续关注。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;zkPoD 的⽬标？我还没想清楚，也许是成为下⼀代互联⽹的基础协议，实现数据与价值的双向流动&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;零知识证明再述&#34;&gt;零知识证明再述&lt;/h2&gt;

&lt;p&gt;零知识证明是我近年来⻅过的最有趣的理论和技术。零知识证明的学术理论确实有些深度。但是它的概念和应⽤却也没那么难懂，虽然⻔槛略⾼。⽆论中⽂还是英⽂，这⽅⾯的资料都极度缺乏，⼯程实践更是少之⼜少。&lt;/p&gt;

&lt;p&gt;我想通过⼏个简单例⼦来解释，假如我数学考试考了61分，爸妈问起来，我只要出示⼀个零知识证明，这个证明是⼀串数字，但是可以让爸妈确信这个分数确实及格了，但是具体多少分呢？对不起，⽼爸是⽆论如何都没办法从这串数字中推算出，甚⾄也⽆法知道到底是80分以上，还是80分以下。这类零知识证明被称为「范围证明」（Range Proof）。当然我还要再出示一个数字签名的零知识证明，「可验证计算证明」（Verifiable Computation Proof），向老爸证明，这个分数曾被老师签过名（我们这里假设是采用的BLS短数字签名）。可验证计算证明，你可以想象成我把老师签名的过程用手机拍了下来，但是镜头里出现分数的地方，我都把它马赛克了。&lt;/p&gt;

&lt;p&gt;又假如，我保存了⼀个你的秘密，⽐如说⽐特币的助记词，我可以向所有⼈出示⼀串数字，证明我没有忘记你的助记词，但是任何⼈都不能从这个证明中得到这个助记词的任何⽚段。这类零知识证明又被称为「知识证明」（Proof of Knowledge）。因为任何⼈都不能从这个证明中分析出更多关于助记词秘密的内容，因此这个证明是零知识的。换句话说，这个证明是⼀串数字，看起来就和随机数⼀样，没有信息量。（这里有个小问题留给读者：我如何向你的朋友们证明，这个助记词对应比特币地址上的钱没有被我花掉。有想法请后台留言）&lt;/p&gt;

&lt;p&gt;零知识证明的⽤处⾮常⼴泛，⼤家可以各种开脑洞，其中⼀个最直接也⾮常重要的⽤处就是敏感数据的保护。不管是成绩单、病历、账本、密码、等等等，你都可以把其中任何部分扣掉，换成⼀个很像随机数的零知识证明，它能证明被扣掉的敏感数据仍然是可信的，真实的。（这⾥请⼤家开脑洞，还有哪些好玩的场景。）&lt;/p&gt;

&lt;p&gt;在 zkPoD 中，零知识证明扮演了⾮常重要的⻆⾊，数据的交付过程是以零知识证明的⽅式交付，买家先拿到的是⼀堆的零知识证明，当然数据隐藏在这些数据中，但是从外部整体上看，这些看似⾮常随机的数据中，是没有任何办法去得到关于原始数据的哪怕⼀个bit。（这⼀点可以证明，请原谅我忍不住插⼀点学术术语：基于离散对数难题假设的「完美零知识」，Perfect Zero-Knowledge）理解零知识证明理论的核心是理解我上面反复提到的「模拟」这个暗黑并有趣的概念。这个我们以后再展开讲。&lt;/p&gt;

&lt;h2 id=&#34;如何加-我们&#34;&gt;如何加⼊我们&lt;/h2&gt;

&lt;p&gt;zkPoD 刚刚出⽣，还只是个⼩玩意儿，我们希望它能健康成长，现在 zkPoD 项⽬召集不超过 5 名⼩伙伴参与搞事情，如果感兴趣请附上你的技能科技树，来和我们⼀起开脑洞，啃论文，撸代码，练技术。报名请扫描后⾯⼆维码（接头暗号：Simulator 开⻔）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「零信任」并不等于什么都可以不用信任。零信任的根基是数学。「In Math We Trust」，这是我脑海中迅速闪过的⼀句话，现在回头看，这中间的每⼀个字⺟都闪烁着⼈类理性智慧的光辉&lt;/p&gt;

&lt;p&gt;———— 郭宇（安⽐实验室创始⼈）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参考文献&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[1] Pagnia, Henning, and Felix C. Gärtner. On the impossibility of fair exchange without a trusted third party. Technical Report TUD-BS-1999-02, Darmstadt University of Technology, Department of Computer Science, Darmstadt, Germany, 1999.&lt;/li&gt;
&lt;li&gt;[2] Garbinato, Benoît, and Ian Rickebusch. &amp;ldquo;Impossibility results on fair exchange.&amp;rdquo; 10th International Conferenceon Innovative Internet Community Systems (I2CS)–Jubilee Edition 2010– (2010).&lt;/li&gt;
&lt;li&gt;[3] Nakamoto, Satoshi. &amp;ldquo;Bitcoin: A peer-to-peer electronic cash system.&amp;rdquo; (2008).&lt;/li&gt;
&lt;li&gt;[4] Maxwell, G. &amp;ldquo;Zero knowledge contingent payment. 2011.&amp;rdquo; URl: &lt;a href=&#34;https://en.bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment&#34;&gt;https://en.bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment&lt;/a&gt; (visited on 05/01/2016) (2016).&lt;/li&gt;
&lt;li&gt;[5] Greg Maxwell. “The first successful Zero-Knowledge Contingent Payment.”
&lt;a href=&#34;https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/&#34;&gt;https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[6] Campanelli, Matteo, Rosario Gennaro, Steven Goldfeder, and Luca Nizzardo. &amp;ldquo;Zero-knowledge contingent payments revisited: Attacks and payments for services.&amp;rdquo; In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, pp. 229-243. ACM, 2017.&lt;/li&gt;
&lt;li&gt;[7] Dziembowski, Stefan, Lisa Eckey, and Sebastian Faust. &amp;ldquo;FairSwap: How to fairly exchange digital
goods.&amp;rdquo; Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications
Security. ACM, 2018.&lt;/li&gt;
&lt;li&gt;[8] Groth, Jens. &amp;ldquo;Linear algebra with sub-linear zero-knowledge arguments.&amp;rdquo; Annual International
Cryptology Conference. Springer, Berlin, Heidelberg, 2009.&lt;/li&gt;
&lt;li&gt;[9] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., &amp;amp; Petit, C. (2016, May). Efficient zero-knowledge
arguments for arithmetic circuits in the discrete log setting. In Annual International Conference on the
Theory and Applications of Cryptographic Techniques (pp. 327-357). Springer, Berlin, Heidelberg.&lt;/li&gt;
&lt;li&gt;[10] Bünz, Benedikt, et al. &amp;ldquo;Bulletproofs: Short proofs for confidential transactions and more.&amp;rdquo; 2018
IEEE Symposium on Security and Privacy (SP). IEEE, 2018.&lt;/li&gt;
&lt;li&gt;[11] Gennaro, Rosario, et al. &amp;ldquo;Quadratic span programs and succinct NIZKs without PCPs.&amp;rdquo; Annual
International Conference on the Theory and Applications of Cryptographic Techniques. Springer Berlin, Heidelberg, 2013.&lt;/li&gt;
&lt;li&gt;[12] Parno, Bryan, et al. &amp;ldquo;Pinocchio: Nearly practical verifiable computation.&amp;rdquo; 2013 IEEE Symposium
on Security and Privacy. IEEE, 2013.&lt;/li&gt;
&lt;li&gt;[13] Groth, Jens. &amp;ldquo;On the size of pairing-based non-interactive arguments.&amp;rdquo; Annual International
Conference on the Theory and Applications of Cryptographic Techniques. Springer, Berlin, Heidelberg, 2016.&lt;/li&gt;
&lt;li&gt;[14] Doug Woos, James R. Wilcox, Steve Anton, Zachary Tatlock, Michael D. Ernst, and Thomas Anderson. Planning for Change in a Formal Verification of the Raft Consensus Protocol. CPP 2016, St. Petersburg, FL, January 2016.&lt;/li&gt;
&lt;li&gt;[15] Pîrlea, George, and Ilya Sergey. &amp;ldquo;Mechanising blockchain consensus.&amp;rdquo; Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs. ACM, 2018.&lt;/li&gt;
&lt;li&gt;[16] Palmskog, Karl, et al. Verification of Casper in the Coq Proof Assistant. 2018.&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Move语言：我眼中的 Libra 最大亮点</title>
      <link>https://sec-bit.github.io/blog/2019/07/10/move-programming-language-the-highlight-of-libra/</link>
      <pubDate>Wed, 10 Jul 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/07/10/move-programming-language-the-highlight-of-libra/</guid>
      
        <description>

&lt;p&gt;相信各位和我一样，今天被 Facebook 刷爆朋友圈。&lt;/p&gt;

&lt;p&gt;Facebook 发起的加密数字货币项目 Libra 于今天（6月18日）正式公开亮相。Libra 同步发布了多语言官网和白皮书，定位为面向数十亿人的全球货币和金融服务基础设施。Libra 还发布了多个技术白皮书，详细介绍了其新开发的编程语言 Move 和共识协议 LibraBFT。Libra 源码已在 GitHub 开源，测试网络也已上线。目前设计为许可链（联盟链），其声称当前非许可链（公链）不存在成熟的解决方案能够支撑数十亿人的使用需求，并表明将在发布五年内开始转向非许可链的过渡工作。&lt;/p&gt;

&lt;p&gt;Libra 的一系列发布中，新的编程语言 Move 尤为吸人眼球。第一时间看了 Move 的白皮书，嗯，这也许才是未来智能合约语言该有的样子。&lt;/p&gt;

&lt;p&gt;一位来自柏林的开发者 Lefteris Karapetsas 在社交平台上提出了自己的观点：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Their design goals seem to overlap, or even aim to replace Ethereum?&lt;/p&gt;

&lt;p&gt;他们的设计目标似乎有些重叠，或者甚至旨在代替以太坊？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PuzzleToLife.com 的创始人 CryptoPuzzleDream 认为：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think &amp;ldquo;move&amp;rdquo; programming language released by $FB could be more interesting than libra&lt;/p&gt;

&lt;p&gt;我认为FB发布的 “move” 语言比 libra 更有趣。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;James Clark 是一名标准极客，他说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m usually pretty skeptical of anything related to cryptocurrency, but here&amp;rsquo;s one piece of Libra that looks potentially interesting: a bytecode programming language called Move with semantics inspired by linear logic.&lt;/p&gt;

&lt;p&gt;我通常对与加密货币相关的任何东西都表示怀疑，但是Libra 中有一部分看起来相当有趣：一个被称为 Move 的字节码编程语言，其语义受线性逻辑的启发。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而我脑子里闪过是这样一句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Move 是为「数字资产」而生的智能合约平台型语言&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;move-语言的三大用处&#34;&gt;Move 语言的三大用处&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;发行数字货币，Token，和数字资产&lt;/li&gt;
&lt;li&gt;灵活处理区块链交易&lt;/li&gt;
&lt;li&gt;验证器（Validator）管理&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;自底向上的静态类型系统&#34;&gt;自底向上的静态类型系统&lt;/h2&gt;

&lt;p&gt;Move 采用的是静态类型系统，类型系统本质上是一种逻辑约束。相比以太坊的智能合约语言来说要严格地多。现代的编程语言比如 Rust, Golang, Typescript，Haskell, Scala, OCaml 都不约而同采用了静态类型系统，他们的优点是，很多编程低级错误都可以在编译的时候发现，而不是拖到运行期才爆出 bug。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Well-typed programs never get stuck.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是程序语言（PL）领域的一句黑话：一个类型无误的代码永远不会跑飞。意思是，如果一段合约代码经过了类型检查，那么可靠性会相当高。&lt;/p&gt;

&lt;p&gt;Move 也没有设计成一个 100% 静态类型检查的语言，那样会降低实用性。 Move 提到了尽量让类型检查在编译的时刻进行，而不是等部署到链上之后。当然有些类型检查不得不放到运行期来做，但是仍然可以保证类型安全。&lt;/p&gt;

&lt;p&gt;Move 有个非常好的设计思路是，从虚拟机开始就是静态类型化的，然后往上是一个有一定易读性的中间语言层，IR层（Intermediate Representation），也是类型化的。将来，Move 上层将会提供更多的面向各种金融应用的高级语言，那些语言自然也是静态类型，保证智能合约不再会发生非常低级的错误。&lt;/p&gt;

&lt;h2 id=&#34;first-class-resources-理念&#34;&gt;First-class Resources 理念&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;First-class Resources&lt;/code&gt; 这个词相当得学术，中文翻译过来叫「资源是一等公民」，
这究竟什么意思呢？所谓编程语言的一等公民就是编程语言在编程的时候首要考虑的被编程对象。&lt;/p&gt;

&lt;p&gt;那么&lt;code&gt;资源&lt;/code&gt;，&lt;code&gt;Resources&lt;/code&gt;又是什么呢？ 这也是一个很学术的名字。&lt;code&gt;Resources&lt;/code&gt;是和&lt;code&gt;Value&lt;/code&gt; 相对应
的概念。&lt;code&gt;Value&lt;/code&gt;是可以随意拷贝的，而&lt;code&gt;Resources&lt;/code&gt;只能被消耗，不能被拷贝。&lt;code&gt;Resources&lt;/code&gt;就像可乐，
你喝了一瓶就少了一瓶，而&lt;code&gt;Value&lt;/code&gt;，就好比写在本子上的英文单词，每天早上都可以念一遍，念完他不会消失，如果你记住了，那就在脑子里拷贝了一份。不仅你可以念，我也可以念，你可以背，我也可以背。&lt;/p&gt;

&lt;p&gt;传统的编程语言，包括以太坊智能合约语言中，对于数字资产的记账是采用 &lt;code&gt;Value&lt;/code&gt; 的方式，这会导致一个问题：记账是有可能记错的。事实上记错账的智能合约相当得多，比如：张三向李四转账，李四的账户多了10块钱，但是张三的账户余额却没改。在过去两年里，各种智能合约记账漏洞甚至一度搞得大家对智能合约的未来丧失了信心。&lt;/p&gt;

&lt;p&gt;Move 合约吸收了传统理论「线性逻辑」的思想，提出了一种类型，叫做「资源类型」（Resources Types）。数字资产可以用「资源类型」来定义，这样一来，数字资产就像资源一样，满足线性逻辑的一些特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数字资产不能被复制&lt;/li&gt;
&lt;li&gt;数字资产不能凭空消失&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;First-class Resources&lt;/code&gt; 的真正含义是「数字资产是一等公民」。这句话可以引申出，Move 是为操作数字资产而生的智能合约语言。从技术角度讲，数字资产可以作为合约的变量，数字资产可以存储，可以赋值，可以作为函数/过程的参数，也可以作为函数/过程的返回值。而 Move 的静态类型系统使得智能合约代码能够在编译期，也就是部署前就可以通过编译器检查出绝大多数的资源使用错误。保证智能合约不再像以前那样的脆弱不堪。&lt;/p&gt;

&lt;p&gt;摘用白皮书摘要中的一句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;First-class resources are a very general concept that programmers can use not only to implement safe digital assets but also to write correct business logic for wrapping assets and enforcing access control policies.&lt;/p&gt;

&lt;p&gt;作为一等公民的资源是一种非常普遍的概念，程序员不仅可以用它实现安全的数字资产，同时也可以编写正确的业务逻辑，实现正确的访问控制策略。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;合约安全性设计&#34;&gt;合约安全性设计&lt;/h2&gt;

&lt;p&gt;Move 合约在设计时，充分考虑了安全性。首先 Move 完全不支持动态指派（Dynamic Dispatch）。好，我这里解释下什么是 Dynamic Dispatch，通俗地说，这是一种非常灵活的语言机制。在程序里面是可以写很多的函数，或者过程，或者子程序。然后一个主程序可以来调用这些函数/过程/子程序，来分别完成不同的功能。如果程序在运行之前，我们就能知道它到底都调用了哪个函数，或者以某种顺序调用很多函数，那么这些函数调用是「静态指派」的，如果在运行之前，我们不清楚某一步的函数调用究竟是调用了哪一个函数，直到程序运行的时候，通过观察，我们才能知道的话，那么这个函数调用被称为是「动态指派」的。「动态指派」显然要比「静态指派」灵活的多。&lt;/p&gt;

&lt;p&gt;但是灵活同时也意味着更容易出问题。很多现代编程语言都或多或少支持动态指派，也就是从语言层面直接支持，比如面向对象语言中的「继承」导致的「动态绑定」。动态特性是不利于程序的推理，更不利于形式化验证（Formal verification），也更容易出安全问题。在以太坊智能合约设计中就存在许多「动态特性」，比如支持函数指针做参数，合约做参数，delegatecall等等。除此之外，还有「高阶函数指针」，「回调函数」，「异常处理函数」等等都属于「动态指派」。而 Move 语言则剔除了任何形式的「动态指派」或者「动态特性」，即所有的合约执行路径都能在编译的时候确定，然后可以进行非常充分的分析、验证。&lt;/p&gt;

&lt;p&gt;Move 合约在运行前都会经过一个字节码验证器（Bytecode verifier）进行校验，这个验证器可以检查出各种类型错误，同时也进行充分的静态分析。同时字节码在解释执行的时候，仍然是带着类型，一边运行，一边检查。&lt;/p&gt;

&lt;p&gt;Move 语言对合约中的「可修改变量」进行了非常严格的限制，并且从 Rust 语言那边偷师了一些设计理念。保证任何时刻只能由一个指针对可修改变量进行修改，这样避免造成混乱。在以太坊 Solidity 里面，可以定义很多的指针指向同一个变量，如果程序员没考虑清楚代码逻辑，就会很容易出各种奇葩问题。&lt;/p&gt;

&lt;p&gt;与以太坊 EVM 平台相比，Move 模块系统不再支持循环递归依赖，完美解决合约重入一类的漏洞（Re-entrancy）。&lt;/p&gt;

&lt;h2 id=&#34;强悍的模块系统&#34;&gt;强悍的模块系统&lt;/h2&gt;

&lt;p&gt;Move 模块系统采用的是一种函数式编程语言（OCaml, Coq, SML）风格的设计，按照白皮书的说法：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Move modules are similar to smart contracts in other blockchain languages. &amp;hellip;, However, modules enforce strong data abstraction — a type is transparent inside its declaring module and opaque outside of it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;模块系统可以很好地将数字资产的概念打包封装，对于数字资产的操作比如通过模块的公开接口，并且在这个接口上可以做灵活的权限控制。在写以太坊智能合约的时候，以太坊上的 ERC20 Token 是作为一个合约而存在，而在 Move 语言中，一个 Token 可以被想象成一个箱子，被随意像资源一样传递，但是同时不会暴露箱子内部细节。同时模块系统的抽象也完全基于它的静态类型系统，并且类型安全性完全可以由智能合约虚拟机来检查保证。&lt;/p&gt;

&lt;p&gt;Move 的模块系统为智能合约的形式化验证提供了非常好的基础，在模块内部可以定义「不变式」。所谓的不变式是指对数字资产内部状态的一个严格约束，这个约束可以为形式化验证的自动化提供非常有价值的信息。而且，模块系统的「不透明抽象」可以使形式化验证工作变得模块化，成本更低。在Move 模块系统上编写程序分析器，符号执行器也会简单很多，因为经过抽象，可以把合约逻辑变得非常简单，易推理。当然对于普通智能合约开发者而言，利用好模块系统，可以让合约代码变得异常清晰。&lt;/p&gt;

&lt;h2 id=&#34;面向未来的-move-智能合约&#34;&gt;面向未来的 Move 智能合约&lt;/h2&gt;

&lt;p&gt;Move 虽然看起来还略显粗糙和稚嫩，但是这个方向仍然让人激动人心，从 Move 语言层面可以看到 Facebook 的野心，是想做一个庞大的数字资产平台。这个角色本来应该属于以太坊。&lt;/p&gt;

&lt;p&gt;我为什么有点喜欢上了 Move，想了想，大概下面三个原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;汲取了 PL (程序语言)领域研究成果，同时也吸收了 EVM 智能合约语言的经验教训。&lt;/li&gt;
&lt;li&gt;从设计上无比重视「智能合约安全性、正确性」&lt;/li&gt;
&lt;li&gt;没有墨守成规（既没有用WASM，LLVM，也没有在 EVM 上直接修改），而是积极创新，是设计构思真正适合金融应用的智能合约语言&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;在区块链领域里面，凡是套用传统方法的方案，无一胜出，唯有创新才有未来。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>为什么说区块链是一座全新的博弈竞技场？</title>
      <link>https://sec-bit.github.io/blog/2019/06/13/ethereum-the-unprecedented-arena-for-playing-cooperative-games/</link>
      <pubDate>Thu, 13 Jun 2019 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2019/06/13/ethereum-the-unprecedented-arena-for-playing-cooperative-games/</guid>
      
        <description>

&lt;p&gt;（本文由安比实验室&amp;amp;橙皮书联合出品）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;区块链到底有什么用？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;针对这个问题，以太坊基金会成员 Virgil Griffith 曾以以太坊为例，提出了一个让人眼前一亮的观点[1]：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ethereum is an unprecedented arena for playing cooperative games（以太坊是前所未有的合作博弈竞技场）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;区块链和博弈论是两个不同的领域，乍一看似乎并没有太大的关联性，但事实并非如此。&lt;strong&gt;几乎所有的博弈论经典案例都可以借助区块链构建出新的博弈关系&lt;/strong&gt;。Virgil Griffith 在他的文章中以以太坊为基础，借用博弈论中经典的案例解释了如何利用区块链来建立新的博弈关系。&lt;/p&gt;

&lt;h3 id=&#34;两败俱伤-合作共赢-建立非合作博弈转变为合作博弈的支点&#34;&gt;两败俱伤？合作共赢？—— 建立非合作博弈转变为合作博弈的支点&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;博弈论&lt;/strong&gt;（&lt;strong&gt;Game Theory&lt;/strong&gt;）是经济学的一个分支，是研究博弈行为中斗争各方是否存在着最合理的行为方案，以及如何找到这个合理的行为方案的数学理论和方法[t2]。其中具有竞争或对抗性质的行为称为&lt;strong&gt;博弈行为&lt;/strong&gt;[2]。&lt;/p&gt;

&lt;p&gt;说到博弈论就不得不提到一个大家所熟知的经典案例——&lt;strong&gt;囚徒困境&lt;/strong&gt;[3]。&lt;/p&gt;

&lt;p&gt;有两个共谋犯罪的囚徒张三和李四被捕，他们之间不能互相交流。如果双方都不揭发对方，则每个人都只被关押 1 年；若他们双方有一方揭发，而另一方选择沉默，则揭发者将立即获释，沉默者则将被关押 8 年；若互相揭发，双方将同时被关押 5 年。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;很显然如果双方都保持沉默，是对他们最有利的选择。但实际上，最终双方在都会倾向于揭发对方。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是什么导致了如此反直觉的结果呢？&lt;/p&gt;

&lt;p&gt;我们用下图的矩阵来简单解释一下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./img1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对于张三来说，若选择沉默，结果有两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;被关押 1 年，此时李四选择沉默，同样被关押 1 年；&lt;/li&gt;
&lt;li&gt;被关押 8 年，此时李四选择揭发，直接释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若张三选择揭发，其两种结果为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接释放，此时李四选择沉默，被关押 8 年；&lt;/li&gt;
&lt;li&gt;被关押 5 年，此时李四选择揭发，同样被关押 5 年。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以无论张三怎么选择，对李四较来说，揭发张三都是对他个人比较有利的选择。同样对张三来说亦然。&lt;/p&gt;

&lt;p&gt;因而在双方未进行沟通协商的前提下，张三和李四只会做出对个人最有利的选择。囚徒双方的这种博弈关系被称为&lt;strong&gt;非合作博弈&lt;/strong&gt;。这里囚徒双方的选择被称为基于&lt;strong&gt;个体理性&lt;/strong&gt;的决策，与之相反的是基于&lt;strong&gt;群体理性&lt;/strong&gt;做出的决策。这里双方在做出决策揭露对方后即达到了博弈的&lt;strong&gt;纳什均衡点&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;博弈的分类根据不同的基准也有不同的分类。一般认为，博弈主要可以分为合作博弈和非合作博弈[t2] 。&lt;strong&gt;合作博弈论&lt;/strong&gt;是指一些参与者以形成联盟、互相合作的方式所进行的博弈。合作博弈的相反是&lt;strong&gt;非合作博弈&lt;/strong&gt;，指的是参与者不可能形成联盟或任何合作机制都必须为自我履约契约(例如，透过置信威胁的方式)[t4]。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;纳什均衡点&lt;/strong&gt; 是指相互作用的经济主体在假定所有其他主体所选策略为既定的情况下选择他们自己最优策略的状态。如果某情况下无一参与者可以通过独自行动而增加收益，则此策略组合被称为纳什均衡点[5]。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在博弈论中，形成&lt;strong&gt;合作博弈&lt;/strong&gt;需要满足两个基本条件[6]：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对联盟来说，整体收益大于其每个成员单独经营时的收益之和。&lt;/li&gt;
&lt;li&gt;对联盟内部而言，每个成员都能获得比不加入联盟时多一些的收益。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;囚徒困境的问题在于，在不知道对方选择的前提下，选择不合作将被关押的时间更短（即他们个人获得的收益更大），所以不满足合作博弈的基本条件。&lt;/p&gt;

&lt;p&gt;Virgil Griffith  给出了一个实现合作博弈的解决方案——&lt;strong&gt;借助区块链智能合约建立新的契约关系来创建新的规则。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们先将囚徒双方被关押的年数转换成其在以太坊上的收益（如收益为 -1ETH 即指的是被关押 1 年）来解释这个问题。在张三和李四被逮捕之前，他们在以太坊上部署一个合约，合约内容如下：两人同时抵押 1000 ETH，并且保证选择沉默。如果任意一方选择不遵守诺言，将烧掉其在合约中锁定的 1000 ETH，即他将损失 1000 ETH，这远远大于他们原本在选择沉默或是揭发时的损失，所以囚徒困境的纳什均衡被打破。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./img2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过部署一个不可修改且自动执行的合约，就可以使囚徒之间达成一个具有约束力且强制执行的协议，原来基于&lt;strong&gt;个人理性&lt;/strong&gt;而做的决策被相互&lt;strong&gt;合作的决策&lt;/strong&gt;所替代，我们成功得将&lt;strong&gt;非合作博弈关系转换成了合作博弈&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;不仅仅是囚徒困境，&lt;strong&gt;几乎所有的非合作博弈都能借助智能合约构造新的博弈关系&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们再来看一个非合作博弈转化为合作博弈的例子 —— &lt;strong&gt;猎鹿赛局&lt;/strong&gt;[7] 。&lt;/p&gt;

&lt;p&gt;两名猎人 A 和 B一起去打猎，他们可以猎取鹿，也可以猎取野兔。鹿需要两个人合作才能获取，野兔一个人就可猎得，但猎鹿所得的收益大于猎野兔所得的收益。如下图所示，我们假定猎取野兔的收益为 1 ETH，猎取鹿的收益为 3 ETH。&lt;img src=&#34;./img3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虽然两名猎人同时选择猎取鹿的收益最大，但却需要承担对方不选择猎取鹿的后果。所以猎人们可能会更倾向于做出猎取野兔这种收益小但风险也小的选择。&lt;/p&gt;

&lt;p&gt;与囚徒困境类似，这里我们同样可以利用区块链在猎人之间建立合作关系。猎人们先在以太坊上创建合约，双方各自向合约中抵押 1000 ETH，若任意一方最终猎取了野兔，则将其抵押的 1000 ETH烧掉，于是此时任何一名猎人此时都不会选择猎取野兔。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./img4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上述例子中，我们将博弈方的收益和损失都转换为了以太坊上的价值符号表示，但在实际的应用场景中，能否以此来代替实际的收益还有待商榷；另外智能合约如何感知实际场景中的决策结果并自动触发合约执行也相对困难。因此&lt;strong&gt;如何找到适合的机制让现实博弈的关键操作与链上合约绑定&lt;/strong&gt; 至关重要。&lt;/p&gt;

&lt;h3 id=&#34;博弈革命-竞技场上的角逐新规则&#34;&gt;博弈革命——竞技场上的角逐新规则&lt;/h3&gt;

&lt;p&gt;其实区块链和智能合约并不是改变博弈的必要条件，但区块链智能合约在应用和部署博弈模型方面有着巨大的潜力。&lt;/p&gt;

&lt;p&gt;由于真实情况下我们难以找到适合的可信第三方来做为公平的仲裁者，辅助执行博弈结果的利益裁定。而区块链及智能合约的出现让这一切变得十分容易，正如 Upgradeability is a bug[8] 这篇文章中所说的那样，&lt;strong&gt;智能合约最大的价值恰恰是在于它的 Trustless&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;不仅仅是非合作博弈，几乎任意的博弈关系都可以与区块链结合，创造出新的规则。&lt;/p&gt;

&lt;h4 id=&#34;1-懦夫博弈&#34;&gt;1. 懦夫博弈&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;在非合作博弈中打造竞争优势。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;懦夫博弈也叫&amp;rdquo;胆小鬼博弈&amp;rdquo;，是指两名车手甲和乙相对驱车而行，最先转弯的一方被耻笑为“胆小鬼”（chicken），另一方胜出，但如果两人拒绝转弯，任由两车相撞，最终谁都无法受益[9]。&lt;/p&gt;

&lt;p&gt;我们假定当两人同时转弯时记为收益为 0；当一方转弯，另一方直行时，转弯的一方记为收益 -1 ETH，另一方收益为 10 ETH；当两人同时直行时记为收益为 -100 ETH。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./img5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;很显然，这个游戏只有当一方选择直行，另一方选择转弯收益最大，但是谁选择直行谁选择转弯却很难判定。&lt;/p&gt;

&lt;p&gt;为了打破僵局获得最大收益，车手甲可以在游戏开始之前创建合约，抵押 1000 ETH ，并通知车手乙。若其选择转弯，合约将自动烧毁其抵押的 1000 ETH，这就使得车手甲必定选择直行，而乙就不得不选择转弯以将损失降到最低。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./img6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-爵士乐队表演&#34;&gt;2. 爵士乐队表演&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;借助智能合约保障合作博弈中的利益公平分配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;爵士乐队表演是一个合作博弈的案例[10]。假设一个场景，某台晚会需要招募表演人员，可供选择的表演人员包括一名吉他手，一名架子鼓手和一名歌手。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若招募的结果是只招募到一个人（歌手，吉他手，架子鼓手任意一人），则仅支付 1 ETH；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若招募到一名歌手和一名吉他手，则共支付他们 7 ETH；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若招募到一名歌手和一名架子鼓手，则共支付他们 5 ETH；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若招募到一名吉他手和一名架子鼓手，则共支付他们 4 ETH；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若同时招募到歌手，吉他手和架子鼓手 3 人，则共支付他们 10 ETH。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;./img7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上述表演费用中，显然歌手，吉他手和架子鼓手组成一个乐队参与表演的收益是最大的，他们有很大的动力组成一个联盟去参加表演。三个人组成乐队得到10个以太币的报酬之后，每个人应该分配多少个以太币才合理呢？&lt;/p&gt;

&lt;p&gt;我们可以简略分析一下乐队中每个成员的贡献：&lt;/p&gt;

&lt;p&gt;有歌手参加的二人合作总收益为：7+5=12&lt;/p&gt;

&lt;p&gt;有吉他手参与的二人合作总收益为：7+4=11&lt;/p&gt;

&lt;p&gt;有架子鼓手参与的二人合作总收益为：5+4=9&lt;/p&gt;

&lt;p&gt;在二人合作中，我们可以看到歌手的价值最高，吉他手的价值居中，架子鼓手的价值最低。&lt;/p&gt;

&lt;p&gt;2012年诺贝尔经济学奖获得者夏普利曾提出一个Shapley值的概念，解决了在合作博弈中合理分配收益给参与者的问题[11]。如果依据他的理论进行分配，歌手应该得到 4，吉他手 3.5，架子鼓手 2.5。&lt;/p&gt;

&lt;p&gt;举办方可以将分配的Shapley值计算公式写入智能合约，在演奏结束之后让合约自动转账给演奏参与者，从而保证分配的公平性。&lt;/p&gt;

&lt;h4 id=&#34;3-从他人的博弈中套利&#34;&gt;3. 从他人的博弈中套利&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;空手套白狼：干扰他人博弈以套利&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设在一个博弈关系中有两个参与者：A 和 B。A 可以执行两个动作，向上或者向下；B 也可以执行两个动作向左或者向右。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若 A 选择向上，B 选择向左，则双方均获得 10 ETH 的收益；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 A 选择向上，B 选择向右，则双方没有收益；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 A 选择向下，B 选择向左，A没有收益，B 获得 1 ETH的收益；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 A 选择向下，B 选择向右，A获得 1 ETH的收益，B 没有收益。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;./img8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显然这个时候 A 选择向上，B 选择向左是对双方最有利的选择。&lt;/p&gt;

&lt;p&gt;在游戏开始之前，第三方 C 创建一个合约，A 需在游戏开始前向 C 转 5 ETH,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若 A 按照要求向 C 转 5 ETH，C将不再干预游戏，最终 A 获得 5ETH收益，B 获得 10 ETH的收益。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;./img9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若 A 未按照要求向 C 转 5 ETH，C将干预游戏，游戏结束后若B选择向右，合约自动向 B 转 100 ETH，那么 A 最多获得 1ETH 的收益，B 则获得 100 ETH的收益。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;./img10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对于 B 来说，他需要根据 A 是否事先向 C 转账来决定他的选择。而对于 A 来说，向 C 转 5 ETH最终他还能获得 5 ETH的收益，如果不转则最多只能获得 1 ETH 的收益。面对理性的 A 和 B，C 仅需要创建一个合约，不支付任何费用，就可以让 A 乖乖得将部分收益转让给他。&lt;/p&gt;

&lt;p&gt;*面对这种赤裸裸的 &amp;ldquo;&lt;strong&gt;敲诈&lt;/strong&gt;&amp;rdquo; 行为，A 是否可以借助区块链来逆转局面呢？*&lt;/p&gt;

&lt;p&gt;（聪明的小伙伴如果想到了解决的办法，欢迎添加小安的微信 secbit_xiaoanbi 来参与讨论）&lt;/p&gt;

&lt;h3 id=&#34;道阻且长-寻找链上链下的绑定机制&#34;&gt;道阻且长 —— 寻找链上链下的绑定机制&lt;/h3&gt;

&lt;p&gt;正如 Virgil Griffith 所说，&lt;/p&gt;

&lt;p&gt;&amp;lsquo;&lt;em&gt;Ethereum enables powerful economic vehicles we don&amp;rsquo;t yet understand.（以太坊支持我们不甚知晓的强大的经济学工具。）&lt;/em&gt;&amp;rsquo; [1]&lt;/p&gt;

&lt;p&gt;区块链作为一种去中心化，执行结果明确，不可篡改的&amp;rdquo;可信第三方&amp;rdquo;，打破了传统的思维，为打破博弈关系建立新的规则提供了非常有效的途径。作为一座全新的博弈竞技场，区块链和智能合约必定会为博弈的应用和改变注入更多的灵感。&lt;/p&gt;

&lt;p&gt;但正如上文所提到的，如何找到适合的机制让现实博弈的关键操作与链上合约绑定，还需要更进一步的探索。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;或许距离这座&amp;rdquo;竞技场&amp;rdquo;真正运转起来还有很长的路要走。&amp;rdquo;&lt;/p&gt;

&lt;p&gt;​                                                                           — 郭宇(安比实验室创始人)&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://medium.com/@virgilgr/ethereum-is-game-changing-technology-literally-d67e01a01cf8&#34;&gt;https://medium.com/@virgilgr/ethereum-is-game-changing-technology-literally-d67e01a01cf8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/Game_theory&#34;&gt;https://en.wikipedia.org/wiki/Game_theory&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&#34;https://en.wikipedia.org/wiki/Prisoner%27s_dilemma&#34;&gt;https://en.wikipedia.org/wiki/Prisoner%27s_dilemma&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] &lt;a href=&#34;https://en.wikipedia.org/wiki/Cooperative_game_theory&#34;&gt;https://en.wikipedia.org/wiki/Cooperative_game_theory&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] &lt;a href=&#34;https://en.wikipedia.org/wiki/Nash_equilibrium&#34;&gt;https://en.wikipedia.org/wiki/Nash_equilibrium&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[6] &lt;a href=&#34;https://wiki.mbalib.com/wiki/%E5%90%88%E4%BD%9C%E5%8D%9A%E5%BC%88&#34;&gt;https://wiki.mbalib.com/wiki/%E5%90%88%E4%BD%9C%E5%8D%9A%E5%BC%88&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[7]&lt;a href=&#34;https://en.wikipedia.org/wiki/Stag_hunt&#34;&gt;https://en.wikipedia.org/wiki/Stag_hunt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[8] Upgradeability Is a Bug &lt;a href=&#34;https://medium.com/consensys-diligence/upgradeability-is-a-bug-dba0203152ce&#34;&gt;https://medium.com/consensys-diligence/upgradeability-is-a-bug-dba0203152ce&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[9] &lt;a href=&#34;https://en.wikipedia.org/wiki/Chicken_(game&#34;&gt;https://en.wikipedia.org/wiki/Chicken_(game&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;[10] &lt;a href=&#34;https://www.coursera.org/lecture/mathematical-game-theory/shapley-value-and-core-gWuz9&#34;&gt;https://www.coursera.org/lecture/mathematical-game-theory/shapley-value-and-core-gWuz9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[11] &lt;a href=&#34;https://en.wikipedia.org/wiki/Shapley_value&#34;&gt;https://en.wikipedia.org/wiki/Shapley_value&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Don’t Test, Verify —— 哪个故事真正符合你对形式化验证的想象？</title>
      <link>https://sec-bit.github.io/blog/2018/10/24/formal-verification-background/</link>
      <pubDate>Wed, 24 Oct 2018 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2018/10/24/formal-verification-background/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;世界上是否有一种技术可以保证计算机程序绝对安全，能够完全抵挡住黑客的进攻？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;2015年夏天，一组黑客奉命对美国军方一款名为Little Bird的无人直升机发动电子攻击，目的是掌控无人机的控制权[1]。该攻击测试持续进行了几个月之久，在每次正式进攻开始前，黑客们占尽先机，他们已经被授权进入了该无人机系统的一部分子系统。接下来，黑客们要做的就是侵入这个无人机的飞行控制系统，从而完全掌握该无人机的控制权。在此次攻击测试刚开始的时候，黑客团队很容易就能侵入该无人机的控制系统。在接下来的一段时间内，来自美国国防部高级研究计划署（DARPA）的专家们重新开发了该无人机的核心控制程序，当该程序被部署到Little Bird上之后，黑客们对Little Bird重新发动攻击。在给定的六周时间内，黑客们使用了当今世界上所有的攻击手段，都未能攻破新部署的系统。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;到底是什么技术给予了Little Bird超强的防御能力，从而使它阻挡了所有的攻击？答案就是：&lt;strong&gt;数学证明！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-little-bird.jpg&#34; alt=&#34;Little Bird&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过数学证明来进行程序设计与验证的技术通称为形式化方法&lt;/strong&gt;。如果说这个世界上是否有一种技术可以保证计算机程序绝对安全，能够完全抵挡住黑客的进攻？答案已经呼之欲出了。&lt;/p&gt;

&lt;p&gt;在区块链领域，据安比（SECBIT）实验室调查显示,仅2018年上半年就已经有大约&lt;strong&gt;11亿美元&lt;/strong&gt;的加密货币被盗，不仅如此，与区块链系统相关的漏洞（如以太坊中的智能合约漏洞）以及围绕加密货币的生态系统安全问题（如多个中心化交易所被盗）更是层出不穷。目前区块链系统中的相关漏洞，以及加密货币生态系统的安全问题归根结底是相关程序设计与实现的问题。以智能合约为例，其一经部署、发布便不能更改的特性，为形式化方法在区块链领域的应用探索提供了可能性。&lt;/p&gt;

&lt;p&gt;形式化方法的核心思想由计算机科学先驱，1972年图灵奖获得者Edsger Dijkstra（大名鼎鼎的Dijkstra最短路径算法发明者）率先提出，其目的是&lt;strong&gt;通过严格的逻辑推理开发出正确且可靠的程序&lt;/strong&gt;，从而避免程序出现错误。如今大部分的计算机系统都通过软件测试来保证程序的正确性，然而正如Dijkstra所说的那样：“*程序测试能证明错误的存在,但不能证明错误不存在*”。&lt;/p&gt;

&lt;p&gt;人类已经在软件和硬件开发方面由于程序设计错误付出了十分惨痛的代价。1996年6月4日，雄心勃勃的欧洲航天局首次发射新一代重型航天运载火箭-阿丽亚娜5型（Ariane 5），欧洲航天局花费了约&lt;strong&gt;80亿美元&lt;/strong&gt;和&lt;strong&gt;9年时间&lt;/strong&gt;设计和研发该型运载火箭，虽然这是阿丽亚娜5型火箭的首次发射，欧洲航天局依然将价值不菲的卫星搭载到该火箭上。然而，火箭在发射仅仅37秒后便偏离了预定轨道，最终坠毁。经过详细调查，调查委员会认定火箭发射失败是由于控制惯性导航系统的计算机向箭载计算机发送了一个错误指令造成的，该&lt;strong&gt;错误指令是由将浮点数转换为整数造成溢出而产生的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;无独有偶，2016年2月17日，日本将价值约3亿美元的天体观测卫星“瞳”发射至距离地面580公里的轨道上，大约五周之后，“瞳”与地面信息通信中断，并且逐步解体。“瞳”卫星上搭载了先进的X射线望远镜及检测器，科学家希望通过这些设备研究宇宙的起源。随着卫星的解体，原本设定的研究计划完全无法进行，给天文学的研究带来了巨大的损失。日本宇宙航空研究开发机构（JAXA）调查显示，事故发生的原因在于卫星底层软件系统的设计出现了问题，“瞳”的控制系统在发现卫星飞行姿态错位时启动了&lt;strong&gt;错误的调整命令&lt;/strong&gt;，导致推进器点火时朝向了相反的方向，进而使卫星产生了更加严重的自旋，在错误指令的操作下“瞳”最终解体。由于航天控制器对软件系统的安全性要求很高，我们国家已经将形式化方法用在验证玉兔号月球车相关控制系统的正确性上[2]。玉兔号月球车于2013年12月15日登陆月球，并且在月球表面生存工作了972天，超额完成了任务。此外，研究人员已经逐步对我国第一个自主研发的空间飞行器嵌入式实时操作系统SpaceOS进行安全性验证[3]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;yutu.jpg&#34; alt=&#34;玉兔&#34; /&gt;&lt;/p&gt;

&lt;p&gt;1994年，数学教授Thomas Nicely在使用电脑进行大数除法运算时一直出错，经过调查，发现这个错误是由于英特尔（Intel）奔腾处理器存在漏洞-奔腾浮点除错误（Pentium FDIV bug）导致的,这个漏洞不仅使英特尔公司付出了5亿美元的代价，更加严重影响了英特尔的声誉。经过这次惨痛的教训，英特尔公司聘请剑桥大学专家Harrison用HOL证明器对芯片中的浮点运算器进行了形式化的验证，从而证明了新设计的浮点运算器的正确性[4]。时至今日，英特尔公司成立了专门形式化验证的小组专门对芯片的功能进行正确性验证。&lt;/p&gt;

&lt;h2 id=&#34;什么是形式化方法&#34;&gt;什么是形式化方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;形式化方法已经被运用到对软件和硬件安全要求很高的领域&lt;/strong&gt;。除了Intel公司之外，其他几家硬件巨头如AMD， NVIDIA 和 CADENCE都已经将形式化方法应用到产品设计与验证过程中。美国国家航空航天局（NASA）早已意识到形式化方法在设计航空航天控制系统中的重要作用，早在30年前就成立了专门的形式化方法小组。随着无人航天技术的发展，NASA对软硬件系统进行错误检测、诊断和预测的需求日益增多，形式化方法已经被NASA运用到系统规范，开发和验证全过程。为了促进形式化方法的研究，NASA每年都会举办形式化方法研讨会（NASA Formal Methods Symposium）[5]，NASA形式化方法研究团队一直在不断壮大，如今，其形式化研究小组的成员分布在NASA的六个研究中心，是NASA研发力量的一个重要组成部分。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;形式化方法特指用来对软件和硬件系统进行&lt;strong&gt;规范&lt;/strong&gt;，&lt;strong&gt;设计&lt;/strong&gt;和&lt;strong&gt;验证&lt;/strong&gt;的数学理论及相关工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，形式化规范  (formal specification) 通过&lt;strong&gt;数学语言&lt;/strong&gt;对系统的预期行为 (例如将数量 S 的 token 从账户 A 转移到账户 B) 和性质 (例如转账不会造成账户 B 额度的溢出) 进行严格和全面的定义。形式化规范往往定义了系统的正确性和安全性。&lt;/p&gt;

&lt;p&gt;给定一个系统的形式化规范，我们即可以从规范出发开始迭代设计和实现出这个系统。在迭代的每一步中，我们可以通过精化 (refinement)、集成 (synthesis) 、形式化证明在内的一系列方法在数学上严格的保证迭代产生的系统和迭代前的规范或者系统保持一致。&lt;/p&gt;

&lt;p&gt;除了从形式化规范出发设计和实现一个系统，我们也可以使用包括&lt;strong&gt;符号执行 (symbolic execution)&lt;/strong&gt;、**模型检测 (model checking) &lt;strong&gt;和&lt;/strong&gt;形式化证明 (formal proving)** 在内的一系列方法验证已有的设计和实现与该规范保持一致。例如，对于一段智能合约程序，我们可以从它所有可能的输入 (例如函数参数的组合) 和初始状态 (例如状态变量初始值的组合) 出发，根据每条语句的语义，逐句推导出程序的所有可能的结束状态 (例如合约执行结束后的状态变量的值和产生的 event log)，并检查合约的所有输入、初始状态、结束状态的组合是否都和形式化规范保持一致。这里，所有的定义都是通过严格的数学语言描述，推导和检查也是严格的数学推导和证明。根据待验证的系统及其形式化规范的复杂程度，推导和证明即可以手工构造，也可能可以由机器自动产生。在实践中，&lt;strong&gt;推导&lt;/strong&gt;和&lt;strong&gt;证明&lt;/strong&gt;无法进行下去往往意味着设计和实现中存在不符合规范的 bug。通过分析推导和证明卡壳的位置和原因，往往可以定位出 bug 在设计和实现中具体位置和成因。&lt;/p&gt;

&lt;h2 id=&#34;形式化方法的应用&#34;&gt;形式化方法的应用&lt;/h2&gt;

&lt;p&gt;通过形式化方法对程序进行验证，需要在原程序的基础上增加相关的检查和证明语句，对程序添加证明是一件十分复杂的工作。在目前的软件开发实践中，软件测试比形式化方法更加广泛的应用到程序开发中。随着与形式化方法相关的技术不断发展，工业界已经开始使用形式化方法来开发和验证高度可靠的软件系统。&lt;/p&gt;

&lt;p&gt;2009年，澳大利亚的科学家使用形式化方法对工业级操作系统seL4微内核进行了完整功能性验证[6]，这是世界上第一个没有漏洞的操作系统内核，能够完全防止系统崩溃或者恶意攻击。*微内核是操作系统的最小核心*，其提供了底层位地址空间管理、进程间通信和调度等功能。与seL4微内核相关的信息可以在其官方网站上查看。此外，耶鲁大学的研究团队通过模块分层验证法（modular layered verification methods）也成功的研发了一个可以防范黑客攻击,并且支持并发操作的计算机操作系统CertiKOS[7]，CertiKOS具有极高的安全性和可靠性。中国科学技术大学软件安全实验室的研究人员也提出一个针对可抢占操作系统的形式化验证框架，并成功的应用在对商用嵌入式操作系统 uC/OS-II 的验证中，以数学证明的形式为其调度系统等主要模块的正确性提供了严格的证据[8]。美国国家自然科学基金（NSF）资助了美国多所顶尖大学进行形式化方法方面的研究，其中一个项目DeepSpec[9]目的在于为硬件和软件开发提供深度规范和验证，从而保证系统的安全性。&lt;/p&gt;

&lt;p&gt;形式化验证技术还被用来设计和验证轨道交通系统，欧洲铁路安全标准（例如EN50128）要求使用形式化方法来确保系统设计满足相应的安全属性。一个典型的例子是Ansaldo-STS公司的开发人员在设计列车管理系统软件LDS时，使用形式化方法验证该系统安全逻辑的正确性[10]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;proof.png&#34; alt=&#34;proof&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在目前区块链安全事件频发的时期，&lt;strong&gt;将形式化方法应用到区块链领域有着非常现实的意义&lt;/strong&gt;。以太坊黑客攻击第一大案The DAO中，攻击者窃取了当时价值5500万美元的以太币，并且导致了以太坊的硬分叉。这之后，与以太坊智能合约相关的攻击一直在继续，2017年11月，以太坊Parity钱包由于被黑客攻击，导致用户损失了价值约为&lt;strong&gt;1.5亿美元&lt;/strong&gt;的数字资产。由于智能合约关键逻辑代码全都是开源的，并且代码直接与数字货币的操作相关，这就导致黑客们会不遗余力的寻找每一个智能合约代码中的漏洞，从而瞬间获得数额巨大的不义之财。&lt;em&gt;通过形式化方法对智能合约的行为进行精确地数学推理和证明，可以保证智能合约的行为符合开发者的设计意图，从而保证代码的安全性。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室在应用形式化方法对智能合约进行安全验证方面走在世界前列，其率先完成了全球首个携带交互式形式化证明的智能合约库，并且将相关代码开源[11]。&lt;strong&gt;安比（SECBIT）实验室的研究员通过交互式定理证明工具 COQ，对 ERC20 智能合约中的一些高阶逻辑特性进行了证明&lt;/strong&gt;。经过证明的 ERC20合约具有以下特性：不存在溢出漏洞、所有账户余额的总和与totalSupply一致、Token中的总量不变、合约转账无法影响非相关账户余额等。此外，MakerDAO项目方发布了第一个经过形式化验证的去中心化应用程序（DApp）[12]，MakerDAO 是一个基于以太坊的智能合约平台，该平台提供了稳定币（stablecoin），抵押贷款（collateral loans），以及去中心化社区治理功能。为了保证所部署的智能合约的安全性，MakerDAO团队对抵押贷款（CDP）核心引擎合约代码通过K-Framewok进行了验证，因此而表明其智能合约程序满足预期的规范，相关证明代码可参考其项目库[13]。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;由于区块链自身不可篡改的特点，智能合约在部署之前要确保没有bug，这与传统软件开发允许试错，快速迭代的特点十分不同；又由于区块链在金融领域的应用使得相关智能合约直接与数字资产绑定，而智能合约一旦被攻破，所有者的资产将化为乌有。&lt;strong&gt;基于数学证明的形式化方法为开发高可信的软件系统提供了有效的手段&lt;/strong&gt;。安比（SECBIT）实验室认为应用形式化方法对安全性要求非常高的智能合约系统进行开发和验证，能够切实解决区块链目前遇到的安全威胁。形式化方法要求对代码进行额外的推理证明，相比于基于测试的软件开发流程更加复杂，为了保证智能合约的安全，付出更多的努力是值得的。我们的后续文章将更加系统的介绍形式化验证及其在智能合约安全方面的应用。&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;

&lt;p&gt;[1] COMPUTER SCIENTISTS CLOSE IN ON PERFECT, HACK-PROOF CODE, &lt;a href=&#34;https://www.wired.com/2016/09/computer-scientists-close-perfect-hack-proof-code/&#34;&gt;https://www.wired.com/2016/09/computer-scientists-close-perfect-hack-proof-code/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] Shan, L., Wang, Y., Fu, N., Zhou, X., Zhao, L., Wan, L., Qiao, L. and Chen, J., 2014, May. Formal verification of lunar rover control software using UPPAAL. In International Symposium on Formal Methods (pp. 718-732). Springer, Cham.&lt;/p&gt;

&lt;p&gt;[3] 乔磊, 杨孟飞, 谭彦亮, 蒲戈光 and 杨桦, 2017. 基于 Event-B 的航天器内存管理系统形式化验证. 软件学报, 28(5), pp.1204-1220.&lt;/p&gt;

&lt;p&gt;[4] Formal Proofs of Floating-Point Algorithms, 2010, &lt;a href=&#34;https://www.cl.cam.ac.uk/~jrh13/slides/scan-28sep10/slides.pdf&#34;&gt;https://www.cl.cam.ac.uk/~jrh13/slides/scan-28sep10/slides.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] Tenth NASA Formal Methods Symposium, 2018, &lt;a href=&#34;https://shemesh.larc.nasa.gov/NFM2018/&#34;&gt;https://shemesh.larc.nasa.gov/NFM2018/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[6] The seL4 Microkernel, &lt;a href=&#34;https://sel4.systems/&#34;&gt;https://sel4.systems/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[7] Certified OS Kernels, &lt;a href=&#34;http://flint.cs.yale.edu/certikos/&#34;&gt;http://flint.cs.yale.edu/certikos/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[8] Fengwei Xu, Ming Fu, Xinyu Feng, Xiaoran Zhang, Hui Zhang and Zhaohui Li. A Practical Verification Framework for Preemptive OS Kernels. Proc. 28th International Conference on Computer Aided Verification (CAV&amp;rsquo;16).&lt;/p&gt;

&lt;p&gt;[9] The science of Deep Specification, 2018, &lt;a href=&#34;https://deepspec.org/main&#34;&gt;https://deepspec.org/main&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[10] Cimatti, A., Corvino, R., Lazzaro, A., Narasamdya, I., Rizzo, T., Roveri, M., Sanseviero, A. and Tchaltsev, A., 2012, July. Formal verification and validation of ERTMS industrial railway train spacing system. In International Conference on Computer Aided Verification (pp. 378-393). Springer, Berlin, Heidelberg.&lt;/p&gt;

&lt;p&gt;[11] Token Libraries with Proofs, 2018, &lt;a href=&#34;https://github.com/sec-bit/tokenlibs-with-proofs&#34;&gt;https://github.com/sec-bit/tokenlibs-with-proofs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[12] The Code is Ready, 2018,  &lt;a href=&#34;https://medium.com/makerdao/the-code-is-ready-2aee2aa62e73&#34;&gt;https://medium.com/makerdao/the-code-is-ready-2aee2aa62e73&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[13] k-dss, 2018, &lt;a href=&#34;https://github.com/dapphub/k-dss&#34;&gt;https://github.com/dapphub/k-dss&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>是谁控制了比特币，是你？还是钱包？BTC地址与交易原理剖析</title>
      <link>https://sec-bit.github.io/blog/2018/09/29/bitcoin-p2pk2-p2sh-addr-pywallet-bug/</link>
      <pubDate>Sat, 29 Sep 2018 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2018/09/29/bitcoin-p2pk2-p2sh-addr-pywallet-bug/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;比特币地址有 1 打头地址 ，也有 3 打头的地址，你知道这两者有什么区别吗？&lt;/p&gt;

&lt;p&gt;在哪种情况下，地址上的比特币会被锁死？&lt;/p&gt;

&lt;p&gt;到底是谁拥有比特币的控制权，是你？还是你的钱包？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;如果你在使用比特币钱包，但却无法回答上面三个问题，那么这篇文章是为你而写。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室在对数字钱包源码审计时，发现一个名为 pywallet 的比特币钱包开源库包含了一个严重缺陷。如果向 pywallet 生成的 OmniLayer 收款地址转账，将导致资产永久丢失。&lt;/p&gt;

&lt;p&gt;据安比（SECBIT）实验室区块链技术专家 zer0to0ne  解释，OmniLayer 协议允许在比特币区块链上发行自定义资产（比如 USDT）。OmniLayer 资产交易的本质是比特币交易。比特币交易的代码库有很多，pywallet 便是其中一种。它可以方便的构造符合 OmniLayer 格式的比特币交易。目前 pywallet 已经被应用在一些数字钱包软件中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是，开源库 pywallet 在生成 OmniLayer 钱包地址的时候，误将地址的前缀写反了，若干资产被锁死在无效的地址内！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面是 pywallet 相关错误代码截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./imgs/pywallet.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;文件地址：&lt;a href=&#34;https://github.com/ranaroussi/pywallet/commit/eb784ea4dd62fe2a50e1352e7d24438fc66a4ac0#diff-ca3a8be6f2ab4be3bfd69a49f5f4122a&#34;&gt;https://github.com/ranaroussi/pywallet/commit/eb784ea4dd62fe2a50e1352e7d24438fc66a4ac0#diff-ca3a8be6f2ab4be3bfd69a49f5f4122a&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;插队科普一下：比特币网络上最常见的地址类型有三种：普通公钥地址（*1-地址*），脚本哈希地址（*3-地址*）和隔离见证地址（*bc1-地址*），地址类型通过地址的前缀来区分。其中*1-地址*的前缀为 0x00，&lt;em&gt;3-地址&lt;/em&gt; 的前缀为 0x05。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;*1-地址*：这是最常见的比特币地址，通常用于普通转账收款。&lt;em&gt;1-地址&lt;/em&gt; 实际上为公钥Hash的编码。验证 *1-地址*的签名后便可解锁收款。&lt;/li&gt;
&lt;li&gt;*3-地址*：这个地址为脚本（Script）哈希地址。这类地址实际对应为一段比特币脚本Hash的编码。&lt;/li&gt;
&lt;li&gt;*bc1-地址*：bech32编码地址，用于隔离见证交易。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源库 pywallet 颠倒了地址前缀，将 &lt;em&gt;1-地址&lt;/em&gt; 错误地设置为 *3-地址*。因此原本要转给 &lt;em&gt;1-地址&lt;/em&gt; 的资产会误转入 *3-地址*。当账户持有者以 &lt;em&gt;1-地址&lt;/em&gt; 的验证方式，也就是私钥签名去取出资产的时候，区块链网络却以 &lt;em&gt;3-地址&lt;/em&gt; 执行脚本的方式去执行验证，导致用户无法正常取出资产！&lt;/p&gt;

&lt;p&gt;&lt;em&gt;请慎重使用 pywallet 开源库！！&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;真相-比特币从未真正实现过转账功能&#34;&gt;真相：比特币从未真正实现过转账功能&lt;/h4&gt;

&lt;p&gt;这一点出乎很多人的意料，由于比特币的实现基于 UTXO 模型，与我们直观理解的账户模型不一样。zer0to0ne 解释说，&lt;strong&gt;实际上比特币从未真正实现过通常意义上的转账功能&lt;/strong&gt;。中本聪只给比特币设计了一系列比特币脚本操作符和比特币脚本执行器，而所谓的转账过程实际是由一段比特币脚本锁定、解锁过程来模拟。这与日常生活中的账本概念（或称之为账户模型）不一样。&lt;/p&gt;

&lt;p&gt;为了便于理解，我们可以把比特币区块链上的资产交易比喻成 &lt;strong&gt;将资产锁进保险箱&lt;/strong&gt;，只有持有保险箱钥匙的人（即收款人）才能拿出保险箱中的资产进行交易。举个例子，如果 Alice 要向 Bob 支付一笔资产，Alice 将这笔资产锁进一个保险箱中，只有 Bob 才有这个保险箱的钥匙，即只有Bob才能取出这笔资产。如果 Bob 要取出资产，那么要求 Bob 必须同时花掉这笔资产（即锁入另一个保险箱）。在 Bob 没有取出资产前，资产并不真正属于 Bob。设想如果 Bob 丢了钥匙，那么将无法再取出资产。 换句话说，这笔资产还在保险箱中保存的时候，既不属于Alice，也不完全属于Bob。当然，Alice 也可以把资产放入任何人都可以打开的保险箱中，这也被称之为 Anyone-Can-Spend 交易。&lt;/p&gt;

&lt;p&gt;由于比特币区块链上的收款地址不同，保险箱的类型也有所不同。&lt;strong&gt;不同类型的保险箱需要不同类型的钥匙来开启。&lt;/strong&gt;付款人为收款人定制一个保险箱，将资产放入保险箱中并上锁，再将保险箱丢到公共场所。而保险箱有两种开启方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若收款人为 *1-地址*，我们称保险箱为&lt;em&gt;1-类保险箱&lt;/em&gt; 。而相应的钥匙必须是指定收款地址对应的私钥。解锁保险箱的过程也就是验证 *1-地址*公钥以及公钥对应的数字签名，这也是我们通常所理解的向普通账户地址转账的验证过程。&lt;/li&gt;
&lt;li&gt;若收款人为 *3-地址*，我们称为&lt;em&gt;3-类保险箱&lt;/em&gt; 。开启钥匙必须为&lt;strong&gt;一段可以执行的比特币脚本&lt;/strong&gt;。解锁保险箱的过程是：比特币脚本的Hash值对应到 &lt;em&gt;3-地址&lt;/em&gt; ，同时比特币脚本执行器运行该脚本后&lt;strong&gt;成功返回&lt;/strong&gt;。也就是说只有拥有脚本原文并可以成功执行的人才可以提取这个保险箱里的资产。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到这一节的问题：为什么说比特币从未实现真正意义上的转账功能。答案很简单，因为比特币系统中根本就不存在账户的概念，账户之间的转账也无从谈起。一个人能在未来打开多少个保险箱，也是未知数。&lt;/p&gt;

&lt;p&gt;通过上面的解释，我们可知：当 pywallet 开源库误将 &lt;em&gt;1-地址&lt;/em&gt; 识别为 &lt;em&gt;3-地址&lt;/em&gt; 时，就好像将原本的&lt;em&gt;1-类保险箱&lt;/em&gt; 改造成了*3-类保险箱*，而账户持有者还是拿着 &lt;em&gt;1-类保险箱&lt;/em&gt; 的钥匙去解锁，那么自然无法打开保险箱。那么之前 zer0to0ne 发现的被误锁住的 OmniLayer 数字资产是否能恢复？&lt;/p&gt;

&lt;h4 id=&#34;是否存在一种可能性-采用-1-地址-的钥匙去开启-3-保险箱&#34;&gt;是否存在一种可能性，采用 &lt;em&gt;1-地址&lt;/em&gt; 的钥匙去开启 &lt;em&gt;3-保险箱&lt;/em&gt; ?&lt;/h4&gt;

&lt;p&gt;zer0to0ne 接着向我们详细解释了两个重要概念 P2PKH（Pay to Public Key Hash） 与 P2SH （Pay to Script Hash）的来龙去脉。这两个名词分别代表了两种不同的比特币交易类型。&lt;/p&gt;

&lt;p&gt;下面是 zer0to0ne 的精彩技术细节分析&lt;/p&gt;

&lt;h2 id=&#34;p2pkh-中本聪的伟大发明&#34;&gt;P2PKH——中本聪的伟大发明&lt;/h2&gt;

&lt;p&gt;Pay to Public Key Hash 顾名思义，是将比特币放入一个保险箱，钥匙孔为公钥 Hash（Public Key Hash）。我们最常见到的 &lt;em&gt;1-地址&lt;/em&gt; 本质上就是 Public Key Hash 的一种编码。&lt;em&gt;1-地址&lt;/em&gt; 的生成过程也很简单，将公钥经过&lt;code&gt;Hash160&lt;/code&gt;运算得到 Public Key Hash，在 Public Key Hash 头部补上前缀 0x00，Hash 尾部补上校验和，经过&lt;code&gt;Base58&lt;/code&gt;便得到了1开头的比特币地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Base58(0x00 + &amp;lt;Public Key Hash&amp;gt; + Checksum)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们来看看P2PKH交易类型的保险箱构造过程，Alice发送比特币给Bob为例：&lt;/p&gt;

&lt;p&gt;付款方 Alice 在构造保险箱的时候需要设置一个&lt;strong&gt;锁定脚本&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;OP_DUP 

OP_HASH160 

(Bob收款地址蕴含的Public Key Hash) 

OP_EQUALVERIFY 

OP_CHECKSIG&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;注：我们可以把这一步理解为 Alice 为 Bob 定制了一个保险箱，把比特币放入保险箱并用 Bob 的公钥 PubKey Hash上锁。现在这把锁除了持有私钥的 Bob，谁都无法打开。&lt;/p&gt;

&lt;p&gt;当 Bob 需要花费 Alice 给他的比特币时，需要提供必要的参数：交易签名 + 公钥（技术黑话：scriptSig）来开启保险箱，使得锁定脚本执行后返回 True，这一步通常由钱包自动完成。&lt;/p&gt;

&lt;p&gt;我们来看看比特币节点是如何校验 scriptSig 合法性的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./imgs/page167image1815040.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;（图片来自Mastering Bitcoin）&lt;/p&gt;

&lt;p&gt;脚本执行过程如图所示，Bob将交易签名后得到的数据（实际上还要包含数据长度信息），真正的scriptSig 应该为&lt;code&gt;&amp;lt;sig len&amp;gt; &amp;lt;sig&amp;gt; &amp;lt;pubKey len&amp;gt; &amp;lt;pubKey&amp;gt;&lt;/code&gt;，比特币脚本执行器从 PUSH 数据开始，PUSH 操作会读取第一个字节获取将要入栈的数据长度信息，然后持续执行比特币脚本，直到最后执行完毕检查执行结果。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;首先入栈的是 &lt;code&gt;&amp;lt;sig&amp;gt;&lt;/code&gt;，然后将 &lt;code&gt;&amp;lt;PubK&amp;gt;&lt;/code&gt; 入栈，一次DUP操作将在栈顶复制一份 &lt;code&gt;&amp;lt;PubK&amp;gt;&lt;/code&gt;，HASH160弹出栈顶的&lt;PubK&gt; 并计算Hash，将结果压回栈中，之后使用 EQUALVERIFY 弹出Hash对比是否和 &lt;PubKHash&gt;相等，如果相等则返回True，不相等便标记交易为无效。执行到这一步，暴露了公钥，确保了签名者的身份的正确性，但是黑客或矿工可以通过暴露的公钥构造出一个新的交易替换原始交易，无法保证安全，那么便需要下一步来保证交易无法伪造。此时栈上还有 &lt;code&gt;&amp;lt;PubK&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;sig&amp;gt;&lt;/code&gt;，执行 CHECKSIG，将校验数字签名的正确性，确保了签名者拥有地址对应的私钥。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;数字签名除了持有私钥的人，谁也无法伪造，执行至此，一笔比特币P2PKH交易已经安全地完成了。&lt;/p&gt;

&lt;p&gt;再解释一遍：当 Bob 要花费 Alice 给他的比特币时，Bob 只有用正确的钥匙才能打开 Alice 留给他的保险箱，把钱放入 Bob 新构造的一个保险箱里。&lt;/p&gt;

&lt;p&gt;这时候一些聪明的读者会注意到&lt;strong&gt;一个细节&lt;/strong&gt;：如果 Bob 取出钥匙，在还未打开保险箱的时刻，区块链上的任何矿工都能看得见这把钥匙的形状，理论上他们是可以立即复制一把钥匙，把 Alice 留给 Bob 的保险箱打开并花掉（俗称 Front-running 攻击）。真的可以这样做吗？&lt;strong&gt;显然中本聪考虑了这个问题&lt;/strong&gt;，这把钥匙中的交易签名是 Bob 发起的交易的完整签名。假设 Bob 要将 Alice 构造的保险箱中的比特币 装入一个新的保险箱（留给Charlie），这时候 Bob 出示的钥匙包含了 Charlie 的公钥Hash，矿工虽然可以复制 Bob 的钥匙，但是这把钥匙已经隐藏了下一个新保险箱的关键信息，因此矿工无法使用这个复制钥匙来完成别的动作（无法挪用数字签名）。&lt;/p&gt;

&lt;h2 id=&#34;p2sh-后中本聪时代的重大创新&#34;&gt;P2SH——后中本聪时代的重大创新&lt;/h2&gt;

&lt;p&gt;中本聪设计了一个这么强大的脚本系统，只用来构造转账交易似乎太浪费了，我们试试用其他指令构造一些特别的锁定脚本，并使用其他方式来解锁。&lt;/p&gt;

&lt;p&gt;例如我们可以构造一个用 Hash 原象（Pre-image）来解锁交易的脚本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;OP_HASH160
&amp;lt;Hash&amp;gt;
OP_EQUAL&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个脚本的含义是：当满足 &lt;code&gt;Hash160(Pre-image)==&amp;lt;Hash&amp;gt;&lt;/code&gt;这个条件时，便可成功将脚本解锁。&lt;/p&gt;

&lt;p&gt;我们继续通过保险箱的例子来解释，并给这类保险箱起名为 *3-类保险箱*。现在 Alice 给 Bob 的比特币锁定在一个由上述 &lt;code&gt;Hash160&lt;/code&gt;保护的保险箱里，我们姑且称之为哈希锁吧。&lt;/p&gt;

&lt;p&gt;这把锁依然需要正确的形状才能开启，但是安全性却弱很多，缺少数字签名机制导致钥匙隐藏的关键信息不会随着Bob 新建的保险箱而变化。任何矿工都能在 Bob 亮出钥匙的一瞬间复制出一摸一样的钥匙，抢着去开Alice留给Bob的保险箱（Front-running），将币转给另一个人 Eve，于是原本属于 Bob 的比特币会被洗劫一空。&lt;/p&gt;

&lt;p&gt;虽然这个脚本非常不安全，但是它却有两个非常神奇的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;交易构造的输出足够短，意味着比特币节点维护的 UTXO 缓存占用空间将会大大减小&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pre-image 总是在交易被花费时作为 input 来引用，不会在交易的 output 侧出现，UTXO依然保持精简，同时可以把手续费负担转嫁给接收方。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;既然所述的输出脚本好处很多，那我们是否有办法让这种交易方式变得安全呢？这就需要讲讲什么是 &lt;strong&gt;P2SH&lt;/strong&gt;了。&lt;/p&gt;

&lt;p&gt;比特币核心开发者 Gavin Adresen 提出了一种叫做 Pay to Script Hash (P2SH) 的技术。&lt;/p&gt;

&lt;p&gt;P2SH 的交易输出依然是判断 &lt;code&gt;Hash160(Script)==&amp;lt;Script Hash&amp;gt;&lt;/code&gt;，这里Script 就是上文中提到的 Pre-image 但是在判断完毕后又增加了一个步骤：使用比特币脚本执行器再次运行 Script 本身。&lt;/p&gt;

&lt;p&gt;比特币开发者为这类交易创建了特殊的地址，用 3 作为开头（0x05经过 Base58 编码后变为 3），地址生成规则为:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Base58(0x05 + &amp;lt;Script Hash&amp;gt; + Checksum)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样事情就变得有趣了，在前 P2SH 时代 Script 仅仅作为 Hash160 的原象存在，但是一旦激活了P2SH，Script 必须要求是一段有意义、可执行的比特币脚本。&lt;/p&gt;

&lt;p&gt;我们可以在 Script 中加入数字签名检查的指令，或者多重签名检查功能，甚至智能合约都可以在P2SH的基础上进行开发，既使用了强大的比特币脚本，又能让交易保持精简。&lt;strong&gt;并且由于 P2SH 交易地址中只存有 Script Hash，相当于保险箱上只有 Hash。&lt;/strong&gt;在交易被成功花费之前，任何人都无法知晓 Script 内容，很好的保护了隐私。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P2SH在2012年4月1日激活，开启了比特币的P2SH时代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在全世界的 &lt;em&gt;3-类保险箱&lt;/em&gt; 经过了升级，再也不怕钥匙被复制了，因为保险箱的钥匙会内置芯片。升级后的保险箱除了能够校验钥匙形状，更能读取钥匙中内置的芯片的数据，芯片中的内容会影响钥匙的形状。Bob制作了一个能够校验钥匙芯片中数字签名的保险箱，让Alice把钱放进这个保险箱然后锁起来。Bob开启保险箱的钥匙形状虽然可以被复制，但是这把钥匙内置了芯片，芯片中可以包含各种高级约束条件，保证钥匙不会被越权滥用。保险箱会在校验完形状后，会执行钥匙芯片内的程序查有效性，只有两个检查都通过才能开启保险箱。&lt;/p&gt;

&lt;h2 id=&#34;被锁死的币是否有挽回可能&#34;&gt;被锁死的币是否有挽回可能&lt;/h2&gt;

&lt;p&gt;再回到开头的那个问题，zer0to0ne 遇到的钱包错误锁死资产的事故，能否采用 &lt;em&gt;1-地址&lt;/em&gt; 的钥匙去开启 &lt;em&gt;3-保险箱&lt;/em&gt; ，挽救保险箱中的资产呢?&lt;/p&gt;

&lt;p&gt;这个问题可以解释为：Alice 按照 Bob 的要求制作了一个 *3-类保险箱*，但是这个保险箱是被 pywallet 错误修改的，实际上 Bob 的本意是需要一个 &lt;em&gt;1-类保险箱&lt;/em&gt; ，因为 Bob 手里只有一个&lt;em&gt;1-类保险箱&lt;/em&gt; 的钥匙。&lt;/p&gt;

&lt;p&gt;当 Bob 请求 Alice 把比特币锁定到 &lt;em&gt;3-类保险箱&lt;/em&gt; 时，这个保险箱就需要同时校验钥匙形状和钥匙芯片内容了，但是 Bob 的&lt;em&gt;1-类保险箱&lt;/em&gt; 的钥匙形状是 Public Key 决定的，在保险箱误变为 &lt;em&gt;3-类保险箱&lt;/em&gt; 后，钥匙形状校验却没有改变，也没有相应的钥匙芯片内容。&lt;/p&gt;

&lt;p&gt;Bob 尝试在钥匙芯片中写入Public Key，使得钥匙形状和锁匹配，但是芯片中的Public Key 却无法被保险箱正确执行，所以 Bob 可能再也无法将他的比特币从保险箱中解锁了。&lt;/p&gt;

&lt;h2 id=&#34;segwit-全新时代来临&#34;&gt;SegWit——全新时代来临&lt;/h2&gt;

&lt;p&gt;比特币开核心发者 Eric Lombrozo, Johnson Lau, Pieter Wuille 提出来了一种全新的概念，隔离见证（Segregated Witness，简称SegWit）。这是一种有效缓解比特币区块拥堵的技术，并且彻底解决了交易延展性问题（Transaction Malleability）。&lt;/p&gt;

&lt;p&gt;在SegWit升级之前，每一个用完的钥匙都插在保险箱上，钥匙占据了一定的体积导致仓库无法密集堆积这些用完的保险箱，总是要为了露在外面一大截的钥匙腾空间。那我们想想能不能把钥匙体积减小，并且用足够廉价的材料来制作，节约成本。&lt;/p&gt;

&lt;p&gt;于是便有了隔离见证（Segregated Witness简称SegWit），它干脆直接把锁从保险箱上移走，变成一个远程无线校验的保险箱，用户可以把钥匙统一插在远离保险箱的地方来远程开启对应的保险箱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2017年08月24日，SegWit软分叉被正式激活，结束了旷日持久的矿工开发者对峙&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了兼容3-类保险箱，比特币开发者使用了一种叫做P2SH-P2WPKH的技术，即通过P2SH来包裹P2WPKH交易，让P2WPKH交易可以骗过不支持SegWit的老旧节点。还有一种类似P2SH包裹的P2WSH技术（P2SH-P2WSH），在此不多做介绍。&lt;/p&gt;

&lt;p&gt;我们先来解释一下P2WPKH是什么：&lt;/p&gt;

&lt;p&gt;P2WPKH全称Pay to Witness Public Key Hash，相较于P2PKH，P2WPKH把scriptSig移动到交易外部，节省了占用的区块空间。&lt;/p&gt;

&lt;p&gt;为了向前兼容未及时升级的比特币节点，这个P2SH需要如何构造呢？&lt;/p&gt;

&lt;p&gt;Bob首先产生一个P2PKH地址，从地址中解析出PubKey Hash，然后构造一个这样的脚本：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Script = 0x0014 + &amp;lt;Pubkey Hash&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后计算Script的Hash160得到Script Hash，构造出一个3地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Base58(0x05 + &amp;lt;Script Hash&amp;gt; + Checksum)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当 Alice 把币锁定到 Bob 提供的  &lt;code&gt;&amp;lt;Script Hash&amp;gt;&lt;/code&gt;  中，意味着 Bob 需要提供正确的 Script 才能解锁。&lt;/p&gt;

&lt;p&gt;Bob通过构造有效的Script通过了Hash160检查，即成功的通过了钥匙形状检查，并且钥匙里的程序也能被保险箱正确解析并执行。&lt;/p&gt;

&lt;p&gt;细心的读者应该又发现了问题，这个钥匙却少了相关安全性约束，很容易被复制，（Front-running）矿工有机会将交易篡改，把币转给 Eve。&lt;/p&gt;

&lt;p&gt;但是升级了 SegWit 之后，支持 SegWit 的比特币节点会在校验 P2SH 后再额外地校验Bob的签名是否正确，数字签名作为独立于交易之外的安全约束，不再占用宝贵的区块空间。&lt;/p&gt;

&lt;p&gt;zer0to0ne：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SegWit 为比特币扩容做出了贡献的同时，也同时在保持向前兼容性上面付出了一些代价。在原生 SegWit 交易被广泛采用之前，使用了混乱的 P2SH 兼容技术。如果未来比特币全部统一到 &lt;em&gt;bc1-地址&lt;/em&gt; ，那么就可以彻底避免使用 P2SH 包裹技术，并且最大限度地利用区块容量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;对三个问题的回复&#34;&gt;对三个问题的回复&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;比特币地址有 1 打头地址 ，也有 3 打头的地址，你知道这两者有什么区别吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;1-地址&lt;/em&gt; 是用做 P2PKH 交易的目标地址，而 &lt;em&gt;3-地址&lt;/em&gt; 是用作 P2SH，SegWit交易的目标地址。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在哪种情况下，地址上的比特币会被锁死？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假设一个比特币地址为  &lt;em&gt;3-地址&lt;/em&gt; ，如果世界上没有人能够提供一个可以通过Hash160校验并有效可执行的脚本，那么这个地址上的比特币会被锁死。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;到底是谁拥有比特币的控制权，是你？还是你在使用的钱包？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果一个比特币地址为 &lt;em&gt;1-地址&lt;/em&gt; ，那么该地址上的比特币被锁在一个 &lt;em&gt;1-类保险箱&lt;/em&gt; 中，拥有私钥的用户拥有该地址上的比特币。这里请注意“拥有私钥”有两层含义：（1）自己牢记私钥，（2）其他人无从知晓。&lt;/p&gt;

&lt;p&gt;如果一个比特币地址为 &lt;em&gt;3-地址&lt;/em&gt; ，那么在某个用户披露一个“解锁脚本”之前，没人知道该地址上的比特币归属。因为脚本由钱包来生成的，而用户只“拥有私钥”，如果你不知道地址对应的脚本，就相当于交出了地址控制权。脚本的内容才真正决定了比特币的归属。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Fomo3D 千万大奖获得者“特殊攻击技巧”完全揭露</title>
      <link>https://sec-bit.github.io/blog/2018/08/23/how-the-winner-got-fomo3d-prize-a-detailed-explanation/</link>
      <pubDate>Thu, 23 Aug 2018 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2018/08/23/how-the-winner-got-fomo3d-prize-a-detailed-explanation/</guid>
      
        <description>

&lt;p&gt;Fomo3D 游戏第一轮正式结束，最终大奖由地址 0xa169 获得，奖金额高达 10,469.66 以太币。&lt;/p&gt;

&lt;p&gt;不少人轻易得出结论：获奖者平平无奇。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室昨日&lt;strong&gt;首个发现&lt;/strong&gt; Fomo3D 大奖获得者采取一些“特殊攻击技巧”，使得游戏临近结束时，矿工打包入区块内的交易数量骤减（涉及连续多个区块），从而起到&lt;strong&gt;加速游戏结束&lt;/strong&gt;和&lt;strong&gt;提高胜率&lt;/strong&gt;的作用。安比（SECBIT）实验室在 Last Winner 上轮游戏结束时也观察到了多个十分类似的异常区块和交易。&lt;/p&gt;

&lt;h2 id=&#34;一组连续的异常区块和交易&#34;&gt;一组连续的异常区块和交易&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;txns.jpg&#34; alt=&#34;连续区块交易数量骤降&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，高度为 6191896 的区块中打包了 Fomo3D 游戏中奖者最后购买 key 的交易，该区块共包含 92 笔交易，交易数量正常。&lt;/p&gt;

&lt;p&gt;而在该区块后的连续 11 个区块（6191898～6191908），每个区块包含交易数量都&lt;strong&gt;骤降&lt;/strong&gt;，最少的一个区块（6191906）&lt;strong&gt;仅包含了 3 笔交易&lt;/strong&gt;，十分异常。&lt;/p&gt;

&lt;p&gt;让我们来观察一下这些“特殊”的区块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;3txns-block.jpg&#34; alt=&#34;仅包含三笔交易的区块&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，高度为 6191906 的区块仅包含了 3 笔交易，并且交易均发往同一合约（调用同一个&lt;strong&gt;神秘合约&lt;/strong&gt;），三笔交易手续费之和&lt;strong&gt;超过 4 个以太币&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而该神秘合约（0x18e1）创建者正是中奖者（0xa169）！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过向 F2POOL 负责人确认我们得知，矿池挑选交易进入区块的策略为手续费（TxFee）高的优先。&lt;/p&gt;

&lt;p&gt;这也解释了为何上文提到的连续 11 个区块，都仅打包了很少量的交易，却能获得超出正常区块的手续费。这些区块分别由 SparkPool、Nanopool、Ethermine、BitClubPool、MiningPoolHub 等矿池打包，显然挑选高手续费交易优先打包，是符合矿池利益的策略，是行业通行的方案 [1]。&lt;/p&gt;

&lt;h2 id=&#34;黑客的-神秘合约-究竟做了什么&#34;&gt;黑客的“神秘合约”究竟做了什么？&lt;/h2&gt;

&lt;p&gt;安比（SECBIT）实验室观察到，这些异常区块内发往神秘合约（攻击合约）的异常交易，最终状态均为失败。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bad-instr.jpg&#34; alt=&#34;失败交易示例&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，交易最终状态为失败，并且 Etherscan 有 &lt;code&gt;Bad instruction&lt;/code&gt; 错误提示，最终导致耗光 Gas Limit (4200000)，约为正常区块 Gas Limit 的一半，因此打包该交易的矿池也收到了高额的手续费。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以太坊区块 Gas Limit 这一概念，代表单个区块中最多允许的 Gas 总量上限，以此来决定单个区块中具体打包多少笔交易。区块 Gas Limit 由矿工间通过一定策略协商设定，目前区块常见值约为 8000000 [2]。&lt;/p&gt;

&lt;p&gt;以太坊上每笔交易也包含一个 Gas Limit 概念，由交易发起者自行设定，代表该笔交易可最多消耗的 Gas 上限，实际 Gas 消耗以交易具体执行消耗为准。一个区块中所有交易花费的 Gas 不能超过区块的 Gas Limit [3]。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们知道，&lt;strong&gt;以太坊智能合约还存在一个指令 &lt;code&gt;assert()&lt;/code&gt;，用于断言。当 assert 的结果不满足条件时，则会耗光交易的 Gas。&lt;/strong&gt; Etherscan 针对这种情况的交易通常提示 &lt;code&gt;Bad instruction&lt;/code&gt;，实际则为 EVM 执行过程中遇到了一个未定义的操作符 &lt;code&gt;0xfe&lt;/code&gt; [4]。&lt;/p&gt;

&lt;p&gt;获奖者（黑客）就是利用这个特性，实现少量交易就能占用整个区块的 Gas Limit。&lt;/p&gt;

&lt;h2 id=&#34;黑客更犀利的操作&#34;&gt;黑客更犀利的操作&lt;/h2&gt;

&lt;p&gt;进一步，安比（SECBIT）实验室发现神秘合约会调用 Fomo3D 游戏的 &lt;code&gt;getCurrentRoundInfo()&lt;/code&gt; 接口，用于获取当前轮次比赛信息，如剩余时间、最后一位购买者的信息（最有可能获奖者）等奖池详尽信息（如下图）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;getCurRndInfo.jpg&#34; alt=&#34;getCurrentRoundInfo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;“神秘合约”并未公开源码，安比（SECBIT）实验室结合逆向结果推测，获奖者（黑客）通过神秘合约，在合约内调用该接口查询游戏信息，重点关注&lt;strong&gt;剩余时间&lt;/strong&gt;和&lt;strong&gt;最后一位购买者地址&lt;/strong&gt;。当游戏剩余时间达到一个阈值，并且最后一个购买者是自己时，则通过 &lt;code&gt;assert()&lt;/code&gt; 让整个交易失败，并耗光所有 Gas；当剩余时间很长或最后一个购买者不是自己时，则不做任何操作，仅消耗很少的 Gas。&lt;/p&gt;

&lt;p&gt;获奖者（黑客）就是利用这种方法，发起大量类似的&lt;strong&gt;可变神秘交易&lt;/strong&gt;：在自己极有可能成为中奖者时，利用这些高额手续费的神秘交易，&lt;strong&gt;吸引矿池优先打包，占满后续区块&lt;/strong&gt;，从而使得其他玩家购买 key 的交易无法被正常打包，最终加速游戏结束，并极大地提高自己的中奖概率。&lt;/p&gt;

&lt;h2 id=&#34;其他一些技巧和重要细节&#34;&gt;其他一些技巧和重要细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安比（SECBIT）实验室观察到 Fomo3D 获奖者（黑客）创建过多个类似神秘合约（攻击合约），并且前后曾使用很多不同地址向神秘合约发起交易，来分散大众注意力，降低自己的“特殊技巧”被发现的可能性。而每个攻击合约都有大量交易记录。上文提到的最终导致黑客获奖的攻击合约（0x18e1）有多达 5000 多笔交易，可见黑客暗地里做过不少尝试。&lt;/li&gt;
&lt;li&gt;获奖者（黑客）控制的地址批量调用神秘合约（攻击合约）时，会给交易设置各种 Gas Limit，从 170000 到 4800000 不等，这同样是一个技巧。如果你猜出黑客的用意，欢迎添加小安同学微信（secbit_xiaoanbi）回答，她会把你加入到「SECBIT 智能合约安全技术讨论」的群里。&lt;/li&gt;
&lt;li&gt;Fomo3D 获奖者（黑客）0xa169 最后一次购买 key 后（区块 6191896），连续十余个区块，都无任何与购买 Fomo3D 游戏 key 相关的交易，这才最终导致游戏倒计时结束，获得最终大奖。&lt;/li&gt;
&lt;li&gt;中奖区块的下一个区块（6191897），其实也包含大量异常交易，欢迎联系小安同学回答 :‑)。&lt;/li&gt;
&lt;li&gt;在游戏结束前，大众一直假想黑客可能会与大矿池联合作弊，拒绝打包竞争者交易来获得大奖，或者设想黑客可能发出大量垃圾交易使以太坊网络拥堵而无法打包竞争者交易，从而获利。&lt;/li&gt;
&lt;li&gt;这轮游戏的获奖者（黑客），&lt;strong&gt;并未联合多家矿池作恶&lt;/strong&gt;，反而巧妙&lt;strong&gt;利用了所有矿池优先挑选交易打包策略的共性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;获奖者（黑客）部署的神秘合约（攻击合约），简直是智能合约作为攻击武器的典范示例，精确制导，有的放矢。比起盲目地使用自动脚本在临近游戏结束时调高 Gas Price 发起参与游戏交易，黑客的攻击手法显然高明许多 。广播至各矿池的攻击交易，如导弹一般部署在内存池中，根据游戏状况，伺机而动。&lt;/li&gt;
&lt;li&gt;安比（SECBIT）实验室在 Last Winner 上轮游戏结束时也观察到了许多十分类似的异常区块和交易，手法十分接近。&lt;/li&gt;
&lt;li&gt;获奖者（黑客）创建的神秘合约，也正频繁与其他一些 Fomo3D 山寨游戏（如 Super Card）发生交易，企图使用同样的手法获得巨额大奖。&lt;/li&gt;
&lt;li&gt;哪有什么简单的“黑天鹅”，有的只是聪明且努力的黑客。「幂律分布」和「游戏缪误」了解一下 [5]。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;幸运的-f2pool-矿池&#34;&gt;幸运的 F2POOL 矿池&lt;/h2&gt;

&lt;p&gt;另外值得一提的是，两款游戏（Fomo3D、Last Winner）中奖交易最终均由 F2POOL 矿池打包出块，并且中奖者的上一笔参与游戏的交易，也均由 F2POOL 打包。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室与 F2POOL 矿池负责人仔细讨论过相关细节后，均初步认为这是巧合。F2POOL 矿池幸运地见证了两款热门智能合约游戏两笔巨额中奖交易的诞生。&lt;/p&gt;

&lt;h2 id=&#34;智能合约游戏路往何方&#34;&gt;智能合约游戏路往何方&lt;/h2&gt;

&lt;p&gt;安比（SECBIT）实验室之前还报道过 Last Winner 及其他 Fomo3D 山寨游戏中，黑客利用原版 Fomo3D 游戏中的空投漏洞，攫取大量奖励，以及 Fomo3D Quick 版本存在的问题。&lt;/p&gt;

&lt;p&gt;在感慨黑客利用特殊技巧获得高额回报之余，我们也不由地替各类智能合约游戏的未来产生担忧。&lt;/p&gt;

&lt;p&gt;Fomo3D 作为 2018 年最火爆的智能合约游戏，在玩法和技术上做了很多创新，是智能合约游戏历史上重要的一步。不可否认，Fomo3D 开发团队，有着过人的技术水平和强烈的去中心化情怀。&lt;/p&gt;

&lt;p&gt;Fomo3D 游戏刚出之初，不少人都惊呼，这是真正公平的去中心化游戏。但回到现实，依旧有黑客能发现当中的各类缺陷，并悄悄利用，获得可观的回报。&lt;/p&gt;

&lt;p&gt;技术的局限性、人性的贪婪、信息的不对称，都制约着一款真正安全、公平、透明的去中心化游戏的诞生。在 Fomo3D 出现之后，各类山寨游戏纷纷涌现，却没有在技术和创新上能走得更远，圈子氛围变得浮躁且嘈杂。&lt;/p&gt;

&lt;p&gt;作为区块链及智能合约爱好者，安比（SECBIT）实验室无比希望能尽快看到下一款安全、公平、优秀、有趣的智能合约游戏出现。&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1]: &lt;a href=&#34;https://ethereum.stackexchange.com/questions/15896/do-mining-pool-or-miners-decide-on-which-transaction-to-be-included-in-the-next&#34;&gt;https://ethereum.stackexchange.com/questions/15896/do-mining-pool-or-miners-decide-on-which-transaction-to-be-included-in-the-next&lt;/a&gt;, 2017/05/06&lt;/li&gt;
&lt;li&gt;[2]: Accounts, Transactions, Gas, and Block Gas Limits in Ethereum, &lt;a href=&#34;https://hudsonjameson.com/2017-06-27-accounts-transactions-gas-ethereum/&#34;&gt;https://hudsonjameson.com/2017-06-27-accounts-transactions-gas-ethereum/&lt;/a&gt;, 2017/06/27&lt;/li&gt;
&lt;li&gt;[3]: 科普 | 以太坊中的账户、交易、Gas 和区块 Gas Limit, &lt;a href=&#34;https://ethfans.org/posts/479&#34;&gt;https://ethfans.org/posts/479&lt;/a&gt;, 2017/07/03&lt;/li&gt;
&lt;li&gt;[4]: Revert(), Assert(), and Require() in Solidity, &lt;a href=&#34;https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e&#34;&gt;https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e&lt;/a&gt;, 2017/09/28&lt;/li&gt;
&lt;li&gt;[5]: 黑天鹅, &lt;a href=&#34;https://book.douban.com/subject/3025921/&#34;&gt;https://book.douban.com/subject/3025921/&lt;/a&gt;, &lt;sup&gt;2008&lt;/sup&gt;&amp;frasl;&lt;sub&gt;05&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上数据均由安比（SECBIT）实验室提供，合作交流请联系info@secbit.io。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;安比（SECBIT）实验室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室专注于区块链与智能合约安全问题，全方位监控智能合约安全漏洞、提供专业合约安全审计服务，在智能合约安全技术上开展全方位深入研究，致力于参与共建共识、可信、有序的区块链经济体。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室创始人郭宇，中国科学技术大学博士、耶鲁大学访问学者、曾任中科大副教授。专注于形式化证明与系统软件研究领域十余年，具有丰富的金融安全产品研发经验，是国内早期关注并研究比特币与区块链技术的科研人员之一。研究专长：区块链技术、形式化验证、程序语言理论、操作系统内核、计算机病毒。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Last Winner 的最后赢家 - 智能合约超大规模黑客攻击手法曝光</title>
      <link>https://sec-bit.github.io/blog/2018/08/20/last-winner-of-lastwinner/</link>
      <pubDate>Mon, 20 Aug 2018 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2018/08/20/last-winner-of-lastwinner/</guid>
      
        <description>

&lt;h1 id=&#34;last-winner-的最后赢家-智能合约超大规模黑客攻击手法曝光&#34;&gt;Last Winner 的最后赢家 - 智能合约超大规模黑客攻击手法曝光&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;安比（SECBIT）实验室创始人郭宇：2009年，中本聪创造了一个虚拟的去中心化新世界。这仿佛是一片流着奶和蜜糖的应许之地，人们欢呼雀跃，蜂拥而至。但与所有的生态系统一样，新世界有生命，就有捕食者。有交易者，就有黑客。区块链上的应用在进化，攻击者也同样，我们给大家展示的是区块链世界不为人知的另一面，暗流涌动。意料之外，也在意料之中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Last Winner（类 Fomo3D）游戏大火，导致以太坊异常拥堵，Gas 费用暴涨。大量以太币资金入场。&lt;/p&gt;

&lt;p&gt;北京时间 2018 年 8 月 10 日凌晨 1:38，加州时间 9 日上午 10:38，安比（SECBIT）实验室收到合作伙伴美国硅谷 AnChain.ai 公司消息，基于 AI 的态势感知系统发出预警信息，发现部分游戏合约出现大量交易并且存在异常的资金流动情况。安比（SECBIT）实验室的小伙伴赶紧根据最新线索，对相关合约和交易进行观察、跟踪、分析。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室由中国科学技术大学博士郭宇创建，从密码学、代码语义、形式化验证、博弈论、编译器等多种理论角度切入，在智能合约安全技术上开展全方位深入研究。&lt;/p&gt;

&lt;p&gt;AnChain.ai 由辛辛那提大学计算机博士方春生 Victor Fang 创建，方博士是硅谷上市网络安全公司 FireEye 史上第一位首席数据科学家，负责 AI 产品研发。AnChain.ai 专注安全威胁情报、区块链态势感知，凭借 AI 技术助力区块链生态安全。&lt;/p&gt;

&lt;p&gt;下文敏感地址只保留前 4 位。片尾有&lt;strong&gt;三个彩蛋&lt;/strong&gt;，智能合约爱好者请不要错过。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;hacker.png&#34; alt=&#34;hacker&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;悄然上线-莫名火爆的-last-winner&#34;&gt;悄然上线：莫名火爆的 Last Winner&lt;/h2&gt;

&lt;p&gt;Last Winner 是一款基于以太坊智能合约的 DApp 游戏，于 8 月 6 日上线，这款游戏一经推出，就“异常”火爆。&lt;/p&gt;

&lt;p&gt;这款游戏合约地址为 0xDd9fd6b6F8f7ea932997992bbE67EabB3e316f3C。据 Etherscan 显示，短短六天时间内，该游戏合约就已产生 27 万余笔交易。甚至前段时间以太坊网络大拥堵也与 Last Winner 游戏密切相关。8 月 8 日 和 9 日，在 Last Winner 和 Fomo3D 超大规模交易量的共同作用下，以太坊未确认交易数量创年内新高，平均 Gas 费用一度飙升至正常 10 倍以上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;gasprice.png&#34; alt=&#34;Gas Price&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该游戏第一轮奖池金额为 1.6 万多个以太币，而玩家总投资额更超过 10 万以太币，资金量巨大。目前游戏第一轮已结束，第二轮奖金池已迅速累积至 7000 多以太币。&lt;/p&gt;

&lt;p&gt;疯狂的现象级游戏背后&lt;strong&gt;暗流涌动&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;疑团重重-前期大量参与者的资金来历不明&#34;&gt;疑团重重：前期大量参与者的资金来历不明&lt;/h2&gt;

&lt;p&gt;据知名媒体「区块律动」报道，Last Winner 由名为「蚁群传播」的&lt;strong&gt;资金盘传销组织&lt;/strong&gt;推广运营，有着数量众多的会员和极强的推广拉下线能力 [1]。而据另一款火爆游戏 Fomo3D 开发团队称，Last Winner 是仿 Fomo3D 游戏，其背后运营团队准备了 20 万 ETH 来进行自动刷量交易。因此，Last Winner 游戏火爆的背后，可能是一场精心布局的传销游戏，初期利用机器人发起批量交易，伪造活跃假象，吸引新韭菜入场。&lt;/p&gt;

&lt;p&gt;Last Winner 游戏合约存在大量非正常交易，并且伴随着大量合约的创建与自毁，与正常人类调用行为特征偏离很大，这引起了我们的高度警惕。&lt;/p&gt;

&lt;h2 id=&#34;疯狂推广-只面向国人-合约源码却未公开&#34;&gt;疯狂推广：只面向国人，合约源码却未公开&lt;/h2&gt;

&lt;p&gt;在各大论坛、媒体、以及微信群中，都可以见到 Last Winner 游戏的推广文章，而这些文章有着类似的描述，并且都附上&lt;strong&gt;推广邀请码&lt;/strong&gt;。但 Last Winner 英文相关资料非常少。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;promo-post.png&#34; alt=&#34;推广文章&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显然，这是一款针对中国人的游戏，有着诱人的推广（&lt;strong&gt;拉下线&lt;/strong&gt;）奖励，因此在网络上广为传播。并且，这款游戏有适配安卓和 iPhone 手机的 App，简化了使用操作，降低了参与门槛。&lt;/p&gt;

&lt;p&gt;但是，十分可疑的是，作为一款基于智能合约的区块链游戏，Last Winner 居然没有公开合约源代码！这是一个非常危险的信号。为何这样一个游戏能这么火爆，吸引&lt;strong&gt;这么多人&lt;/strong&gt;参加？&lt;/p&gt;

&lt;p&gt;我们直觉上感到这款游戏到处透露着诡异的气息。&lt;/p&gt;

&lt;h2 id=&#34;安全性存疑-实则是-fomo3d-山寨版&#34;&gt;安全性存疑：实则是 Fomo3D 山寨版&lt;/h2&gt;

&lt;p&gt;Last Winner 官方宣传语写道：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Last Winner（LW）是首款完全去中心化的类 Fomo3D 游戏 DApp，完全基于以太坊智能合约原生开发。只要下载安装 App 就可参与游戏。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类 Fomo3D 游戏，且未公开源代码，这不得不让人产生怀疑。要知道，短短时间内原创开发一个好玩又&lt;strong&gt;安全&lt;/strong&gt;的 DApp 游戏难度非常大。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室迅速使用内部工具逆向分析了 Last Winner 的合约代码（字节码）。果不其然，这款游戏合约代码函数名称与 Fomo3D 高度相似，疑似直接拷贝（抄袭）了 Fomo3D 的源码，但却又新增了 10 余个可疑&lt;strong&gt;未知函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;尽管 Fomo3D 在 Etherscan 公开了源代码，但这并不代表它开源给任何人随意使用。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室之前报道过：在 Fomo3D 爆红之后，各类山寨版 Fomo3D 层出不穷。之前这些山寨版游戏往往复制 Fomo3D 官网和合约源码，并可疑地在一些地方进行修改。而 Last Winner 在此基础上更进一步，推出移动客户端，并疯狂推广，却不公开智能合约源代码。&lt;/p&gt;

&lt;p&gt;智能合约游戏或 DApp 的亮点之一就是公开透明。Last Winner 游戏则完全违背了这一点，动机十分可疑，参与该类游戏的风险极高！&lt;/p&gt;

&lt;p&gt;当时严峻的形势是：一方面有多个地址疑似疯狂发起攻击交易，另一方面项目方游戏合约未公开源码，高度可疑却吸引了巨量资金。我们感觉到态势十分紧急，于是迅速开展分工合作。AnChain.ai 中美团队日夜交替分析和监控异常交易，收集证据，定位攻击来源与攻击规模。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室的小伙伴们则兵分两路，分别开展对&lt;strong&gt;不透明游戏合约&lt;/strong&gt;和&lt;strong&gt;黑客攻击手法&lt;/strong&gt;的逆向分析。&lt;/p&gt;

&lt;h2 id=&#34;前情回顾-类-fomo3d-游戏空投机制存漏洞&#34;&gt;前情回顾：类 Fomo3D 游戏空投机制存漏洞&lt;/h2&gt;

&lt;p&gt;Fomo3D 游戏参与形式是用以太币购买游戏道具，除了最后一个购买的人可以获得巨额大奖外，平时参与者还有机会获得“空投”奖励。&lt;/p&gt;

&lt;p&gt;这里有主奖池和副奖池的概念，最终的巨额大奖和&lt;strong&gt;空投奖励&lt;/strong&gt;分别从从主奖池和副奖池中获取。&lt;/p&gt;

&lt;p&gt;所有进入游戏的以太币，有 1% 数量会进到副奖池。每一次购买道具都会有概率获得空投。空投的概率从 0% 开始，每增加一笔不小于 0.1 ETH 销售订单，空投概率会增加 0.1%。同时空投奖金额与购买金额也挂钩，如果购买 0.1 ~ 1 ETH，就有概率赢得 25% 副奖池奖金，购买更多则比例越大。&lt;/p&gt;

&lt;p&gt;一进入游戏界面，就会看到&lt;strong&gt;鲜明提示&lt;/strong&gt;，通知当前中奖概率和奖池金额。这一设计，原本是想增加游戏趣味性，并起到吸引资金入场、延长游戏时间的作用。但实际情况却并非如此。&lt;/p&gt;

&lt;p&gt;通过观察 LastWinner 游戏合约以及部分地址的异常交易行为，我们心中有了&lt;strong&gt;初步答案&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;让我们把时间退回到 20 多天前，&lt;strong&gt;早在 7 月 24 日&lt;/strong&gt;，安比（SECBIT）实验室和派盾（PeckShield）科技分别同时预警：Fomo3D 游戏的智能合约存在随机数漏洞可被利用，Fomo3D 及所有抄袭源码的山寨合约均存在该安全漏洞 [2]。原本设计上随机性较大的空投游戏可通过&lt;strong&gt;特殊手段操纵&lt;/strong&gt;，大大提高中奖概率。&lt;/p&gt;

&lt;p&gt;经安比（SECBIT）实验室字节码智能扫描工具逆向分析，Last Winner 游戏空投奖励代码与 Fomo3D 基本一致，相似度达 91%，可能存在同样漏洞。随着游戏火爆进行，机敏的黑客肯定也闻风而动。&lt;/p&gt;

&lt;h2 id=&#34;不能说的秘密-黑客制造秘密武器攫取高额收益&#34;&gt;不能说的秘密：黑客制造秘密武器攫取高额收益&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;lw-graph.png&#34; alt=&#34;攻击分析&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在区块链态势感知系统所展现出来的数据面前，我们不由地倒吸一口凉气。&lt;/p&gt;

&lt;p&gt;图中的这些可疑地址，如同“病毒”一般紧紧缠绕在 Last Winner 合约四周，肆意吞噬着 Last Winner 内的资金。&lt;/p&gt;

&lt;p&gt;我们观察到，图中紧靠 Last Winner 的这些地址，有着&lt;strong&gt;类似的行为模式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不停地往某合约地址上发起交易，同时附带 0.1 个以太币&lt;/li&gt;
&lt;li&gt;不少交易状态为失败&lt;/li&gt;
&lt;li&gt;成功的交易又会涉及大量“内部交易”&lt;/li&gt;
&lt;li&gt;“内部交易”调用逻辑十分复杂，并伴随大量合约的创建和自毁&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安比（SECBIT）实验室迅速得出初步结论：这些不明合约就是黑客用来攻击 Last Winner 的秘密武器，黑客正是通过这些合约，持续吸走 Last Winner 游戏内的以太币。&lt;/p&gt;

&lt;h2 id=&#34;案发现场-大量类似交易-超高回报率&#34;&gt;案发现场：大量类似交易，超高回报率&lt;/h2&gt;

&lt;p&gt;上面态势感知图中，&lt;strong&gt;占地面积最大&lt;/strong&gt;的嫌疑地址引起了我们的注意：0xae58，于是从这个地址展开了追踪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8 月 9 号当天&lt;/strong&gt;，0xae58 地址内以太币余额就以超过 300 个，而当时他正在大量往地址 0x5483 上发起交易，每笔交易转账金额都是 0.1 Ether。显然，黑客正通过 0x5483 智能合约向 LW 发起攻击。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;same-txn-in.png&#34; alt=&#34;来自不同地址的相同交易&#34; /&gt;&lt;/p&gt;

&lt;p&gt;让我们观察下面这条状态显示为成功的交易。表面上看是 0xae58 向攻击合约 0x5483 转了 0.1 Ether，实际却涉及了一大堆地址间的相互转账，最终随着 0x7c77 合约&lt;strong&gt;自毁&lt;/strong&gt;，0.189 个 Ether 转移回 0xae58 的账户中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;pwn-tx-example.png&#34; alt=&#34;成功攻击的交易&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这十分神奇，攻击者投入 0.1 个以太币，最终收获 0.189 个，&lt;strong&gt;瞬间回报率高达 89%&lt;/strong&gt;，简直暴利。&lt;/p&gt;

&lt;p&gt;我们很快发现，除了 0xae58 地址外，还有&lt;strong&gt;四个地址&lt;/strong&gt;也持续不断地向 0x5483 合约发起类似交易，持续获得高额回报。&lt;/p&gt;

&lt;p&gt;而失败的交易，仅消耗 27712 燃料（Gas），&lt;strong&gt;成本损耗十分低&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;研究目标立刻锁定为攻击合约 0x5483。由于无法获得源码，安比（SECBIT）实验室立刻使用内部工具展开逆向分析。&lt;/p&gt;

&lt;h2 id=&#34;暴利-数据面前我们再次震惊&#34;&gt;暴利：数据面前我们再次震惊&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;8 月 13 日&lt;/strong&gt;，当我们沉浸在研究黑客的攻击合约各种细节优化和精巧设计之时，黑客攻击数据全景分析新鲜出炉。&lt;/p&gt;

&lt;p&gt;其中，攻击获利最大的是以 0x820d 地址为首的团队。他们累计获利超过 5000 个以太币。AnChain.ai 团队和安比（SECBIT）实验室将该黑客团伙精确定位，并将其命名为 BAPT-LW20 (Blockchain APT – Last Winner)。&lt;/p&gt;

&lt;p&gt;BAPT-LW20 团队在短短 6 天时间内，共发送将近 5 万笔交易，从中攫取 5194 个 Ether，获利价值将近 1200 万人民币。&lt;/p&gt;

&lt;p&gt;由下图每小时发起的&lt;strong&gt;攻击交易数量趋势图&lt;/strong&gt;（下图），我们可以看出攻击的高峰期发生在 &lt;strong&gt;8 月 8 日 ～ 10 日&lt;/strong&gt;，每小时平均攫取将近 100 以太币，将近 22 万人民币。这正好也是 LW 游戏最火爆的时间段。随着游戏进入后期，入场资金急剧下降，收益降低，黑客也不得不也降低了攻击频率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;hour-txn.png&#34; alt=&#34;每小时发起的攻击交易数量&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再看看&lt;strong&gt;黑客每小时攫取以太币数量趋势图&lt;/strong&gt;（下图）。惨淡的漫漫熊市里，黑客却在狂赚以太币。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;lw-hourly-stolen.png&#34; alt=&#34;每小时被盗的ETH数量&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下图是“Last Winner 中黑客的交易量占比和攫取 ETH 占比”，可见黑客发送的交易量只占总交易量的 9.877%，但是却攫取了Last Winner奖金池中49%的奖金。黑客的娴熟攻击技能，为他们带来了普通玩家难以企及的好运，而普通玩家在这场游戏里面几乎很难获得空投奖励。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;lw-attack-txn-and-share.png&#34; alt=&#34;AnChain AI 预测&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;火线追凶-bapt-lw20-团队攻击-lw-始末&#34;&gt;火线追凶：BAPT-LW20 团队攻击 LW 始末&lt;/h2&gt;

&lt;p&gt;安比（SECBIT）实验室尝试追踪复原 BAPT-LW20 团队攻击时间线。&lt;/p&gt;

&lt;p&gt;下图是 BAPT-LW20 团队某账户余额变动情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;fomo-vs-lw.png&#34; alt=&#34;BAPT-LW20 某账户余额&#34; /&gt;&lt;/p&gt;

&lt;p&gt;0x820d 是 BAPT-LW20 团队所有攻击合约的部署者，也是攻击的实施者之一，可认为是 BAPT-LW20 团队的队长。0x820d 地址最早活跃于 &lt;strong&gt;7 月 20 日&lt;/strong&gt;，账户中的初始以太币均由 0x73B6 地址转入。而 0x73B6 也是同一天开始活跃的新地址，它的初始以太币来自总部位于美国旧金山的 Kraken 交易所。&lt;/p&gt;

&lt;p&gt;0x820d 在收到来自 0x73B6 的 10 个以太币后，随即部署了它的第一个合约。可能有些地方不太理想，他并没有继续使用该合约。&lt;strong&gt;三分钟后&lt;/strong&gt;，0x820d 部署下了第二个合约，攻击对象是 Fomo3D。在一组准备工作设置、若干次失败的调用以及两次虽然成功但却没有收益的尝试过后，0x820d 应该是发现了攻击合约里的 bug 和优化空间。&lt;/p&gt;

&lt;p&gt;在接下来的 &lt;strong&gt;14 个小时内&lt;/strong&gt;，他依次部署了 8 个合约进行攻击测试，无奈都不成功。终于在第 9 个合约 0xBad7 中首次完成攻击，以 0.1 ETH 的投入换回了 0.125 ETH。&lt;/p&gt;

&lt;p&gt;0xBad7 是 0x820d 团队首个可以正常工作的攻击合约，他们在 7 月 21 日至 7 月 23 日三天时间内总计调用该合约 11551 次，小有斩获。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7 月 23 日&lt;/strong&gt;，0x820d 又部署了新的合约，将攻击对象转移为另一款 Fomo3D 山寨游戏老鼠会 &lt;strong&gt;RatScam&lt;/strong&gt; (0x5167350d082c9ec48ed6fd4c694dea7361269705)，0x820d 团队在一天时间内使用了 2299 次攻击合约。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一天后&lt;/strong&gt;，0x820d 又找到了新目标，一个名为 &lt;strong&gt;FoMoGame&lt;/strong&gt;（0x86D179c28cCeb120Cd3f64930Cf1820a88B77D60） 的山寨游戏，部署新合约（0xb599）进行攻击。这款游戏知名度不高，入场资金并不多，黑客调用了 126 次之后就放弃。&lt;/p&gt;

&lt;p&gt;接下来的&lt;strong&gt;三天内&lt;/strong&gt;，0x820d 前后部署了 10 个新合约进行优化与攻击测试。&lt;/p&gt;

&lt;p&gt;终于，在 &lt;strong&gt;7 月 26 日&lt;/strong&gt;上线了他们的新版攻击合约（0x5483）。该合约总共发生过 23835 笔交易，最近一次活跃时间在 8 月 10 号（7 天前）。这款攻击合约，可由攻击者 &lt;strong&gt;自定义受害游戏合约地址&lt;/strong&gt;。因此 0x820d 在接下来的几天内，&lt;strong&gt;持续混合攻击 Fomo3D 原版、RatScam、FoMoGame 等游戏&lt;/strong&gt;，并持续观察其他山寨游戏的动态，等待时机。同时，继续部署若干个新合约进行调优测试。&lt;/p&gt;

&lt;p&gt;终于，&lt;strong&gt;8 月 6 日&lt;/strong&gt; Last Winner 游戏上线，&lt;strong&gt;24 小时后&lt;/strong&gt; 0x820d 团队就使用准备好的 0x5483 合约，针对 Last Winner 发起第一次攻击，并在接下来的 4 天内集中力量，疯狂利用空投漏洞展开攻势。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8 月 10 日&lt;/strong&gt;，0x820d 调用 0x5483 攻击合约 withdraw 接口，提走了里面的余额，攻击疑似暂停。&lt;/p&gt;

&lt;p&gt;原来，他们早已经部署了新版合约攻击合约 0x9C10，又发起了超过 30000 笔交易，至今仍在活跃攻击。&lt;/p&gt;

&lt;h2 id=&#34;不仅仅是空投-bapt-lw20-黑客团队拿走-lw-最终大奖&#34;&gt;不仅仅是空投：BAPT-LW20 黑客团队拿走 LW 最终大奖&lt;/h2&gt;

&lt;p&gt;北京时间 8 月 17 日上午，Last Winner 游戏第一轮最终结束，最终大奖由 0x5167 地址获得，奖金额总计 7,754 以太币。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;real-winner.png&#34; alt=&#34;最后的赢家&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而这个地址正是 BAPT-LW20 黑客团队的五个地址之一&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如下图，14 小时前，黑客还在利用&lt;strong&gt;攻击合约&lt;/strong&gt;获取空投奖励。随后，他改变了方案，直接用自身地址购买道具参与游戏，不断尝试夺取最终大奖。在此之后，又继续调用合约攻击 LW 游戏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;attack-and-play.png&#34; alt=&#34;临近游戏结束&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室猜测黑客潜伏很久，早已做好充分的准备，长时间利用脚本监控 LW 游戏状态，最终才能在众人放松警惕之时获得大奖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BAPT-LW20 黑客团队利用空投漏洞获利超 5,194 Ether，同时又夺取最终大奖 7,754 Ether，累计获利 12,948 Ether。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;同行相杀-zethr-团队两天时间就成功利用漏洞&#34;&gt;同行相杀：Zethr 团队两天时间就成功利用漏洞&lt;/h2&gt;

&lt;p&gt;这场超大规模的类 Fomo3D 智能合约游戏被攻击事件，攻击者使用的秘密武器也正是智能合约。&lt;/p&gt;

&lt;p&gt;据安比（SECBIT）实验室调查分析，0x20C9 地址最先成功利用原版 Fomo3D 空投漏洞并获取奖励。我们将他定位，并将其命名为 BAPT-LW10。&lt;/p&gt;

&lt;p&gt;0x20C9 于 &lt;strong&gt;7 月 8 日&lt;/strong&gt; 10 点 07 分创建了攻击合约 0xe7ce，在接下来的十分钟内，前后调用了三次，最终在第四次时成功获得奖励，投入 0.1 以太币，收回 0.19 个，回报率高达 90%（见下图）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;first-pwn-by-etherguy.png&#34; alt=&#34;最早成功利用漏洞的交易&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此后，0x20C9 继续部署多个攻击合约，进行调试优化。最终，在 &lt;strong&gt;7 月 23 日&lt;/strong&gt;部署了最终版本 0x39ac 攻击合约，接下来的时间前后调用过 90 余次，而攻击对象涉及 Fomo3D 原版、Last Winner 以及其他山寨版 Fomo3D。&lt;/p&gt;

&lt;p&gt;据我们观察，0x20C9 是最早研究并成功利用空投漏洞的黑客。研究过程中，安比（SECBIT）实验室发现 0x20C9 与另一款游戏 &lt;strong&gt;Zethr&lt;/strong&gt; 密切关联。&lt;/p&gt;

&lt;p&gt;最终我们在 Zethr 游戏合约代码中发现了他的身影。他是热门游戏 Zethr 的八位核心开发者之一，代号为 &lt;strong&gt;Etherguy&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;zethr-etherguy.png&#34; alt=&#34;zethr-etherguy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显然，作为 DApp 游戏开发同行，Etherguy 以及他所在的 Zethr 团队很早就研究了 Fomo3D 项目代码。Fomo3D 合约 7 月 6 日部署上主网，Etherguy &lt;strong&gt;两天后就发现并成功利用了漏洞&lt;/strong&gt;。从调用规模来看，Etherguy (BAPT-LW10) 应该主要还是出于研究目的，并没有太多获利。&lt;/p&gt;

&lt;p&gt;让其他黑客获利最多的正是 Last Winner 游戏。&lt;/p&gt;

&lt;h2 id=&#34;游戏细节-last-winner-为何让黑客如此疯狂&#34;&gt;游戏细节：Last Winner 为何让黑客如此疯狂&lt;/h2&gt;

&lt;p&gt;从最初 Fomo3D 上线后不久，空投漏洞就已被人发现并成功利用。随着游戏的广泛传播，以及该漏洞被逐渐披露，空投漏洞的攻击手段也在这一过程中不断升级进化，最终部分黑客团队完成了精巧的攻击方案，可低成本、高效率获得奖励，并可大规模工程化地攻击任意任何同类游戏合约，疯狂收割以太币。&lt;/p&gt;

&lt;p&gt;据安比（SECBIT）实验室分析，除 LW 游戏以外，不少黑客团队都曾尝试攻击其他类 Fomo3D 游戏合约。但获利都远小于 BAPT-LW20 团队在 LW 游戏中所得。&lt;/p&gt;

&lt;p&gt;我们试图从 LW 游戏本身寻找答案。&lt;/p&gt;

&lt;p&gt;LW 游戏是 Fomo3D 山寨版，本身没有太多创新，但入场资金完全集中在游戏开始后的&lt;strong&gt;第 2 天至第 5 天&lt;/strong&gt;内。巨量入场资金，会让游戏空投奖池迅速累积，因此这段时间也是黑客攻击的黄金时机。&lt;/p&gt;

&lt;p&gt;更要命的是，Last Winner 团队修改了空投游戏参数，使进入副奖池（空投奖池）的以太币比例&lt;strong&gt;由 1% 调整到 10%&lt;/strong&gt;，相当于空投奖励金高了 10 倍！&lt;/p&gt;

&lt;p&gt;一方面，游戏运营团队可能是利用高额空投奖励吸引用户疯狂加入；另一方面，他们可能并不知道空投漏洞的严重性，而提高奖励比例则会让该问题进一步放大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Last Winner 游戏简直成为了黑客的提款机！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;特别地，前面提到 Last Winner 游戏第一轮入场资金已达 10 万以太币，这也就是说，单单这一款游戏就有超过 1 万个以太币都持续暴露在被攻击的风险下，成为黑客的囊中之物。要知道，这款游戏第一轮最终奖池也才 1.6 万余以太币。本来空投奖励都是很小的金额，但黑客持续利用空投漏洞，积少成多，终成 Last Winner 最大赢家。&lt;/p&gt;

&lt;p&gt;我们追踪到有多个团队对 Fomo3D 及山寨合约开展大规模自动化攻击，企图攫取利益。&lt;/p&gt;

&lt;p&gt;而 BAPT-LW20 团队在游戏开始后 &lt;strong&gt;24 小时&lt;/strong&gt;左右就加入了战局，并迅速扩大作战规模，最终占得先机，获取巨额收益。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室追踪到还有其他黑客团队向 Last Winner 合约开展攻击。部分黑客 8 月 11 号以后才入局，虽规模也很大，但终究因为错过黄金时机而获利较少。&lt;/p&gt;

&lt;h2 id=&#34;攻击合约-设计复杂又精巧&#34;&gt;攻击合约：设计复杂又精巧&lt;/h2&gt;

&lt;p&gt;攻击合约 0x5483，创建于 7 月 26 日，创建者为 0x820D，同时也是持续调用攻击合约的五个地址之一。&lt;/p&gt;

&lt;p&gt;起初，攻击合约的创建时间让我们感到疑惑，前面提到 LW 游戏合约于 8 月 6 日才部署上主网。难道 0x820D 可以未卜先知，或者他与项目方有什么不可告人的秘密？&lt;/p&gt;

&lt;p&gt;带着这个疑问，我们尝试从合约 0x5483 的代码（字节码）中寻找答案。&lt;/p&gt;

&lt;p&gt;经过逆向发现，该合约有七个公开函数，其中一个疑似函数名是 &lt;code&gt;withdraw(uint256)&lt;/code&gt;，用于将攻击合约中积累的以太币转走。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室在字节码中发现了上面提到的五个地址。原来这两个函数都会跳转到同一个内部函数，检查交易发起人是否是这五人地址之一。如果是，则可继续执行，如果不是，则提前让交易失败。&lt;/p&gt;

&lt;p&gt;这也解释了为什么偏偏是这五个地址一直在调用攻击合约。&lt;strong&gt;因为他们是一个团队，合约特地为他们而设计，而其他人根本无法正常调用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;初步猜测，攻击合约这么设计是为了分散权限和资金，降低出问题或被发现的风险。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;pwn-calldata.png&#34; alt=&#34;传入参数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图正是一笔攻击交易的传入参数。第一部分是调用函数哈希 ID，后面跟着三个参数。注意看第一个参数，攻击者传入的明显是一个地址。显然，这个地址正是 LW 游戏合约地址。&lt;/p&gt;

&lt;p&gt;原来如此，攻击目标对象可以作为参数传入。“黑客真机智！”，我们不由地感慨。之前的一个困惑被解开，早在 LW 游戏上线前就已部署好的攻击合约 0x5483，其实是一个&lt;strong&gt;通用型武器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;继续研究，接下来合约的复杂程度出乎我们意料。我们沿着生成的控制流程图（CFG）追踪合约函数调用过程，程序指令以及&lt;strong&gt;分支情况&lt;/strong&gt;非常之多（下图是一小部分截图），让人难以完全跟上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;cfg.png&#34; alt=&#34;控制流程图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室使用动态追踪调试技术，结合逆向分析结果与攻击交易内部记录，搞清楚了黑客所使用的手法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;internal-txns.png&#34; alt=&#34;内部交易图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其他攻击交易也都是类似的过程，黑客调用攻击合约，攻击合约再调用提前创建好的合约，进而创建新的合约，以新合约的身份参与 LW 游戏，买游戏道具，然后几乎&lt;strong&gt;必定获得&lt;/strong&gt;空投奖励。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这一过程中不断新建的合约，就是态势感知系统中预警的大量异常合约创建与自毁。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;追踪攻击合约调用历史，发现攻击者在部署完攻击合约后，就立即多次调用特定函数，每次新建 10 个新合约。而函数总共恰好调用了 100 次，因此&lt;strong&gt;新建了 1000 个新合约&lt;/strong&gt;（记住这个细节）。&lt;/p&gt;

&lt;p&gt;在攻击交易中，攻击合约最先调用的就是这预先创建好的 1000 个合约之一，似乎是&lt;strong&gt;特地&lt;/strong&gt;从中挑选出来一个地址。&lt;/p&gt;

&lt;h2 id=&#34;智能合约-一切皆可预测&#34;&gt;智能合约：一切皆可预测&lt;/h2&gt;

&lt;p&gt;攻击函数控制流程图（CFG）中一个相隔很远的&lt;strong&gt;循环&lt;/strong&gt;引起了我们的注意。&lt;/p&gt;

&lt;p&gt;我们恍然大悟。攻击函数所做的就是不断循环地在 1000 个合约中，挑选“合适”的地址来完成下一步新建合约操作。所谓“合适”的地址，就是指能确保每次参与游戏都能获得空投奖励。&lt;/p&gt;

&lt;p&gt;前面提到，以太坊智能合约中可以很容易的预测随机数，因为随机数的来源都是区块或者交易中特定的一些公开参数，如交易发起者地址、区块时间戳、区块难度等等。因此空投游戏利用随机数来控制中奖概率是不可行的。&lt;/p&gt;

&lt;p&gt;而这里，黑客利用了另一个以太坊的特征，一个地址（账户）创建一个合约，合约地址是可按照特定规则计算得到的，任何人都可以根据已知信息进行推算。&lt;/p&gt;

&lt;p&gt;因此，黑客循环利用自己控制的 1000 个合约地址，推算各地址下一次新建的合约地址，而该地址恰恰是空投游戏中奖数字的随机源。攻击合约通过一系列预演推算来筛选出“合适”的地址来完成攻击操作（技术细节后文会详细讨论）。&lt;/p&gt;

&lt;p&gt;这才是黑客能够以超高概率获得空投的真正原因！&lt;/p&gt;

&lt;h2 id=&#34;技术流-攻击手法细节披露&#34;&gt;技术流：攻击手法细节披露&lt;/h2&gt;

&lt;p&gt;类 Fomo3D 游戏空投漏洞的根本原因在于，以太坊智能合约环境中难以生成无法预测的随机数。而 Fomo3D 开发者在其合约中增加了「判断调用者是普通人类还是合约」的逻辑来尝试规避，但此逻辑实现存在漏洞。黑客利用攻击合约提前预测随机数，并通过在构造函数内调用游戏合约的方法来伪装成普通人类（非合约）地址，从而大大增加自身中奖概率。&lt;/p&gt;

&lt;p&gt;时间再次回到 &lt;strong&gt;7 月 23 日&lt;/strong&gt;，以太坊基金会开发团队负责人之一 Péter Szilágyi 在 Reddit 上首次公开爆出这个漏洞并给出 1.0 版本的 POC 方案（详细可以参考引文 [3]）。这主要是利用了这些特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;空投游戏用来控制中奖概率的随机源，可被提前获得&lt;/li&gt;
&lt;li&gt;用户能否获得空投奖励以及奖励金额，可在另外一个合约中提前计算出来，从而决定后面的操纵逻辑&lt;/li&gt;
&lt;li&gt;Fomo3D 空投机制中尝试限制只有非合约地址（普通人类）才能参加游戏以防止上述情况的发生。但该判断方法存在漏洞，在构造合约的过程中（即合约构造方法里）参与游戏即可绕过该限制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此攻击者可以部署一个智能合约，并在合约的构造方法中计算出自己是否能够获益，如果能则投入以太币参加游戏空投获利，否则就不参加（参见下图）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./pwn-v1.png&#34; alt=&#34;第一版&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Péter 提出的这个方案只是一个最简单的原型，因为每次部署合约都要消耗不少 Gas，而且&lt;strong&gt;工作效率很低&lt;/strong&gt;且收益率并不高，采用该方案攻击，发起上千笔交易，都不一定能够真正获得空投奖励。&lt;/p&gt;

&lt;p&gt;看到这里你可能会有疑问，上文的攻击者似乎手法更高明，而且&lt;strong&gt;实际成功攻击的发生时间要早得多&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Zethr 开发者 Etherguy 早在 &lt;strong&gt;7 月 8 日&lt;/strong&gt;就已使用更高明的手法成功获利，解决了上文 &lt;strong&gt;1.0 方案&lt;/strong&gt;中的部分问题，我们姑且称之为 &lt;strong&gt;2.0 版本&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这个思路是通过&lt;strong&gt;合约循环创建子合约&lt;/strong&gt;（参见下图），直到子合约满足空投条件可以获利为止。这样做的好处是，在 Gas 充足的情况下，每次调用合约几乎一定可以获得收益，提高了工作效率。然而这种方案和 1.0 版本的攻击成本接近，并没有从本质上提高收益率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./pwn-v2.png&#34; alt=&#34;第二版&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而这次事件的最大获利者 BAPT-LW20 团队，就是在 2.0 版本的思路上进行了进一步优化&lt;strong&gt;降低了投入成本&lt;/strong&gt;，提高了收益率。 &lt;strong&gt;3.0 版本&lt;/strong&gt;则疯狂创建代理合约，通过利用计算下一步新建合约地址的技巧提前预判，筛选出符合条件的代理合约再创建出新的子合约，在子合约的构造函数中再完成上述攻击（见下图）。而且攻击目标地址可配置，可多人同时协作攻击。当游戏奖池金额不足以覆盖攻击成本时，发出的攻击交易会自动提前失败，仅消耗很低的 Gas 费用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./pwn-v3.png&#34; alt=&#34;第三版&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在分析各类攻击合约过程中，我们还见到另外一种更高明的做法：主攻击合约有着良好的设计模型，支持&lt;strong&gt;核心算法动态替换与升级&lt;/strong&gt;。原理上则是利用了 &lt;code&gt;delegatecall&lt;/code&gt; 进行操作。安比（SECBIT）实验室会持续关注这批黑客的动向。&lt;/p&gt;

&lt;h2 id=&#34;彩蛋一-空投与挖矿&#34;&gt;彩蛋一：空投与挖矿&lt;/h2&gt;

&lt;p&gt;我们知道在 PoW 挖矿的时候，矿工通常需要进行如下计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;nx&#34;&gt;BlockHash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Header&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Nonce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Check&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;BlockHash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Diff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当 BlockHash 结果小于当前难度值的时候，代表找到了一个合法的 Nonce。&lt;/p&gt;

&lt;p&gt;在 Fomo3D 的空投奖励里有着类似挖矿的机制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;airdrop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;view&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keccak256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;abi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;encodePacked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;add&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;difficulty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;add&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keccak256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;abi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;encodePacked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;coinbase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;add&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gaslimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;add&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keccak256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;abi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;encodePacked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;add&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))));&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;airDropTracker_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;用户唯一可以操纵的就是 &lt;code&gt;msg.sender&lt;/code&gt; 字段，我们是否可以将 &lt;code&gt;msg.sender&lt;/code&gt; 作为 Nonce 来挖矿呢？&lt;/p&gt;

&lt;p&gt;答案显然是可以的，智能合约的地址是根据 &lt;code&gt;发起者账户 + nonce&lt;/code&gt; 决定的，于是有了第 1 代方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;                       创建合约
用户（地址+nonce0） --------------------&amp;gt; 新合约（尝试攻击）
用户（地址+nonce1） --------------------&amp;gt; 新合约（尝试攻击）
用户（地址+nonce2） --------------------&amp;gt; 新合约（尝试攻击）
用户（地址+nonce3） --------------------&amp;gt; 新合约（尝试攻击）&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但是这种方式需要用户持续部署合约，消耗的矿工费代价非常大，且成功率极低，每次都是以 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1000&lt;/sub&gt; 的中奖概率在尝试。&lt;/p&gt;

&lt;p&gt;由于第 1 代惊人的失败率，显然无法利用，于是有了第 2 代攻击方法：&lt;/p&gt;

&lt;p&gt;这种方法的主要思想是，合约创建的新合约地址由 &lt;code&gt;合约地址+nonce&lt;/code&gt; 确定：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;      部署合约    |------------------| hash(caddr, nonce)
用户 ----------&amp;gt; |循环创建合约，      | -------&amp;gt; 新合约（尝试攻击）
                 |直到攻击成功或到达终 | -------&amp;gt; 新合约（尝试攻击）
                 |止条件才停止，可能需 | -------&amp;gt; 新合约（尝试攻击）
                 |要部署大量合约。    | -------&amp;gt; 新合约（尝试攻击）
                 |----------------- |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种方式类似于挖矿，固定区块头部，不断修改 nonce 来试探能否成功获得奖励，但是问题在于，如果在循环第 1000 次才发现合法的 nonce，那么意味着之前部署的 999 个合约都属于浪费 Gas 的操作。&lt;/p&gt;

&lt;p&gt;那么如何更高效地寻找合法的 nonce 呢？&lt;/p&gt;

&lt;p&gt;我们回想比特币挖矿，一个挖矿任务中，不仅有 nonce，还有 extraNonce [4]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bitcoin.png&#34; alt=&#34;比特币挖矿&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在比特币区块的 Coinbase 字段中，有一个自由修改的区域，修改这个区域会导致 MerkleRoot 被修改，从而实现 Header 被修改，具有 nonce 的效果，因此被称作 extraNonce。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为什么需要引入 extraNonce 呢？原因在于 nonce 为 32 bit 数字，搜索范围只有 2^32，矿机几乎一瞬间就遍历完了，通过不断修改 extraNonce 来扩大本地搜索范围，我们甚至可以不修改 nonce 只修改 extraNonce 来挖矿。&lt;/p&gt;

&lt;p&gt;也许黑客也想到了这一点，他们通过提前部署 1000 个代理合约来实现有 1000 个 extraNonce 的效果。
至此，攻击方法升级到了第 3 代：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;                    部署合约
用户 --------------------------------------&amp;gt; 管理合约 C

      调用合约C，预先创建代理合约(extraNonce)
用户 --------------------------------------&amp;gt; 1000个代理合约

      调用合约C，循环尝试可以成功攻击的代理合约
用户 --------------------------------------&amp;gt; 部署合约(尝试攻击)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;显而易见，这种攻击方式同时实现了 2 个效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提升了攻击成功率&lt;/li&gt;
&lt;li&gt;减少了攻击合约部署数量，大大减少了 Gas 消耗。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;彩蛋二-黑客预先创建的合约数量与中奖概率&#34;&gt;彩蛋二：黑客预先创建的合约数量与中奖概率&lt;/h2&gt;

&lt;p&gt;前文提到黑客预先部署 1000 个代理合约，这个数字有什么讲究呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;airDropTracker_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;seed 经由一系列以太坊链上环境以及多次 Hash 运算得出。Hash 结果对 1000 取余数，可以得到 0～999 的伪随机数。&lt;/p&gt;

&lt;p&gt;我们假设哈希输出结果是均匀的，并且哈希是抗碰撞的，那么平均每次中奖的概率为 1/1000。&lt;/p&gt;

&lt;p&gt;模拟结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;probability-sim.png&#34; alt=&#34;模拟结果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;公式运算结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;probability-calculate.png&#34; alt=&#34;公式运算结果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;尽管更多合约能够提供更高的中奖概率，但是需要考虑到 Gas 消耗与 Gas Limit 等因素，不宜过大。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室认为黑客选择部署 1000 个合约，是根据概率代码 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1000&lt;/sub&gt; 想当然做出的判断。&lt;/p&gt;

&lt;h2 id=&#34;彩蛋三-黑客可能利用了空投概率计算的另一个-bug&#34;&gt;彩蛋三：黑客可能利用了空投概率计算的另一个 bug&lt;/h2&gt;

&lt;p&gt;黑客仍然需要更高效地攫取利润，他们甚至“发现”了 Fomo3D 空投规则在这种攻击方式下暴露出的缺陷。&lt;/p&gt;

&lt;p&gt;攻击合约需要在最开始获取空投奖励信息，作为后续操作的依据。因此，攻击合约会先依次调用游戏合约的两个查询接口，分别是 &lt;code&gt;0xd87574e0 airDropPot_()&lt;/code&gt; 和 &lt;code&gt;0x11a09ae7 airDropTracker_()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Fomo3D 空投奖励的 &lt;code&gt;airDropTracker_&lt;/code&gt; 计算方式为如下方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_eth&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000000000000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;airDropTracker_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;airdrop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Fomo3D 判断是否能中空投奖励使用了如下方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;airDropTracker_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;根据我们分析，0x820d 后期更新的攻击合约直接去除了对 &lt;code&gt;airDropTracker_&lt;/code&gt; 的判断，但这样做其实&lt;strong&gt;有利有弊&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果你了解细节，猜出了黑客的用意，或者知晓这种做法的优缺点，欢迎添加小安同学微信（secbit_xiaoanbi），她会把你加入到「SECBIT 智能合约安全技术讨论」的群里。&lt;/p&gt;

&lt;h2 id=&#34;尾声-下一个是谁&#34;&gt;尾声：下一个是谁？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;8 月 14 日&lt;/strong&gt;，BAPT-LW20 黑客团队的 0x820d 再次部署了两个新版攻击合约，这一次他们将炮筒又对准了另一款一天前新部署的不知名合约。&lt;/p&gt;

&lt;p&gt;望着大屏幕上 AnChain.ai 态势感知态势感知平台不断闪烁的红点，安比（SECBIT）实验室和 AnChain.ai 都很清楚，区块链世界里的战役还远远没有结束。&lt;/p&gt;

&lt;p&gt;2009年，中本聪创造了一个虚拟的去中心化新世界。这仿佛是一片流着奶和蜜糖的应许之地，人们欢呼雀跃，蜂拥而至。但与所有的生态系统一样，新世界有生命，就有捕食者。有交易者，就有黑客。区块链上的应用在进化，攻击者也同样，我们给大家展示的是区块链世界不为人知的另一面，暗流涌动。意料之外，也在意料之中。&lt;/p&gt;

&lt;h2 id=&#34;bapt-lw20-bapt-f3d-大事件时间表&#34;&gt;BAPT-LW20 &amp;amp; BAPT-F3D 大事件时间表：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2018/07/06 Fomo3D 游戏合约上线&lt;/li&gt;
&lt;li&gt;2018/07/08 Zethr 核心开发者 Etherguy 发现并利用空投漏洞&lt;/li&gt;
&lt;li&gt;2018/07/20 Fomo3D 游戏在国内走红&lt;/li&gt;
&lt;li&gt;2018/07/20 BAPT-LW20 黑客团队地址开始活跃&lt;/li&gt;
&lt;li&gt;2018/07/21 BAPT-LW20 团队第一次成功利用 Fomo3D 空投漏洞&lt;/li&gt;
&lt;li&gt;2018/07/23 BAPT-LW20 团队攻击山寨游戏⽼鼠会 RatScam&lt;/li&gt;
&lt;li&gt;2018/07/23 Péter 在 Reddit 爆料 Fomo3D 空投漏洞&lt;/li&gt;
&lt;li&gt;2018/07/24 安比（SECBIT）实验室发布 Fomo3D 及山寨版游戏空投漏洞预警&lt;/li&gt;
&lt;li&gt;2018/07/24 BAPT-LW20 黑客团队攻击 FoMoGame&lt;/li&gt;
&lt;li&gt;2018/07/26 BAPT-LW20 黑客团队部署新版攻击合约 0x5483&lt;/li&gt;
&lt;li&gt;2018/08/06 类 Fomo3D 游戏 Last Winner 上线&lt;/li&gt;
&lt;li&gt;2018/08/07 LW 游戏开始火爆&lt;/li&gt;
&lt;li&gt;2018/08/07 BAPT-LW20 黑客团队开始攻击 LW 游戏&lt;/li&gt;
&lt;li&gt;2018/08/09 以太坊未确认交易数创年内新高&lt;/li&gt;
&lt;li&gt;2018/08/10 凌晨 AnChain.ai 态势感知系统发出预警&lt;/li&gt;
&lt;li&gt;2018/08/10 安比（SECBIT）实验室与 AnChain.ai 联手开展调查&lt;/li&gt;
&lt;li&gt;2018/08/10 BAPT-LW20 黑客团队转移旧合约中资金，使用新版合约继续开展攻击&lt;/li&gt;
&lt;li&gt;2018/08/11 完成 BAPT-LW20 攻击时间线复原&lt;/li&gt;
&lt;li&gt;2018/08/12 完成 BAPT-LW20 攻击手法复原&lt;/li&gt;
&lt;li&gt;2018/08/13 针对更多攻击源分析&lt;/li&gt;
&lt;li&gt;2018/08/13 完成 BAPT-F3D 和 BAPT-LW20 攻击数据全景分析，黑客获利超 5000 Ether&lt;/li&gt;
&lt;li&gt;2018/08/14 BAPT-LW20 黑客团队再次部署新版攻击合约，开始攻击一个不知名合约&lt;/li&gt;
&lt;li&gt;2018/08/17 BAPT-LW20 黑客团队夺取 LW 最终大奖 7754 Ether&lt;/li&gt;
&lt;li&gt;2018/08/17 安比（SECBIT）实验室完成 BAPT-LW20 攻击事件报告&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] 区块律动：8万笔交易「封死」以太坊网络，只为抢夺Fomo3D大奖？&lt;a href=&#34;https://mp.weixin.qq.com/s/5nrgj8sIZ0SlXebG5sWVPw&#34;&gt;https://mp.weixin.qq.com/s/5nrgj8sIZ0SlXebG5sWVPw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] Pwning Fomo3D Revealed: Iterative, Pre-Calculated Contract Creation For Airdrop Prizes!, &lt;a href=&#34;https://peckshield.com/2018/07/24/fomo3d/&#34;&gt;https://peckshield.com/2018/07/24/fomo3d/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] Péter Szilágyi 提出的空投漏洞利用 POC，&lt;a href=&#34;https://www.reddit.com/r/ethereum/comments/916xni/how_to_pwn_fomo3d_a_beginners_guide/&#34;&gt;https://www.reddit.com/r/ethereum/comments/916xni/how_to_pwn_fomo3d_a_beginners_guide/&lt;/a&gt;, 2018/07/23&lt;/li&gt;
&lt;li&gt;[4] AsicBoost - A Speedup for Bitcoin Mining, &lt;a href=&#34;https://arxiv.org/pdf/1604.00575.pdf&#34;&gt;https://arxiv.org/pdf/1604.00575.pdf&lt;/a&gt;, 2016/03/31&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上数据均由安比（SECBIT）实验室和 AnChain.ai 提供，合作交流请联系info@secbit.io。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;安比（SECBIT）实验室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室专注于区块链与智能合约安全问题，全方位监控智能合约安全漏洞、提供专业合约安全审计服务，在智能合约安全技术上开展全方位深入研究，致力于参与共建共识、可信、有序的区块链经济体。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室创始人郭宇，中国科学技术大学博士、耶鲁大学访问学者、曾任中科大副教授。专注于形式化证明与系统软件研究领域十余年，具有丰富的金融安全产品研发经验，是国内早期关注并研究比特币与区块链技术的科研人员之一。研究专长：区块链技术、形式化验证、程序语言理论、操作系统内核、计算机病毒。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>从世界杯小组赛消极比赛，到矿工博弈及共识算法，博弈论解释了一切</title>
      <link>https://sec-bit.github.io/blog/2018/08/03/worldcup-miner-dilemma/</link>
      <pubDate>Fri, 03 Aug 2018 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2018/08/03/worldcup-miner-dilemma/</guid>
      
        <description>

&lt;p&gt;博弈论被认为是20世纪经济学最伟大的成果之一，其思想被广泛的应用到经济学，政治学，计算机科学，生物学，运筹学等学科。通过分析博弈各方的收益情况而对参与者的行为进行预测，博弈论已经被应用于处理国际关系、研究军事战略、制定公司经营策略等领域。诺贝尔经济学奖获得者约翰.纳什(John F. Nash)在他的博士论文中提出的“纳什均衡”概念，完全颠覆了传统经济学家的固有观念，因此“纳什均衡”对经济学的影响被类比为“DNA双螺旋结构对生物科学的影响”。纳什均衡提供了一种分析社会和经济参与者行为的工具，安比(SECBIT)实验室的研究员利用均衡的概念来揭示世界杯比赛中消极比赛、比特币系统中矿工挖矿博弈，以及共识系统所面临的挑战背后所蕴含的均衡模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;johnnash.jpg&#34; alt=&#34;alt text&#34; title=&#34;约翰纳什&#34; /&gt;&lt;/p&gt;

&lt;p&gt;6月26日，第21届世界杯小组赛C组法国对战丹麦队的比赛由于两个国家队踢默契球而引起了球迷的抱怨，安比(SECBIT)实验室的研究人员通过博弈论的分析方法来讨论比赛规则对球队行为的影响，从而说明规则会影响参与者的行为。接着，我们描述了在比特币挖矿的情境下，矿池之间存在的博弈现象。最后，我们讨论了比特币系统共识算法所面临的潜在威胁。通过对这些实例的分析，安比(SECBIT)实验室希望将博弈论的思想引用到智能合约的部署中，当开发人员在设计有多个参与者参加的智能合约时，通过添加智能合约的博弈论属性来预测参与者的行为。&lt;/p&gt;

&lt;h2 id=&#34;世界杯消极比赛与重复剔除的占优战略均衡&#34;&gt;世界杯消极比赛与重复剔除的占优战略均衡&lt;/h2&gt;

&lt;p&gt;在世界杯小组赛中，每个小组有4支球队，通过互相比赛最终两支获得最高分数的球队出线进入下一轮，小组赛的得分规则是：赢一场得3分，平局的话两队各得1分，输的队伍得0分。如果两支队伍积分相等，出线队伍通过比较净胜球和红黄牌数量来决定。&lt;/p&gt;

&lt;p&gt;世界杯C组有四支队伍：法国，丹麦，秘鲁和澳大利亚。在法国队和丹麦队比赛之前，法国队已经战胜澳大利亚和秘鲁，得到了6分，丹麦队战胜秘鲁，打平澳大利亚积4分，澳大利亚积1分，秘鲁两场全输积0分。具体赛况如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;Score.png&#34; alt=&#34;alt text&#34; title=&#34;赛前积分示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;C组还剩下两场比赛，分别是丹麦对战法国，澳大利亚对战秘鲁。&lt;/p&gt;

&lt;p&gt;在这个前提下，我们画了下面的收益图来表示丹麦对战法国的比赛的可能结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;France.png&#34; alt=&#34;alt text&#34; title=&#34;纳什均衡示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，有两个参赛队伍法国和丹麦，每个参赛队伍有两个策略：积极比赛和消极比赛。消极比赛中，每个球队的重点不在于如何积极地发动进攻获得进球，而是将比赛的重心放在如何消磨时间上，比如持续在后场传球。还有就是派遣替补队员上场，让主力球员休息从而避免意外受伤。&lt;/p&gt;

&lt;p&gt;在这张图表中有四个状态组合，第一个状态（积极，积极）表示两个队都积极地应对比赛，这个状态下丹麦队的收益是 $( 0.75 - \epsilon )$，$( 0.75 )$ 表示丹麦队有较大的可能性出线，$( \epsilon )$ 是一个很小的小数，它表示的意思是队伍中的队员由于获得黄牌或者受伤而需要付出的代价。法国队的收益是$( 1 - \epsilon )$，这表示虽然法国队出线了，但是球队队员由于受伤或者黄牌而导致收益下降。&lt;/p&gt;

&lt;p&gt;第二个状态（积极，消极）表示丹麦队积极比赛，而法国队消极比赛，在这种情况下，丹麦队获胜的可能性大大的增加，但是由于需要付出相应的代价，丹麦队的收益成为$( 1 - \epsilon )$。法国队由于以前的两场比赛均获得了胜利，因此无论这场比赛是输是赢都会出线，因此法国队的收益为1.&lt;/p&gt;

&lt;p&gt;第三个状态（消极，积极）表示丹麦队消极比赛而法国队积极比赛，这样丹麦队输掉比赛的概率很大，是否出线会受到澳大利亚和秘鲁比赛结果的影响，因此我们设置其收益为$( 0.5 )$，与此同时，由于法国队积极比赛会付出代价，因此法国队的收益为$( 1 - \epsilon )$。&lt;/p&gt;

&lt;p&gt;第四个状态（消极，消极）表示两队都消极比赛，在此状态下，由于平局两队都可以增加积分，这样无论澳大利亚和秘鲁的比赛结果如何，法国和丹麦都会出线，因此我们设置两队的收益都为1.&lt;/p&gt;

&lt;p&gt;观察本次比赛的收益图可以发现，对于法国队而言，无论采取什么策略都可以出线，但是积极比赛会让其损失$(\epsilon)$的收益。因此消极比赛是法国队的占优战略。我们假设法国队是理性的，因此法国队会&lt;strong&gt;剔除自己的劣势策略&lt;/strong&gt;：“积极”，而选择对自己最有利的策略：消极比赛。我们同样假定丹麦队是理性的，他会正确的预测到法国队会选择消极比赛，在此状况下，丹麦队获得最大收益的策略也是消极比赛。在实际比赛中，法国队让替补队员首发上场比赛，这无疑给了丹麦队一个消极比赛的信号，因此丹麦队会做出消极比赛的决定。&lt;/p&gt;

&lt;p&gt;在本次博弈中，状态（消极，消极）是一个纳什均衡状态。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;纳什均衡：在一个状态下，没有一个参与者可以在独自改变策略的情况下增加自己的收益。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来我们将会运用相同的分析方式来描述比特币挖矿系统中所存在的均衡现象。&lt;/p&gt;

&lt;h2 id=&#34;矿工博弈&#34;&gt;矿工博弈&lt;/h2&gt;

&lt;p&gt;比特币系统的安全性依赖于其自身所具有的稳定的激励规则，这个激励系统所运用的底层数据结构是区块链，区块链中记录了所有比特币的交易记录，因此区块链可以被认为是一个在分布式系统中维护的一个全局账本。由于区块链的开放性，任何人都可以加入到这个系统中，比特币系统中的参与者（即矿工），需要通过提供代价高昂的计算来提供工作量证明（Proof of Work）来产生新的区块，矿工产生新的区块的过程被称为挖矿。当一个矿工完成了比特币系统所要求的工作量证明，一个新的区块会被添加到原有的区块链当中，提供工作量证明的矿工会得到相应的比特币奖励。随着比特币系统的发展，其中所运用的激励规则被认为是稳定且可扩展的。&lt;/p&gt;

&lt;p&gt;由于比特币的市值很高，越来越多的矿工加入到挖矿的队列，为了保证每个区块的创立时间保持基本恒定（每10分钟产生一个新的区块），比特币系统在不断地调整挖矿的难度。因此计算能力小的矿工很难依靠自己的算力生成新的区块，这就导致矿工会选择加入其它挖矿的机群，从而聚集成一个&lt;strong&gt;矿池&lt;/strong&gt;一起进行挖矿，如果这个矿池成功的生成一个新的区块，即完成工作量证明（Proof of Work），这个区块所得到的比特币奖励会根据每个矿工的贡献进行分配。&lt;/p&gt;

&lt;p&gt;在一个矿池中，会有一个管理员和诸多矿工，管理员负责分配和监督矿工进行工作。如果有一个矿工完成了一个工作量证明（Proof of Work）,管理员会将其发布到网络中并且将新区快添加到区块链中。为了对矿工进行管理，管理员每隔一段时间会要求矿工矿工向其提交部分工作量证明(partial Proof of Work)。通过这个检查机制，管理员一方面可以确认所有的矿工都在为挖矿而工作，另一方面也可以评估每个矿工的工作量，从而计算矿工的收益。有些矿池为了增加自己的算力，会公开自己的服务器接口，其他矿工只需要注册便可以加入矿池，接收挖矿任务，进而发送工作量证明给管理员，当这个矿池创造出新的区块，每个矿工根据自己贡献的大小获得利润分成。&lt;/p&gt;

&lt;h3 id=&#34;区块截留攻击&#34;&gt;区块截留攻击&lt;/h3&gt;

&lt;p&gt;在正常状况下，不同的矿池各自独立挖矿，独自分享挖矿的收益。然而，一个矿池（A）可以对另一个矿池（B）发动攻击，矿池A将其中的一部分矿工注册到矿池B,这些矿工像正常矿工一样接收矿池B管理员所分发的挖矿任务，然后入侵的矿工会开始挖矿，如果他们完成了部分工作量证明任务，他们会将这些信息发送给管理员。但是，如果他们完成了一个完整的工作量证明，他们会选择丢弃该信息，拒绝向管理员发送工作量证明。由于入侵矿工会向管理员发送部分工作量证明，他们会被管理员认定为正常矿工，并且在该矿池其他矿工创建新的区块链的时候得到利润分成，因此攻击者可以获得被入侵的矿池的收益。一个矿池可以通过比较期望收益和实际收益的差异来确定自己是否受到攻击，但是由于每个矿工所要完成的部分工作量证明的任务相对较小，矿池管理员很难判断出到底是哪个矿工发起了攻击。&lt;/p&gt;

&lt;p&gt;为了衡量一个矿池的挖矿效率，我们提出了一个衡量标准：
&amp;gt; 收益密度：一个矿池的收益密度是矿池中每个矿工的平均收益与每个矿工单独挖矿所获得收益的比率。&lt;/p&gt;

&lt;p&gt;显而易见，一个矿池的收益密度越高，其获得的收益就相对更多。一个没有受到攻击的矿池的收益密度是1，而一个受到攻击的矿池的收益密度会小于1。&lt;/p&gt;

&lt;p&gt;现在我们构建一个具有两个矿池的博弈模型，在这个模型中，我们假设除了矿池A和矿池B之外的所有矿工均独自挖矿。而且矿池A和矿池B的运算能力并没有超过整个系统中运算能力的50%。每个矿池都可以设置自己的攻击比率，即在自己所有的矿工中选择一定数量的矿工作为入侵矿工，矿池可以根据自己的算力来调整自己的攻击比率，从而最大化自己的收益。&lt;/p&gt;

&lt;p&gt;我们设定$r_a$为矿池A的收益密度，$r_b$为矿池B的收益密度。$r^{\prime}_b$是矿池B在受到矿池A攻击而不做出反击的情况下的收益密度，$r^{\prime}_a$是矿池A在受到矿池B攻击而不做出反击的情况下的收益密度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;twominer.png&#34; alt=&#34;alt text&#34; title=&#34;矿工博弈1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当矿池A受到矿池B的攻击，其收益会下降，当矿池A发起反击的时候，他的收益会上升，而矿池B的收益会下降。为了更直观的表示两个矿池的博弈过程，我们特意构造了一个更为直接的博弈模型，见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;miner_dilemma.png&#34; alt=&#34;alt text&#34; title=&#34;矿工博弈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上图所示的博弈中，对于矿池B而言，当矿池A选择攻击时，矿池B同样选择攻击会获得0.8的收益密度，如果矿池B不选择反击，他只会获得0.7的收益密度，所以当矿池A发动攻击时，矿池B应当选择反击；当矿池A选择不攻击时，如果矿池B选择攻击，他会获得1.25的收益密度，这个收益要大于矿池B不攻击的收益。因此对于矿池B而言，发动攻击是一个可以获得高收益的优势策略。对于矿池A而言，重复上述分析，他的优势策略也是发动攻击。因此这个博弈存在一个&lt;strong&gt;占优策略均衡&lt;/strong&gt;，即状态（攻击，攻击）。这个状态也是一个纳什均衡状态，也就是说，一方参与者独自改变策略，不会增加自己的收益。&lt;/p&gt;

&lt;p&gt;这个博弈模型是一个典型的&lt;strong&gt;囚徒困境&lt;/strong&gt;模型，但是，由于挖矿行为是一直持续的行为，所以这个博弈可以无限次的重复发生，而囚徒困境只进行了一次博弈。在这个模型中，相互发动攻击会造成双方收益的下降，所以对于两个矿池而言最好的状态是达成默契互不攻击（虽然单方攻击可以提升收益，但是如果对方发动反击，双方利益都会受损）。&lt;/p&gt;

&lt;p&gt;当博弈推广到具有多个矿池的一般情况下，矿池之间互相发动攻击依然会造成收益下降；如果有矿池单方面发动攻击也会增加收益，但是有受到报复的风险。总而言之，受到攻击的矿池挖矿的效率并没有得到提升，并且由于其将利润分给了入侵矿工，原有的矿工收益会下降。发动攻击的矿池由于分散了一部分矿工进行攻击，其计算能力也会下降，但是由于入侵其他矿池，他会得到额外的收益。入侵行为会导致整个挖矿系统的算力缩减，进一步会导致比特币系统降低挖矿的难度。在实际挖矿中，矿场可以选择建造自己私密的矿池，开放的矿池可以选择降低自己的规模，从而减少被攻击的风险。上面所描述的博弈模型的数学推导可参考论文[1].&lt;/p&gt;

&lt;p&gt;接下来我们讨论比特币系统中可能存在的另一种类型攻击：贿赂攻击。&lt;/p&gt;

&lt;h2 id=&#34;贿赂攻击者模型与共识算法&#34;&gt;贿赂攻击者模型与共识算法&lt;/h2&gt;

&lt;p&gt;在这个模型中，我们假设有两个候选人A与B，我们想要通过投票的方式从这两个参与者之中选择出一个优胜者。每个参与投票的人可以投一票，最终获得票数最多的候选人赢得胜利；投票给胜利者的候选人可以获得1000人民币的奖励。假设Bob是参与投票的参与者，其获得的收益可以由下图表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bob1.png&#34; alt=&#34;alt text&#34; title=&#34;Schellingcoin1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们现在假设候选人B有很多预算，他准备对投票的参与者发起贿赂，并且承诺付给投票给他的参与者$( 1000 + \epsilon )$人民币，通过贿赂的手段候选人B可以获得胜利，$( \epsilon )$代表一个很小的小数。受到贿赂攻击后的Bob收益如下。可以看到本轮博弈会产生新的均衡点，即接受贿赂攻击者选择投票给贿赂者，由于会有较高的潜在收益，投票给贿赂者还是一个很稳定的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;Bob2.png&#34; alt=&#34;alt text&#34; title=&#34;Schellingcoin2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;比特币系统同样存在这样的潜在攻击威胁，一个攻击者可以通过贿赂其他矿工来让大家同意其挖掘的区块。由于参与者众多，贿赂其他矿工的成本太高（取得其他矿工的信任很难），现在的比特币系统成功的避免了贿赂攻击。关于贿赂攻击的详细讨论可以参考以太坊的博客[3].&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;通过上面的分析，安比(SECBIT)实验室的研究人员为世界杯上法国队和丹麦队的默契球比赛建立了一个博弈模型，并且根据模型分析了产生默契球比赛的原因。消极比赛的行为不仅存在于世界杯比赛，在奥运会羽毛球比赛中也会发生消极比赛的状况,相关报道可参考[2]。接下来的实例分析了在比特币挖矿的场景下，矿池之间的博弈，虽然互相发动攻击是一个均衡状态，但是为了长远的利益考虑，矿池之间通过达成互不攻击的默契可以保证各方的共同利益。最后，我们又讨论了比特币共识算法所存在的潜在攻击威胁，但是由于在现存系统中攻击的成本太高，比特币系统成功的避免了贿赂攻击。&lt;/p&gt;

&lt;p&gt;由于博弈论的广泛应用，已经有很多数学家和经济学家获得了诺贝尔经济学奖，例如，2012年诺贝尔经济学奖颁发给了美国经济学家埃尔文·罗斯（Alvin E. Roth）与罗伊德·沙普利（Lloyd S. Shapley），以表彰他们创建稳定分配理论和进行市场设计的实践。安比(SECBIT)实验室的研究员通过利用博弈论的分析工具对两个不同场景（比赛及加密货币）下的活动进行建模，说明了博弈论和纳什均衡的概念及应用。更进一步，安比(SECBIT)实验室希望开发人员在设计有多个用户参与的智能合约的时候，可以运用博弈论的分析工具对智能合约中的规则进行分析和证明，从而引导参与者做出更有利于全体社会收益的行为。&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] Eyal, I., 2015, May. The miner&amp;rsquo;s dilemma. In Security and Privacy (SP), 2015 IEEE Symposium on (pp. 89-103). IEEE.&lt;/li&gt;
&lt;li&gt;[2] 于洋/王晓理消极比赛 四对女双被取消奥运资格 &lt;a href=&#34;http://2012.163.com/12/0801/20/87RM0LPI000506A2.html&#34;&gt;http://2012.163.com/12/0801/20/87RM0LPI000506A2.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] The P + epsilon Attack. &lt;a href=&#34;https://blog.ethereum.org/2015/01/28/p-epsilon-attack/&#34;&gt;https://blog.ethereum.org/2015/01/28/p-epsilon-attack/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;合作交流请联系info@secbit.io。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;安比（SECBIT）实验室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室专注于区块链与智能合约安全问题，全方位监控智能合约安全漏洞、提供专业合约安全审计服务，在智能合约安全技术上开展全方位深入研究，致力于参与共建共识、可信、有序的区块链经济体。&lt;/p&gt;

&lt;p&gt;安比（SECBIT）实验室创始人郭宇，中国科学技术大学博士、耶鲁大学访问学者、曾任中科大副教授。专注于形式化证明与系统软件研究领域十余年，具有丰富的金融安全产品研发经验，是国内早期关注并研究比特币与区块链技术的科研人员之一。研究专长：区块链技术、形式化验证、程序语言理论、操作系统内核、计算机病毒。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ERC223及ERC827实现代码欠缺安全考虑</title>
      <link>https://sec-bit.github.io/blog/2018/06/24/lacking-insights-in-erc223-erc827-implementation/</link>
      <pubDate>Sun, 24 Jun 2018 08:00:00 +0800</pubDate>
      
      <guid>https://sec-bit.github.io/blog/2018/06/24/lacking-insights-in-erc223-erc827-implementation/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;ATN Token 中的 CUSTOM_CALL 漏洞深入分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;本文部分内容基于安比（SECBIT）实验室团队与吴玉会（轻信科技）的讨论&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;本文结论：ERC223, ERC827的部分实现代码引入了任意函数调用缺陷，可能会对使用这部分代码的合约带来安全漏洞。如果需要实现上述规范接口，请仔细检查实现代码。这种合约本身允许用户自定义 &lt;code&gt;call()&lt;/code&gt; 任意地址上任意函数的设计，十分危险。攻击者可以很容易地借用当前合约的身份来进行&lt;strong&gt;任何操作&lt;/strong&gt;，比如盗取Token或者绕开权限检查等。&lt;/p&gt;

&lt;p&gt;影响范围：截止目前检测到以太坊上部署的受影响的ERC20合约数量：146&lt;/p&gt;

&lt;p&gt;最新更新：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;火币网已经暂停了已经上线交易的相关问题Token[9][10]&lt;/li&gt;
&lt;li&gt;ATN团队已经修复漏洞[1]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;custom-call-滥用事件回顾与分析&#34;&gt;CUSTOM_CALL 滥用事件回顾与分析&lt;/h2&gt;

&lt;p&gt;2018 年 6 月 20 日，AI Technology Network (ATN) 和慢雾团队披露了一起针对 ATN 智能合约的攻击事件，黑客于 2018 年 5 月 11 日利用 ATN Token 合约存在的漏洞，将自己地址设为 owner 并增发获利 1100 万 ATN。ATN 技术团队迅速发现问题、定位攻击方法并完成合约的升级修复 [1]。黑客利用了 ERC223 合约可传入自定义的接收调用函数与 ds-auth 权限校验等特征，在 ERC223 合约调用这个自定义函数时，合约调用自身函数从而造成内部权限控制失效。随后，百度安全的“隐形人真忙”也在先知安全大会上进行了“以太坊智能合约 call 注入攻击”的主题分享 [2]。这个漏洞源于一个较为常见的做法：在调用合约函数之后，可以再次调用一次另一个合约的任意函数，并且这个任意函数可以由合约调用发起者指定。但是 ATN 的合约漏洞恰恰暴露了这一常见做法非常危险的一面：合约调用者可能通过该功能绕开权限检查，或者以合约的身份发起对其它合约的攻击等等。&lt;/p&gt;

&lt;p&gt;有安全隐患代码链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Dexaran/ERC223-token-standard/blob/16d350ec85d5b14b9dc857468c8e0eb4a10572d3/ERC223_Token.sol#L70&#34;&gt;https://github.com/Dexaran/ERC223-token-standard/blob/16d350ec85d5b14b9dc857468c8e0eb4a10572d3/ERC223_Token.sol#L70&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC827/ERC827Token.sol&#34;&gt;https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC827/ERC827Token.sol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;atn-事件漏洞分析&#34;&gt;ATN 事件漏洞分析&lt;/h3&gt;

&lt;p&gt;ERC223 是由 Dexaran 于 2017 年 3 月 5 日提出的一个 Token 标准草案 [3]，用于改进 ERC20，解决其无法处理发往合约自身 Token 的这一问题。ERC20 有两套代币转账机制，一套为直接调用 &lt;code&gt;transfer()&lt;/code&gt; 函数，另一套为调用 &lt;code&gt;approve()&lt;/code&gt; + &lt;code&gt;transferFrom()&lt;/code&gt; 先授权再转账。当转账对象为智能合约时，这种情况必须使用第二套方法，否则转往合约地址的 Token 将永远无法再次转出。&lt;/p&gt;

&lt;p&gt;下面代码为 ERC223 草案中的一段 &lt;strong&gt;正确示例&lt;/strong&gt;，调用 &lt;code&gt;transfer()&lt;/code&gt; 函数时，合约判断目标地址 &lt;code&gt;to&lt;/code&gt; 是否是合约，如果是合约，则调用目标合约的 &lt;code&gt;tokenFallback()&lt;/code&gt; 方法，从而实现合约对转入 Token 的处理。这段代码并没有 CUSTOM_CALL 滥用的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 提案中的正确示例代码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;contract&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ERC223&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;codeLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;assembly&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;codeLength&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;extcodesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;balances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;balances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sub&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;balances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;balances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;codeLength&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// Require proper transaction handling.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nx&#34;&gt;ERC223Receiver&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;receiver&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ERC223Receiver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tokenFallback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ERC223 合约是 ERC20 合约的超集，目标为取代 ERC20 合约，成为新的 Token 合约标准。但提出以来至今一年多的时间仍未得到广泛接受，仅有少数项目采用了该提案。&lt;/p&gt;

&lt;p&gt;下面是 ERC223 &lt;strong&gt;错误实现代码&lt;/strong&gt;，ATN Token不幸地采用了这一段代码。用户被允许传入任意自定义的 &lt;code&gt;_custom_fallback&lt;/code&gt;，从而任意调用目标 &lt;code&gt;_to&lt;/code&gt; 地址上的任意方法！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 此代码有 CUSTOM_CALL 滥用问题
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;transferFrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_amount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_custom_fallback&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;kr&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ERC223ReceivingContract&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;receiver&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ERC223ReceivingContract&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;receiving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;byte4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keccak256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_custom_fallback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;amout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ATN 的漏洞分析报告中称其 Token 合约参考了 ERC223 标准的推荐实现 [4]。经过我们调查，发现其的确与 Dexaran 维护的 ERC223-token-standard 中 Recommended 分支的 &lt;code&gt;transfer()&lt;/code&gt; 方法实现类似 [5]：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 此代码有 CUSTOM_CALL 滥用问题
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_custom_fallback&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;kr&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bytes4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keccak256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_custom_fallback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这其实是很危险的行为！ConsenSys 维护的「以太坊智能合约 —— 最佳安全开发指南」中曾明确提示，要尽量避免合约的外部调用。但在此次攻击事件中，黑客传入的 &lt;code&gt;_custom_fallback&lt;/code&gt; 为 &lt;code&gt;setOwner(address)&lt;/code&gt;，传入的目标地址 &lt;code&gt;_to&lt;/code&gt; 恰好是 ATN 合约本身，间接调用了 ATN 的 &lt;code&gt;setOwner(address)&lt;/code&gt; 方法，使得 &lt;code&gt;msg.sender&lt;/code&gt; 变为 ATN Token 合约本身，从而通过 ds-auth 库的 &lt;code&gt;isAuthorized()&lt;/code&gt; 鉴权校验。&lt;/p&gt;

&lt;p&gt;EVM 读取参数时并不会校验参数个数，在上述例子中，黑客调用了 &lt;code&gt;setOwner(adddress)&lt;/code&gt; 函数，EVM 仅会读取最左边的 &lt;code&gt;_from&lt;/code&gt; 参数。因此使用底层 &lt;code&gt;call()&lt;/code&gt; 方法传参时，参数个数与函数所需不一致并不会引发报错，黑客很容易精心构造出所需的攻击参数。&lt;/p&gt;

&lt;h3 id=&#34;custom-call-滥用的危害&#34;&gt;CUSTOM_CALL 滥用的危害&lt;/h3&gt;

&lt;p&gt;再回到 &lt;code&gt;_custom_fallback&lt;/code&gt; 接口实现上。我们认为作为一个通用 Token 标准接口设计，设计者必须尽可能多地考虑整个系统生态的安全性，尽可能规避因使用不当引入的风险。倘若上面这种 &lt;code&gt;_custom_fallback&lt;/code&gt; 接口设计得到广泛采纳，未来势必会出现更多类似的安全性问题。一个良好的接口设计，最好能做到精简、易用和无歧义。作者提案中 &lt;code&gt;tokenFallback()&lt;/code&gt; 接口完全可以应对其原本想要解决的 ERC20 问题。而实现上引入自定义的 &lt;code&gt;_custom_fallback&lt;/code&gt;，很容易对开发者产生误导并被滥用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;  &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;approveAndCall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;kr&#34;&gt;public&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;payable&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// require(_spender != address(this));
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;approve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通常当我们调用 ERC20 的 &lt;code&gt;approve()&lt;/code&gt; 函数给一个智能合约地址后，对方并不能收到相关通知进行下一步操作，常见做法是利用 &lt;strong&gt;接收通知调用&lt;/strong&gt;（&lt;code&gt;receiverCall&lt;/code&gt;）来解决无法监听的问题。上面代码是一种实现方式，很不幸这段代码有严重的 CUSTOM_CALL 滥用漏洞。调用 &lt;code&gt;approveAndCall()&lt;/code&gt; 函数后，会接着执行 &lt;code&gt;_spender&lt;/code&gt; 上用户自定义的其他方法来进行接收者的后续操作。&lt;/p&gt;

&lt;p&gt;下面敲黑板！&lt;/p&gt;

&lt;p&gt;【&lt;strong&gt;危害&lt;/strong&gt;】：这种合约本身允许用户自定义 &lt;code&gt;call()&lt;/code&gt; 任意地址上任意函数的设计，十分危险。攻击者可以很容易地借用当前合约的身份来进行&lt;strong&gt;任何操作&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这通常会导致两种危险的后果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;后果一&lt;/strong&gt;：允许攻击者以缺陷合约身份来盗走其它 Token 合约中的 Token&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果二&lt;/strong&gt;：与 ds-auth 结合，绕过合约自身的权限检查&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果三&lt;/strong&gt;：允许攻击者以缺陷合约身份来盗走其它 Token 账户所授权（Approve）的 Token&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后果一举例：假设缺陷 Token 合约 A 自身账户中拥有各种 Token B、 C、 D 等，攻击者只需将 &lt;code&gt;_spender&lt;/code&gt; 设为想要盗取的目标 Token （如 B 的地址），再构造用于调用 &lt;code&gt;transfer(address,uint256)&lt;/code&gt; 的 &lt;code&gt;_data&lt;/code&gt;，即可轻松以合约 A 的身份将合约 A 中的各类 Token 转走。上面代码中对 &lt;code&gt;_spender != address(this)&lt;/code&gt; 的校验，也仅能保护 A Token。&lt;/p&gt;

&lt;p&gt;管理各种 Token 的智能合约，倘若也允许自定义 &lt;code&gt;call()&lt;/code&gt;，其合约上的各种 Token 就十分危险了。&lt;/p&gt;

&lt;p&gt;后果二举例：如 ATN 安全事件中，黑客也是借此漏洞利用 ATN 合约的身份，绕过了 ds-auth 的权限控制。&lt;/p&gt;

&lt;p&gt;后果三举例：假设缺陷 Token 合约 A 被用户 X 授权（Approve）管理 10,000 个Token B，那么黑客也是借此漏洞调用&lt;code&gt;transferFrom()&lt;/code&gt;函数来盗取Token B。&lt;/p&gt;

&lt;h3 id=&#34;erc223-提案实现与接口定义不一致&#34;&gt;ERC223 提案实现与接口定义不一致&lt;/h3&gt;

&lt;p&gt;进一步调查我们发现，ERC223 提案的文字接口描述中并没有提到 &lt;code&gt;_custom_fallback&lt;/code&gt; 这一参数的引入和使用。&lt;/p&gt;

&lt;p&gt;以下是该提案规定的接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;nx&#34;&gt;contract&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ERC223Interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;totalSupply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;balanceOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;who&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;constant&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;indexed&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;indexed&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到两个 &lt;code&gt;transfer()&lt;/code&gt; 接口定义中均没有出现 &lt;code&gt;_custom_fallback&lt;/code&gt; 参数。&lt;/p&gt;

&lt;p&gt;我们在来看看提案的文字描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the receiver is a contract ERC223 token contract will try to call tokenFallback function on receiver contract. If there is no tokenFallback function on receiver contract transaction will fail. tokenFallback function is analogue of fallback function for Ether transactions. It can be used to handle incoming transactions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段话的中心思想就是如果 Token 转账目标对象是 ERC223 合约，则尝试调用其 &lt;code&gt;tokenFallback()&lt;/code&gt; 函数，如果目标对象不存在 &lt;code&gt;tokenFallback()&lt;/code&gt; 函数，则让交易 fail 掉。&lt;code&gt;tokenFallback()&lt;/code&gt; 在这里充当的作用就是类似以太转账里的默认 &lt;code&gt;fallback&lt;/code&gt; 函数。&lt;/p&gt;

&lt;p&gt;显然，ERC223 提案的初衷十分清晰，就是约定一个 &lt;code&gt;tokenFallback()&lt;/code&gt; 接口作为 Token 合约标准，用于处理转入的 Token。ERC223 提案主分支的代码实现也没有 &lt;code&gt;_custom_fallback&lt;/code&gt; 的问题。而作者推荐的 Recommended 分支里的代码却增加了一种引入 &lt;code&gt;_custom_fallback&lt;/code&gt; 的 &lt;code&gt;transfer()&lt;/code&gt; 实现，但是没有进行任何风险提示。&lt;/p&gt;

&lt;h3 id=&#34;erc223-代码实现的其他问题&#34;&gt;ERC223 代码实现的其他问题&lt;/h3&gt;

&lt;p&gt;事实上，ERC223 Recommended 分支代码实现还存在其他问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;call()&lt;/code&gt; 在处理 bytes 变量时会引发 evm 层面的 bug，导致数据不一致 [6]。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ERC223_Token.sol#L70
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bytes4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keccak256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_custom_fallback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;event 处理 indexed 的 bytes 变量，在特殊情况下也会引发报错 [7]。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ERC223_Interface.sol#L18
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;indexed&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;indexed&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;indexed&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由此可以推断 ERC223 的 Recommended 分支代码是不成熟的，我们不推荐使用。&lt;/p&gt;

&lt;h2 id=&#34;evm-参数传递机制&#34;&gt;EVM 参数传递机制&lt;/h2&gt;

&lt;p&gt;下面我们解释一下 EVM 中函数调用与参数传递的机制，以便于对这个安全隐患的理解。以如下合约为例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;nx&#34;&gt;contract&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  	      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先了解一下EVM参数传递机制：在调用函数时，如果目标函数有参数，正常情况下我们需要根据ABI指定的参数类型来构造输入。例如 &lt;code&gt;transfer(address to, uint256 value)&lt;/code&gt; 在调用 &lt;code&gt;transfer()&lt;/code&gt; 时，以太坊使用函数签名的哈希值前4字节作为 &lt;code&gt;function selector&lt;/code&gt;，计算 &lt;code&gt;sha3(transfer(address,uint256))&lt;/code&gt; 得到 &lt;code&gt;0xA9059CBB&lt;/code&gt;，再拼接上&lt;code&gt;to&lt;/code&gt;地址，256位补全为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;0x0000000000000000000000003f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;，紧随其后拼接上&lt;code&gt;value&lt;/code&gt;，同样256位补全为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;0x000000000000000000000000000000000000000000000000000000e8d4a51000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最后得到完整的calldata：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;0xa9059cbb0000000000000000000000003f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be000000000000000000000000000000000000000000000000000000e8d4a51000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;将这段 calldata 附加在交易中发送到目标智能合约地址即可实现函数调用。当以太坊节点收到交易时，将 calldata 与智能合约字节码一同加载到 EVM 中，字节码在编译时生成，也意味着对参数的处理在编译时也已经固定下来了。我们查阅以太坊黄皮书可以看到：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们来看一下实际编译出的字节码如何分离 &lt;code&gt;transfer&lt;/code&gt;、&lt;code&gt;address&lt;/code&gt;、&lt;code&gt;value&lt;/code&gt;这三个参数，观察如下字节码片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;80&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;MSTORE&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;CALLDATASIZE&lt;/span&gt; 
&lt;span class=&#34;nx&#34;&gt;LT&lt;/span&gt; 
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;JUMPI&lt;/span&gt; 
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;CALLDATALOAD&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000000000000000000000000000000000000000000000000000000&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;SWAP1&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;DIV&lt;/span&gt; 
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FFFFFFFF&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;AND&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;DUP1&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;A9059CBB&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;EQ&lt;/span&gt; 			
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;JUMPI&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;JUMPDEST&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;PUSH&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;DUP1&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;REVERT&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到在字节码中，出于动态数组的考虑，只会判断 &lt;code&gt;calldata&lt;/code&gt; 是否小于某个最小长度，但是不会检查参数是否过长。编译器会生成一系列 &lt;code&gt;CALLDATALOAD&lt;/code&gt; 配合数学运算来分离出函数需要的参数。首先计算调用的目标函数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CALLDATALOAD&lt;/code&gt; 指令将交易中的 calldata（&lt;code&gt;0xa9059cbb0000000000000000000000003f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be000000000000000000000000000000000000000000000000000000e8d4a51000&lt;/code&gt;）加载到栈中，然后使用除法运算，将数据前256位除以 &lt;code&gt;0x 100000000000000000000000000000000000000000000000000000000&lt;/code&gt;, 得到&lt;code&gt;0xA9059CBB&lt;/code&gt;，以此类推，每个参数都会用类似的方法分离出来。但是当参数过多的时候，字节码、EVM都不会处理，可以直接忽略，所以这个特性主要来源于编译器。黑客利用这一特性可以很容易地针对 CUSTOM_CALL 构造攻击参数。&lt;/p&gt;

&lt;h2 id=&#34;erc827-的有安全隐患代码实现&#34;&gt;ERC827 的有安全隐患代码实现&lt;/h2&gt;

&lt;p&gt;类似的 ERC827 Token 提案也存在相同的问题 [8]。下面的代码来自于 &lt;strong&gt;openzeppelin-solidity&lt;/strong&gt; 的 ERC827 问题代码实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;transferAndCall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;kr&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;payable&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transfer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;该代码在 &lt;code&gt;transferAndCall()&lt;/code&gt; 中转账功能完成后，会调用&lt;code&gt;_to&lt;/code&gt;地址上的任意函数，并且参数由调用者任意指定。由于该函数检查了 &lt;code&gt;_to != address(this)&lt;/code&gt;，因此代码不会产生 与 ds-auth 库结合后绕开权限检查的安全漏洞（&lt;code&gt;后果二&lt;/code&gt;），但是可能会引入前文所提到的 &lt;code&gt;后果一&lt;/code&gt;与&lt;code&gt;后果三&lt;/code&gt;，即可以任意支配问题合约所拥有或管理的 Token（即以 this 合约为跳板攻击其它合约）。&lt;/p&gt;

&lt;p&gt;此外，还有不少 ERC20 Token 加入了类似的 &lt;code&gt;call()&lt;/code&gt; 自定义数据的实现。这种允许自定义 &lt;code&gt;call()&lt;/code&gt; 任意地址上任意函数的设计，十分危险。在特殊情况下，甚至允许攻击者盗走合约中的各种 Token，以及绕过合约本身的权限控制。&lt;/p&gt;

&lt;h2 id=&#34;erc20-erc721-中关于-接收通知调用-正确的代码实现&#34;&gt;ERC20, ERC721 中关于“接收通知调用”正确的代码实现&lt;/h2&gt;

&lt;p&gt;正确的代码实现中，对于“接收通知调用”的处理应该将被通知函数的签名（signature）写死为固定值，避免由攻击者来&lt;strong&gt;任意指定&lt;/strong&gt;的任何可能性。下面举两个例子说明正确的通知调用的写法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;声明Receiver函数，并通过声明的函数进行接收通知调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例如在以太坊官网(ethereum.org)维护的 ERC20 代码中关于通知调用的代码片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;approveAndCall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_extraData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;kr&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;tokenRecipient&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;spender&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tokenRecipient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;approve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;receiveApproval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_extraData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;调用通知采用了正常的函数调用方式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过 Receiver 函数的&lt;strong&gt;签名常量&lt;/strong&gt;进行接收通知调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面一段正确实现代码来自于 Consensys 维护的 Token-Factory 项目&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Approves and then calls the receiving contract */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;approveAndCall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uint256&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_extraData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;allowed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;Approval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn&amp;#39;t have to include a contract in here just for this.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_spender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bytes4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bytes32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sha3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;receiveApproval(address,uint256,address,bytes)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_extraData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面是正确实现“接收通知调用”的代码实现库&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/svenstucki/ERC677&#34;&gt;https://github.com/svenstucki/ERC677&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/ERC721BasicToken.sol#L349&#34;&gt;https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/ERC721BasicToken.sol#L349&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ConsenSys/Token-Factory/blob/master/contracts/HumanStandardToken.sol&#34;&gt;https://github.com/ConsenSys/Token-Factory/blob/master/contracts/HumanStandardToken.sol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ethereum/ethereum-org/blob/b46095815f52cf328ecf7676b2b38284d48fba58/solidity/token-advanced.sol#L138&#34;&gt;https://github.com/ethereum/ethereum-org/blob/b46095815f52cf328ecf7676b2b38284d48fba58/solidity/token-advanced.sol#L138&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结与反思&#34;&gt;总结与反思&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ERC223 标准的实现与接口定义脱节，实现仓库存在两个分支接口不一致，使用&lt;strong&gt;权威代码&lt;/strong&gt;时不能放松警惕&lt;/li&gt;
&lt;li&gt;ERC827 代码同样存在隐患&lt;/li&gt;
&lt;li&gt;用 low-level call 一定要小心&lt;/li&gt;
&lt;li&gt;需要深刻理解 EVM 中关于合约函数调用的实现机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://atn.io/resource/aareport.pdf&#34;&gt;ATN抵御合约攻击的报告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://blog.csdn.net/u011721501/article/details/80757811&#34;&gt;以太坊智能合约call注入攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://github.com/ethereum/EIPs/issues/223&#34;&gt;ERC-223 Token Standard Proposal Draft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] &lt;a href=&#34;https://github.com/ATNIO/atn-contracts/blob/7203781ad8d106ec6d1f9ca8305e76dd1274b181/src/ATN.sol#L114&#34;&gt;ATN.sol transferFrom()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[5] &lt;a href=&#34;https://github.com/Dexaran/ERC223-token-standard/blob/16d350ec85d5b14b9dc857468c8e0eb4a10572d3/ERC223_Token.sol#L70&#34;&gt;ERC223_Token.sol transfer() function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[6] &lt;a href=&#34;https://github.com/Dexaran/ERC223-token-standard/issues/50&#34;&gt;ERC223-token-standard Issue 50&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[7] &lt;a href=&#34;https://github.com/Dexaran/ERC223-token-standard/issues/51&#34;&gt;ERC223-token-standard Issue 51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[8] &lt;a href=&#34;https://github.com/OpenZeppelin/openzeppelin-solidity/blob/f18c3bc438b366f9cb3a8613f5be160c2cbced5e/contracts/token/ERC827/ERC827Token.sol#L73&#34;&gt;ERC827Token.sol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[9] &lt;a href=&#34;https://peckshield.com/2018/06/23/evilReflex/&#34;&gt;New evilReflex Bug Identified in Multiple ERC20 Smart Contracts (CVE-2018-12702, CVE-2018-12703)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[10] &lt;a href=&#34;https://huobiglobal.zendesk.com/hc/en-us/articles/360000110521-HADAX-Suspends-18T-and-GVE-Deposits-and-Withdrawals&#34;&gt;HADAX Suspends 18T and GVE Deposits and Withdrawals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>
